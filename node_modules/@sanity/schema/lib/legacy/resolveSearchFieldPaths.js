"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolveSearchFieldPaths;
const stringFieldsSymbol = Symbol('__cachedStringFields');

function reduceType(type, reducer, accumulator) {
  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  let maxDepth = arguments.length > 4 ? arguments[4] : undefined;

  if (maxDepth < 0) {
    return accumulator;
  }

  if (type.jsonType === 'array' && Array.isArray(type.of)) {
    return reduceArray(type, reducer, accumulator, path, maxDepth);
  }

  if (type.jsonType === 'object' && Array.isArray(type.fields)) {
    return reduceObject(type, reducer, accumulator, path, maxDepth);
  }

  return reducer(accumulator, type, path);
}

function reduceArray(arrayType, reducer, accumulator, path, maxDepth) {
  return arrayType.of.reduce((acc, ofType) => reduceType(ofType, reducer, acc, path, maxDepth - 1), accumulator);
}

function reduceObject(objectType, reducer, accumulator, path, maxDepth) {
  return objectType.fields.reduce((acc, field) => {
    const segment = [field.name].concat(field.type.jsonType === 'array' ? [[]] : []);
    return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);
  }, accumulator);
}

function getCachedStringFieldPaths(type, maxDepth) {
  if (!type[stringFieldsSymbol]) {
    type[stringFieldsSymbol] = getStringFieldPaths(type, maxDepth);
  }

  return type[stringFieldsSymbol];
}

function getStringFieldPaths(type, maxDepth) {
  const reducer = (accumulator, childType, path) => childType.jsonType === 'string' ? [...accumulator, path] : accumulator;

  return reduceType(type, reducer, [], [], maxDepth);
}

function resolveSearchFieldPaths(type) {
  return getCachedStringFieldPaths(type, 4);
}