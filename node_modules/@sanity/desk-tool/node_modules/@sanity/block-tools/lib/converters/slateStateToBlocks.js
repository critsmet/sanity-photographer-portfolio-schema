"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = slateStateToBlocks;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _randomKey = _interopRequireDefault(require("../util/randomKey"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function toSanitySpan(node, sanityBlock, spanIndex) {
  if (node.kind === 'text') {
    return node.ranges.map(range => {
      return {
        _type: 'span',
        _key: `${sanityBlock._key}${spanIndex()}`,
        text: range.text,
        marks: range.marks.map(mark => mark.type)
      };
    });
  }

  if (node.kind === 'inline') {
    const nodes = node.nodes,
          data = node.data;
    return (0, _flatten2.default)(nodes.map(nodesNode => {
      if (nodesNode.kind !== 'text') {
        throw new Error(`Unexpected non-text child node for inline text: ${nodesNode.kind}`);
      }

      if (node.type !== 'span') {
        return node.data.value;
      }

      const annotations = data.annotations;
      const annotationKeys = [];

      if (annotations) {
        Object.keys(annotations).forEach(name => {
          const annotation = annotations[name];
          const annotationKey = annotation._key;

          if (annotation && annotationKey) {
            sanityBlock.markDefs.push(annotation);
            annotationKeys.push(annotationKey);
          }
        });
      }

      return nodesNode.ranges.map(range => ({
        _type: 'span',
        _key: `${sanityBlock._key}${spanIndex()}`,
        text: range.text,
        marks: range.marks.map(mark => mark.type).concat(annotationKeys)
      }));
    }));
  }

  throw new Error(`Unsupported kind ${node.kind}`);
}

function toSanityBlock(block) {
  if (block.type === 'contentBlock') {
    const sanityBlock = _objectSpread({}, block.data, {
      _type: 'block',
      _key: block.key || block.data._key || (0, _randomKey.default)(12),
      markDefs: []
    });

    let index = 0;

    const spanIndex = () => {
      return index++;
    };

    sanityBlock.children = (0, _flatten2.default)(block.nodes.map(node => {
      return toSanitySpan(node, sanityBlock, spanIndex);
    }));
    return sanityBlock;
  }

  return block.data.value;
}

function isEmpty(blocks) {
  if (blocks.length === 0) {
    return true;
  }

  if (blocks.length > 1) {
    return false;
  }

  const firstBlock = blocks[0];

  if (firstBlock._type !== 'block') {
    return false;
  }

  const children = firstBlock.children;

  if (children.length === 0) {
    return true;
  }

  if (children.length > 1) {
    return false;
  }

  const firstChild = children[0];

  if (firstChild._type !== 'span') {
    return false;
  }

  return firstChild.text.length === 0;
}

function slateStateToBlocks(json) {
  const nodes = (0, _get2.default)(json, 'document.nodes');

  if (!nodes || nodes.length === 0) {
    return undefined;
  }

  const blocks = nodes.map(toSanityBlock).filter(Boolean);
  return isEmpty(blocks) ? undefined : blocks;
}