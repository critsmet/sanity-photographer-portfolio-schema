"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _default = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _popover = _interopRequireDefault(require("part:@sanity/components/dialogs/popover"));

var _content = _interopRequireDefault(require("part:@sanity/components/dialogs/content"));

var _FormBuilderInput = require("../../FormBuilderInput");

var _FormBuilderSpan = _interopRequireDefault(require("./styles/FormBuilderSpan.css"));

var _simplePatch = require("../../simplePatch");

var _StopPropagation = _interopRequireDefault(require("./StopPropagation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function isEmpty(object, ignoreKeys) {
  for (const key in object) {
    if (!ignoreKeys.includes(key)) {
      return false;
    }
  }

  return true;
}

class FormBuilderSpan extends _react.default.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isEditing: false,
      focusedAnnotationName: undefined
    });

    _defineProperty(this, "_clickCounter", 0);

    _defineProperty(this, "_isMarkingText", false);

    _defineProperty(this, "_editorNodeRect", null);

    _defineProperty(this, "destroy", () => {
      this.props.editor.props.blockEditor.operations.removeSpan(this.props.node);
    });

    _defineProperty(this, "isEmptyAnnotation", annotation => {
      return isEmpty(annotation, ['_type', '_key']);
    });

    _defineProperty(this, "handleCloseInput", () => {
      this.props.editor.focus();

      if (this.state.isEditing) {
        this.setState({
          isEditing: false,
          focusedAnnotationName: undefined
        });
      }

      this.garbageCollect();
    });

    _defineProperty(this, "handleMouseDown", () => {
      this._isMarkingText = true;
      setTimeout(() => {
        if (this._clickCounter === 1 && !this._isMarkingText) {
          this.setState({
            isEditing: true
          });
        }

        this._clickCounter = 0;
      }, 350);
      this._clickCounter++;
    });

    _defineProperty(this, "handleMouseUp", () => {
      this._isMarkingText = false;
    });

    _defineProperty(this, "handleNodeClick", () => {
      const annotations = this.getAnnotations(); // Don't do anyting if this type doesn't have annotations.

      if (this.props.type.annotations.length === 0) {
        return;
      } // Try to figure out which annotation that should be focused when user clicks the span


      let focusedAnnotationName;

      if (this.props.type.annotations.length === 1) {
        // Only one annotation type, always focus this one
        focusedAnnotationName = this.props.type.annotations[0].name;
      } else if (annotations && Object.keys(annotations).length === 1) {
        // Only one annotation value, focus it
        focusedAnnotationName = annotations[Object.keys(annotations)[0]]._type;
      }

      if (focusedAnnotationName) {
        this.focusAnnotation(focusedAnnotationName);
      } // If no focusedAnnotationName was found, buttons to edit respective annotations will be show

    });

    _defineProperty(this, "handleAnnotationChange", event => {
      const name = this.state.focusedAnnotationName;
      const annotations = this.getAnnotations();

      const nextAnnotations = _objectSpread({}, annotations, {
        [name]: (0, _simplePatch.applyAll)(annotations[name], event.patches)
      });

      Object.keys(nextAnnotations).forEach(key => {
        if (nextAnnotations[key] === undefined) {
          delete nextAnnotations[key];
        }
      });
      const _this$props = this.props,
            node = _this$props.node,
            editor = _this$props.editor;

      const data = _objectSpread({}, node.data.toObject(), {
        focusedAnnotationName: this.state.focusedAnnotationName,
        annotations: nextAnnotations
      });

      const change = editor.getState().change().setNodeByKey(node.key, {
        data
      });
      editor.onChange(change);
    });

    _defineProperty(this, "setRootElement", element => {
      this.setState({
        rootElement: element
      });
    });
  }

  componentWillMount() {
    this.setState({
      isEditing: false,
      focusedAnnotationName: this.props.node.data && this.props.node.data.get('focusedAnnotationName')
    });
  }

  componentDidMount() {
    this._editorNodeRect = _reactDom.default.findDOMNode(this.props.editor).getBoundingClientRect();

    if (this.state.focusedAnnotationName) {
      this.setState({
        isEditing: true
      });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return nextState.isEditing !== this.state.isEditing || nextState.rootElement !== this.state.rootElement || nextState.focusedAnnotationName !== this.state.focusedAnnotationName || nextProps.state.focusOffset !== this.props.state.focusOffset || nextProps.node.data !== this.props.node.data;
  }

  componentWillUpdate(nextProps, nextState) {
    // If annotations where emptied, just destroy this span (unwrap it to text actually)
    if (!nextProps.node.data.get('annotations')) {
      this.destroy();
    }
  }

  componentDidUpdate() {
    // Close popover and clean up if it is unnanotated and no annotation type is in focus
    if (this.isUnannotated() && this.state.isEditing && !this.state.focusedAnnotationName) {
      this.handleCloseInput();
    }
  }

  isUnannotated() {
    const annotations = this.getAnnotations();

    if (!annotations) {
      return true;
    }

    return !Object.keys(annotations).filter(key => {
      return !this.isEmptyAnnotation(annotations[key]);
    }).length === 0;
  }

  getAnnotations() {
    return this.props.node.data.get('annotations');
  }

  garbageCollect() {
    let nextAnnotations = _objectSpread({}, this.getAnnotations());

    Object.keys(nextAnnotations).forEach(key => {
      if (this.isEmptyAnnotation(nextAnnotations[key])) {
        delete nextAnnotations[key];
      }
    });
    const _this$props2 = this.props,
          editor = _this$props2.editor,
          node = _this$props2.node;

    if (Object.keys(nextAnnotations).length === 0) {
      nextAnnotations = undefined;
    }

    const data = _objectSpread({}, node.data.toObject(), {
      focusedAnnotationName: undefined,
      annotations: nextAnnotations
    });

    const change = editor.getState().change().setNodeByKey(node.key, {
      data
    });
    editor.onChange(change);
  }

  focusAnnotation(annotationName) {
    const _this$props3 = this.props,
          editor = _this$props3.editor,
          node = _this$props3.node;
    this.setState({
      focusedAnnotationName: annotationName
    });

    const data = _objectSpread({}, node.data.toObject(), {
      focusedAnnotationName: annotationName
    });

    const change = editor.getState().change().setNodeByKey(node.key, {
      data
    });
    editor.onChange(change);
  } // Open dialog when user clicks the node,
  // but support double clicks, and mark text as normal


  renderInput() {
    const annotations = this.getAnnotations();
    const annotationTypes = this.props.type.annotations;
    const focusedAnnotationName = this.state.focusedAnnotationName;
    const annotationTypeInFocus = annotationTypes.find(type => {
      return type.name === focusedAnnotationName;
    });
    const focusedAnnotationKey = Object.keys(annotations).find(key => {
      return annotations[key]._type === focusedAnnotationName;
    });
    const annotationValue = focusedAnnotationKey && annotations && annotations[focusedAnnotationKey];
    return _react.default.createElement("span", {
      className: _FormBuilderSpan.default.editSpanContainer
    }, _react.default.createElement(_popover.default, {
      onClose: this.handleCloseInput,
      onEscape: this.handleCloseInput,
      onClickOutside: this.handleCloseInput,
      modifiers: {
        flip: {
          boundariesElement: 'viewport'
        },
        preventOverflow: {
          priority: ['bottom', 'top', 'right', 'left'],
          boundariesElement: 'viewport'
        }
      }
    }, !focusedAnnotationName && Object.keys(annotations).length > 1 && _react.default.createElement("div", null, _react.default.createElement("h3", null, "Which annotation?"), Object.keys(annotations).map(annotationKey => {
      if (!annotations[annotationKey]) {
        return null;
      }

      const setFieldFunc = () => {
        this.focusAnnotation(annotations[annotationKey]._type);
      };

      return _react.default.createElement(_default.default, {
        key: `annotationButton${annotationKey}`,
        onClick: setFieldFunc
      }, annotationTypes.find(type => type.name === annotations[annotationKey]._type).title);
    })), focusedAnnotationName && _react.default.createElement(_content.default, {
      size: "medium"
    }, _react.default.createElement(_FormBuilderInput.FormBuilderInput, {
      value: annotationValue,
      type: annotationTypeInFocus,
      level: 0,
      onChange: this.handleAnnotationChange,
      autoFocus: true
    }))));
  }

  render() {
    const isEditing = this.state.isEditing;
    const attributes = this.props.attributes;
    return _react.default.createElement("span", _extends({}, attributes, {
      className: _FormBuilderSpan.default.root,
      ref: this.setRootElement
    }), _react.default.createElement("span", {
      onClick: this.handleNodeClick,
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp
    }, this.props.children), isEditing && _react.default.createElement(_StopPropagation.default, {
      tagName: "span"
    }, this.renderInput()));
  }

}

exports.default = FormBuilderSpan;

_defineProperty(FormBuilderSpan, "propTypes", {
  type: _propTypes.default.object,
  editor: _propTypes.default.object,
  state: _propTypes.default.object,
  attributes: _propTypes.default.object,
  children: _propTypes.default.node,
  node: _propTypes.default.object
});