"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _slate = require("slate");

var _slateReact = require("slate-react");

var _fullscreen = _interopRequireDefault(require("part:@sanity/components/dialogs/fullscreen?"));

var _scrollContainer = _interopRequireDefault(require("part:@sanity/components/utilities/scroll-container"));

var _activateOnFocus = _interopRequireDefault(require("part:@sanity/components/utilities/activate-on-focus"));

var _default = _interopRequireDefault(require("part:@sanity/components/formfields/default"));

var _Toolbar = _interopRequireDefault(require("./toolbar/Toolbar"));

var _createBlockEditorOperations = _interopRequireDefault(require("./createBlockEditorOperations"));

var _prepareSlateForBlockEditor = _interopRequireDefault(require("./util/prepareSlateForBlockEditor"));

var _initializeSlatePlugins = _interopRequireDefault(require("./util/initializeSlatePlugins"));

var _BlockEditor = _interopRequireDefault(require("./styles/BlockEditor.css"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const NOOP = () => {};

class BlockEditor extends _react.default.Component {
  constructor(props, context) {
    super(props, context);

    _defineProperty(this, "state", {
      fullscreen: false,
      toolbarStyle: {},
      preventScroll: false,
      editorHasFocus: false
    });

    _defineProperty(this, "_inputId", (0, _uniqueId2.default)('SlateBlockEditor'));

    _defineProperty(this, "checkScrollHeight", () => {
      if (!this._inputContainer || !this._editorWrapper) {
        return;
      }

      const inputHeight = this._inputContainer.offsetHeight;
      const contentHeight = this._editorWrapper.offsetHeight;

      if (contentHeight > inputHeight) {
        this.setState({
          preventScroll: true
        });
      }
    });

    _defineProperty(this, "handleNodePatch", event => this.props.onNodePatch(event));

    _defineProperty(this, "handleInsertBlock", item => {
      if (item.options && item.options.inline) {
        this.operations.insertInline(item);
        return;
      }

      this.operations.insertBlock(item);
    });

    _defineProperty(this, "handleOnClickMarkButton", mark => {
      this.operations.toggleMark(mark);
    });

    _defineProperty(this, "handleOnClickListFormattingButton", (listItem, isActive) => {
      this.editor.focus();
      this.operations.toggleListItem(listItem, isActive);
    });

    _defineProperty(this, "handleAnnotationButtonClick", annotation => {
      this.editor.focus();

      if (annotation.active) {
        const value = this.props.value;
        const spans = value.inlines.filter(inline => inline.type == _constants.SLATE_SPAN_TYPE);
        spans.forEach(span => {
          this.operations.removeAnnotationFromSpan(span, annotation.type);
        });
        return;
      }

      this.operations.createFormBuilderSpan(annotation.type);
    });

    _defineProperty(this, "handleBlockStyleChange", selectedValue => {
      this.operations.setBlockStyle(selectedValue.style.value);
    });

    _defineProperty(this, "handleToggleFullscreen", () => {
      this.setState(prevState => ({
        fullscreen: !prevState.fullscreen
      }));
    });

    _defineProperty(this, "refEditor", editor => {
      this.editor = editor;
    });

    _defineProperty(this, "refBlockDragMarker", marker => {
      this.blockDragMarker = marker;
    });

    _defineProperty(this, "handleEditorContainerClick", () => {
      this.editor.focus();
    });

    _defineProperty(this, "handleEditorFocus", event => {
      this.props.onFocus();
      this.setState({
        editorHasFocus: true
      });
    });

    _defineProperty(this, "handleEditorBlur", event => {
      this.setState({
        editorHasFocus: false
      });
    });

    _defineProperty(this, "handleInputScroll", event => {// Prevents the parent container to scroll when user tries
      // to scroll to the top/bottom of the block editor with momentum scroll or
      // a speedy mouse wheel
      // This makes the block-editor more usable when scrolling inside it.

      /*
      Enable this when activeOnFocus is finished
       const el = this._inputContainer
      const scrollTop = el.scrollTop
      const scrollHeight = el.scrollHeight
      const height = el.clientHeight
       if (this.state.fullscreen) {
        return
      }
       if (event.nativeEvent.deltaY <= 0) {
        // scrolling up
        if (scrollTop <= 0) {
          event.preventDefault()
        }
      } else if (scrollTop + height >= scrollHeight) {
        // scrolling down
        event.preventDefault()
      }
      */
    });

    _defineProperty(this, "setInputContainerElement", element => {
      this._inputContainer = element;
    });

    _defineProperty(this, "setEditorWrapper", element => {
      this._editorWrapper = element;
    });

    _defineProperty(this, "handleFullScreenScroll", event => {
      const threshold = 100;
      const scrollTop = event.target.scrollTop;
      let ratio = scrollTop / threshold;

      if (ratio >= 1) {
        ratio = 1;
      }

      this.setState({
        toolbarStyle: {
          backgroundColor: `rgba(255, 255, 255, ${ratio * 0.95})`,
          boxShadow: `0 2px ${5 * ratio}px rgba(0, 0, 0, ${ratio * 0.3})`
        }
      });
    });

    _defineProperty(this, "handleFullScreenClose", () => {
      this.setState({
        fullscreen: false
      });
    });

    const preparation = (0, _prepareSlateForBlockEditor.default)(this);
    this.slateSchema = preparation.slateSchema;
    this.textStyles = preparation.textStyles;
    this.listItems = preparation.listItems;
    this.annotationTypes = preparation.annotationTypes;
    this.customBlocks = preparation.customBlocks;
    this.operations = (0, _createBlockEditorOperations.default)(this);
    this.slatePlugins = (0, _initializeSlatePlugins.default)(this);
  }

  componentDidMount() {
    window.addEventListener('keydown', this.handleKeyDown); // this._inputContainer.addEventListener('mousewheel', this.handleInputScroll)

    this.checkScrollHeight();
  }

  componentWillUnmount() {
    window.removeEventListener('keydown', this.handleKeyDown); // this._inputContainer.removeEventListener('mousewheel', this.handleInputScroll)
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps !== this.props) {
      this.checkScrollHeight();
    }
  }

  hasAnnotationType(annotationType) {
    const value = this.props.value;
    const spans = value.inlines.filter(inline => inline.type == _constants.SLATE_SPAN_TYPE);
    return spans.some(span => {
      const annotations = span.data.get('annotations') || {};
      return Object.keys(annotations).find(key => annotations[key]._type === annotationType.name);
    });
  }

  getActiveAnnotations() {
    const value = this.props.value;
    const focusBlock = value.focusBlock;
    const disabled = value.inlines.some(inline => inline.type !== _constants.SLATE_SPAN_TYPE) || (focusBlock ? focusBlock.isVoid || focusBlock.text === '' : false);
    return this.annotationTypes.map(annotationType => {
      const active = this.hasAnnotationType(annotationType);
      return {
        active: active,
        type: annotationType,
        disabled: disabled
      };
    });
  }

  hasStyle(styleName) {
    const value = this.props.value;
    return value.blocks.some(block => block.data.get('style') === styleName);
  }

  getBlockStyles() {
    function Preview(props) {
      return _react.default.createElement("span", null, props.children);
    }

    const items = this.textStyles.map((style, index) => {
      return {
        key: `blockFormat-${index}`,
        style: style,
        preview: this.slateSchema.nodes.contentBlock({
          children: [_react.default.createElement(Preview, {
            key: style.value,
            parent: {
              data: _slate.Data.create({
                style: style.value
              })
            }
          }, style.title)]
        }),
        title: ` ${style.title}`,
        active: this.hasStyle(style.value)
      };
    });
    let value = items.filter(item => item.active);

    if (value.length === 0) {
      value = [{
        key: 'blockFormat-none',
        preview: null,
        type: null,
        title: 'No style',
        active: true
      }];
    }

    return {
      items: items,
      value: value
    };
  }

  hasDecorator(decoratorName) {
    const value = this.props.value;
    return value.marks.some(mark => mark.type == decoratorName);
  }

  getActiveDecorators() {
    return Object.keys(this.slateSchema.marks).map(decorator => {
      return {
        type: decorator,
        active: this.hasDecorator(decorator)
      };
    });
  }

  hasListItem(listItem) {
    const value = this.props.value;
    return value.blocks.some(block => {
      return block.data.get('listItem') === listItem;
    });
  }

  getListItems() {
    return this.listItems.map((item, index) => {
      return {
        type: item.value,
        title: item.title,
        active: this.hasListItem(item.value)
      };
    });
  }

  focus() {
    this.editor.focus();
  }

  showBlockDragMarker(pos, node) {
    this.blockDragMarker.style.display = 'block';

    const editorDOMNode = _reactDom.default.findDOMNode(this.editor);

    const editorRect = editorDOMNode.getBoundingClientRect();
    const elemRect = node.getBoundingClientRect();
    const topPos = elemRect.top - editorRect.top;
    const bottomPos = topPos + (elemRect.bottom - elemRect.top);

    if (pos == 'after') {
      this.blockDragMarker.style.top = `${parseInt(bottomPos, 0)}px`;
    } else {
      this.blockDragMarker.style.top = `${parseInt(topPos, 0)}px`;
    }
  }

  hideBlockDragMarker() {
    this.blockDragMarker.style.display = 'none';
  }

  renderBlockEditor() {
    const _this$props = this.props,
          value = _this$props.value,
          onChange = _this$props.onChange,
          readOnly = _this$props.readOnly;
    const _this$state = this.state,
          fullscreen = _this$state.fullscreen,
          toolbarStyle = _this$state.toolbarStyle,
          preventScroll = _this$state.preventScroll,
          editorHasFocus = _this$state.editorHasFocus;
    return _react.default.createElement("div", {
      className: `${_BlockEditor.default.root} ${fullscreen ? _BlockEditor.default.fullscreen : ''}`
    }, _react.default.createElement(_activateOnFocus.default, {
      isActive: editorHasFocus || fullscreen || !preventScroll,
      message: "Click to edit"
    }, !readOnly && _react.default.createElement(_Toolbar.default, {
      className: _BlockEditor.default.toolbar,
      onInsertBlock: this.handleInsertBlock,
      insertBlocks: this.customBlocks,
      onFullscreenEnable: this.handleToggleFullscreen,
      fullscreen: this.state.fullscreen,
      onMarkButtonClick: this.handleOnClickMarkButton,
      onAnnotationButtonClick: this.handleAnnotationButtonClick,
      onListButtonClick: this.handleOnClickListFormattingButton,
      onBlockStyleChange: this.handleBlockStyleChange,
      listItems: this.getListItems(),
      blockStyles: this.getBlockStyles(),
      annotations: this.getActiveAnnotations(),
      decorators: this.getActiveDecorators(),
      style: toolbarStyle
    }), _react.default.createElement("div", {
      className: _BlockEditor.default.inputContainer,
      id: this._inputId,
      onClick: this.handleEditorContainerClick,
      ref: this.setInputContainerElement,
      onWheel: this.handleInputScroll
    }, _react.default.createElement("div", {
      ref: this.setEditorWrapper
    }, _react.default.createElement(_slateReact.Editor, {
      ref: this.refEditor,
      className: _BlockEditor.default.input,
      onChange: readOnly ? NOOP : onChange,
      placeholder: "",
      readOnly: readOnly,
      state: value,
      blockEditor: this,
      plugins: this.slatePlugins,
      schema: this.slateSchema,
      onFocus: this.handleEditorFocus,
      onBlur: this.handleEditorBlur
    }), _react.default.createElement("div", {
      ref: this.refBlockDragMarker,
      style: {
        display: 'none'
      },
      className: _BlockEditor.default.blockDragMarker
    })))));
  }

  render() {
    const _this$props2 = this.props,
          type = _this$props2.type,
          level = _this$props2.level,
          markers = _this$props2.markers;
    const fullscreen = this.state.fullscreen;
    const blockEditor = this.renderBlockEditor();
    return _react.default.createElement(_default.default, {
      markers: markers,
      label: type.title,
      description: type.description,
      labelFor: this._inputId,
      level: level
    }, _react.default.createElement("button", {
      type: "button",
      tabIndex: 0,
      className: _BlockEditor.default.focusSkipper,
      onClick: () => this.focus()
    }, "Jump to editor"), fullscreen ? _react.default.createElement(_fullscreen.default, {
      isOpen: true,
      onClose: this.handleFullScreenClose
    }, _react.default.createElement(_scrollContainer.default, {
      className: _BlockEditor.default.portal,
      onScroll: this.handleFullScreenScroll
    }, blockEditor)) : blockEditor);
  }

}

exports.default = BlockEditor;

_defineProperty(BlockEditor, "propTypes", {
  type: _propTypes.default.any,
  level: _propTypes.default.number,
  value: _propTypes.default.instanceOf(_slate.State),
  markers: _propTypes.default.arrayOf(_propTypes.default.shape({
    type: _propTypes.default.string.isRequired
  })),
  onChange: _propTypes.default.func,
  onFocus: _propTypes.default.func,
  readOnly: _propTypes.default.bool,
  onNodePatch: _propTypes.default.func
});

_defineProperty(BlockEditor, "defaultProps", {
  onChange() {},

  markers: []
});

_defineProperty(BlockEditor, "contextTypes", {
  formBuilder: _propTypes.default.object
});