"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _offsetKey = _interopRequireDefault(require("slate-react/lib/utils/offset-key"));

var _setTransferData = _interopRequireDefault(require("slate-react/lib/utils/set-transfer-data"));

var _transferTypes = _interopRequireDefault(require("slate-react/lib/constants/transfer-types"));

var _slateBase64Serializer = _interopRequireDefault(require("slate-base64-serializer"));

var _slateReact = require("slate-react");

var _FormBuilderInput = require("../../FormBuilderInput");

var _default = _interopRequireDefault(require("part:@sanity/components/dialogs/default"));

var _content = _interopRequireDefault(require("part:@sanity/components/dialogs/content"));

var _fullscreen = _interopRequireDefault(require("part:@sanity/components/dialogs/fullscreen"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _popover = _interopRequireDefault(require("part:@sanity/components/dialogs/popover"));

var _fold = _interopRequireDefault(require("part:@sanity/components/edititem/fold"));

var _Preview = _interopRequireDefault(require("../../Preview"));

var _FormBuilderBlock = _interopRequireDefault(require("./styles/FormBuilderBlock.css"));

var _createRange = _interopRequireDefault(require("./util/createRange"));

var _resolveTypeName = require("../../utils/resolveTypeName");

var _InvalidValueInput = _interopRequireDefault(require("../InvalidValueInput"));

var _SimpleFocusManager = _interopRequireDefault(require("../../sanity/focusManagers/SimpleFocusManager"));

var _editIcon = _interopRequireDefault(require("part:@sanity/base/edit-icon"));

var _StopPropagation = _interopRequireDefault(require("./StopPropagation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DIALOG_ACTIONS = [{
  index: '1',
  name: 'close',
  title: 'Close' // {
  //   index: '2',
  //   name: 'delete',
  //   kind: 'simple',
  //   title: 'Delete',
  //   color: 'danger',
  //   secondary: true
  // }

}];

class FormBuilderBlock extends _react.default.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isSelected: false,
      isEditing: false,
      isDragging: false
    });

    _defineProperty(this, "_dropTarget", null);

    _defineProperty(this, "_editorNode", null);

    _defineProperty(this, "handleChange", event => {
      const _this$props = this.props,
            onPatch = _this$props.onPatch,
            node = _this$props.node;
      onPatch(event.prefixAll(node.key));
    });

    _defineProperty(this, "handleInvalidValueChange", event => {
      const _this$props2 = this.props,
            onPatch = _this$props2.onPatch,
            node = _this$props2.node;
      onPatch(event.prefixAll(node.key));
    });

    _defineProperty(this, "handleDragStart", event => {
      const editor = this.props.editor;
      this._editorNode = _reactDom.default.findDOMNode(editor);
      this.setState({
        isDragging: true
      });
      this.addDragHandlers();

      const element = _reactDom.default.findDOMNode(this.previewContainer);

      const encoded = _slateBase64Serializer.default.serializeNode(this.props.node, {
        preserveKeys: true
      });

      (0, _setTransferData.default)(event.dataTransfer, _transferTypes.default.NODE, encoded);
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setDragImage(element, element.clientWidth / 2, -10);
    });

    _defineProperty(this, "handleSelectionChange", event => {
      if (!this._editorNode || !this._editorNode.contains(event.target)) {
        return;
      }

      const selection = document.getSelection();
      const isSelected = selection.containsNode && selection.containsNode(this.formBuilderBlock);
      this.setState({
        isSelected
      });
    });

    _defineProperty(this, "handleDragLeave", event => {
      this.hideBlockDragMarker();

      if (event.target === this._editorNode) {
        this.resetDropTarget();
      }
    });

    _defineProperty(this, "handleDragOverOtherNode", event => {
      if (!this.state.isDragging) {
        return;
      }

      const targetDOMNode = event.target; // As the event is registered on the editor parent node
      // ignore the event if it is coming from from the editor node itself

      if (targetDOMNode === this._editorNode) {
        return;
      }

      const offsetKey = _offsetKey.default.findKey(targetDOMNode, 0);

      if (!offsetKey) {
        return;
      }

      const key = offsetKey.key;
      const editor = this.props.editor;
      const state = editor.getState();
      const document = state.document;
      const range = (0, _createRange.default)(event);

      if (range === null) {
        return;
      }

      const rangeIsAtStart = range.rangeIsAtStart,
            rangeOffset = range.rangeOffset;
      const node = document.getClosestBlock(key);

      if (!node) {
        this.resetDropTarget();
        return;
      }

      const domNode = (0, _slateReact.findDOMNode)(node);

      if (rangeIsAtStart) {
        this.showBlockDragMarker('before', domNode);
      } else {
        this.showBlockDragMarker('after', domNode);
      }

      this._dropTarget = {
        node: node,
        isAtStart: rangeIsAtStart,
        offset: rangeOffset
      };
    });

    _defineProperty(this, "handleDragEnd", event => {
      this.setState({
        isDragging: false
      });
      this.removeDragHandlers();
      const _this$props3 = this.props,
            editor = _this$props3.editor,
            node = _this$props3.node;
      const state = editor.getState();
      const target = this._dropTarget; // Return if this is our node

      if (!target || target.node === node) {
        this.resetDropTarget();
        return;
      }

      let nextChange = state.change().removeNodeByKey(node.key);
      nextChange = nextChange[target.isAtStart ? 'collapseToStartOf' : 'collapseToEndOf'](target.node).insertBlock(node).collapseToEndOf(node).focus();
      editor.onChange(nextChange);
      this.resetDropTarget();
    });

    _defineProperty(this, "handleCancelEvent", event => {
      event.preventDefault();
    });

    _defineProperty(this, "handleToggleEdit", () => {
      this.setState({
        isEditing: true
      });
    });

    _defineProperty(this, "handleClose", () => {
      this.setState({
        isEditing: false
      });
    });

    _defineProperty(this, "handleDialogAction", action => {
      if (action.name === 'close') {
        this.handleClose();
      }

      if (action.name === 'delete') {// Implement delete
      }
    });

    _defineProperty(this, "refFormBuilderBlock", formBuilderBlock => {
      this.formBuilderBlock = formBuilderBlock;
    });

    _defineProperty(this, "refPreview", previewContainer => {
      this.previewContainer = previewContainer;
    });

    _defineProperty(this, "renderFormBuilderInput", ({
      onFocus,
      onBlur,
      focusPath
    }) => {
      const value = this.getValue();
      const memberType = this.getMemberTypeOf(value);
      return _react.default.createElement("div", {
        style: {
          padding: '1rem'
        }
      }, _react.default.createElement(_FormBuilderInput.FormBuilderInput, {
        type: memberType,
        level: 1,
        value: value,
        onChange: this.handleChange,
        onFocus: onFocus,
        onBlur: onBlur,
        focusPath: focusPath,
        path: [{
          _key: value._key
        }]
      }));
    });
  }

  componentDidMount() {
    this.addSelectionHandler();
  }

  componentWillUnmount() {
    this.removeSelectionHandler();
  }

  addSelectionHandler() {
    document.addEventListener('selectionchange', this.handleSelectionChange);
  }

  removeSelectionHandler() {
    document.removeEventListener('selectionchange', this.handleSelectionChange);
  }

  addDragHandlers() {
    this._editorNode.addEventListener('dragover', this.handleDragOverOtherNode);

    this._editorNode.addEventListener('dragleave', this.handleDragLeave);
  }

  removeDragHandlers() {
    this._editorNode.removeEventListener('dragover', this.handleDragOverOtherNode);

    this._editorNode.removeEventListener('dragleave', this.handleDragLeave);
  }

  resetDropTarget() {
    this._dropTarget = null;
    this.hideBlockDragMarker();
  }

  getValue() {
    return this.props.node.data.get('value');
  }

  getMemberTypeOf(value) {
    const typeName = (0, _resolveTypeName.resolveTypeName)(value);
    return this.props.type.of.find(memberType => memberType.name === typeName);
  }

  renderPreview() {
    const value = this.getValue();
    const memberType = this.getMemberTypeOf(value);

    if (!memberType) {
      const validMemberTypes = this.props.type.of.map(type => type.name);
      const actualType = (0, _resolveTypeName.resolveTypeName)(value);
      return _react.default.createElement(_InvalidValueInput.default, {
        validTypes: validMemberTypes,
        actualType: actualType,
        value: value,
        onChange: this.handleInvalidValueChange
      });
    }

    return _react.default.createElement(_Preview.default, {
      type: memberType,
      value: this.getValue(),
      layout: "block"
    });
  }

  renderInput() {
    const editModalLayout = (0, _get2.default)(this.props.type.options, 'editModal');

    const input = _react.default.createElement(_SimpleFocusManager.default, null, this.renderFormBuilderInput);

    if (editModalLayout === 'fullscreen') {
      return _react.default.createElement(_fullscreen.default, {
        isOpen: true,
        title: this.props.node.title,
        onClose: this.handleClose
      }, input);
    }

    if (editModalLayout === 'popover') {
      return _react.default.createElement("div", {
        className: _FormBuilderBlock.default.editBlockContainerPopOver
      }, _react.default.createElement(_popover.default, {
        title: this.props.node.title,
        onClose: this.handleClose,
        onEscape: this.handleClose,
        onClickOutside: this.handleClose,
        onAction: this.handleDialogAction,
        actions: DIALOG_ACTIONS
      }, _react.default.createElement(_content.default, {
        size: "medium"
      }, input)));
    }

    return _react.default.createElement(_default.default, {
      isOpen: true,
      title: this.props.node.title,
      onClose: this.handleClose,
      showCloseButton: false,
      onAction: this.handleDialogAction,
      actions: DIALOG_ACTIONS
    }, _react.default.createElement(_content.default, {
      size: "medium"
    }, input));
  }

  showBlockDragMarker(pos, node) {
    const editor = this.props.editor;
    editor.props.blockEditor.showBlockDragMarker(pos, node);
  }

  hideBlockDragMarker() {
    const editor = this.props.editor;
    editor.props.blockEditor.hideBlockDragMarker();
  }

  render() {
    const isEditing = this.state.isEditing;
    const _this$props4 = this.props,
          attributes = _this$props4.attributes,
          node = _this$props4.node,
          editor = _this$props4.editor;
    const isFocused = editor.props.blockEditor.props.value.selection.hasFocusIn(node);
    let className;

    if (isFocused && !this.state.isSelected) {
      className = _FormBuilderBlock.default.focused;
    } else if (this.state.isSelected) {
      className = _FormBuilderBlock.default.selected;
    } else {
      className = _FormBuilderBlock.default.root;
    }

    const value = this.getValue();
    const memberType = this.getMemberTypeOf(value);
    return _react.default.createElement("div", _extends({}, attributes, {
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd,
      onDragEnter: this.handleCancelEvent,
      onDragLeave: this.handleCancelEvent,
      onDrop: this.handleCancelEvent,
      draggable: true,
      ref: this.refFormBuilderBlock,
      className: className
    }), _react.default.createElement("span", {
      ref: this.refPreview,
      className: _FormBuilderBlock.default.previewContainer,
      onClick: this.handleToggleEdit
    }, _react.default.createElement("div", {
      className: _FormBuilderBlock.default.preview
    }, this.renderPreview()), _react.default.createElement("div", {
      className: _FormBuilderBlock.default.functions
    }, memberType && _react.default.createElement("span", {
      className: _FormBuilderBlock.default.type
    }, memberType.title || memberType.name), _react.default.createElement("div", null, _react.default.createElement(_default2.default, {
      kind: "simple",
      icon: _editIcon.default,
      title: "Delete"
    })))), isEditing && _react.default.createElement(_StopPropagation.default, null, this.renderInput()));
  }

}

exports.default = FormBuilderBlock;

_defineProperty(FormBuilderBlock, "propTypes", {
  // Note: type refers to the array type, not the value type
  type: _propTypes.default.object.isRequired,
  node: _propTypes.default.object,
  editor: _propTypes.default.object,
  state: _propTypes.default.object,
  attributes: _propTypes.default.object,
  onPatch: _propTypes.default.func
});