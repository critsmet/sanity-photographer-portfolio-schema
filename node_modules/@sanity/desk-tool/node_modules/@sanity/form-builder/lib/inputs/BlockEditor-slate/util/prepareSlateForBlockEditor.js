"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prepareSlateForBlockEditor;

var _react = _interopRequireDefault(require("react"));

var _slate = require("slate");

var _createBlockNode = _interopRequireDefault(require("../createBlockNode"));

var _createInlineNode = _interopRequireDefault(require("../createInlineNode"));

var _createSpanNode = _interopRequireDefault(require("../createSpanNode"));

var _mapToObject = _interopRequireDefault(require("./mapToObject"));

var _randomKey = _interopRequireDefault(require("../util/randomKey"));

var _spanHelpers = require("./spanHelpers");

var _constants = require("../constants");

var _Blockquote = _interopRequireDefault(require("../preview/Blockquote"));

var _Header = _interopRequireDefault(require("../preview/Header"));

var _ListItem = _interopRequireDefault(require("../preview/ListItem"));

var _Decorator = _interopRequireDefault(require("../preview/Decorator"));

var _Normal = _interopRequireDefault(require("../preview/Normal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Set our own key generator for Slate
const keyGenerator = () => (0, _randomKey.default)(12);

(0, _slate.setKeyGenerator)(keyGenerator); // When the slate-fields are rendered in the editor, their node data is stored in a parent container component.
// In order to use the node data as props inside our components, we have to dereference them here first (see list and header keys)

const slateTypeComponentMapping = {
  normal: _Normal.default,

  h1(props) {
    return _react.default.createElement(_Header.default, _extends({
      level: 1
    }, props));
  },

  h2(props) {
    // eslint-disable-line react/no-multi-comp
    return _react.default.createElement(_Header.default, _extends({
      level: 2
    }, props));
  },

  h3(props) {
    // eslint-disable-line react/no-multi-comp
    return _react.default.createElement(_Header.default, _extends({
      level: 3
    }, props));
  },

  h4(props) {
    // eslint-disable-line react/no-multi-comp
    return _react.default.createElement(_Header.default, _extends({
      level: 4
    }, props));
  },

  h5(props) {
    // eslint-disable-line react/no-multi-comp
    return _react.default.createElement(_Header.default, _extends({
      level: 5
    }, props));
  },

  h6(props) {
    // eslint-disable-line react/no-multi-comp
    return _react.default.createElement(_Header.default, _extends({
      level: 6
    }, props));
  },

  listItem(props) {
    // eslint-disable-line react/no-multi-comp
    // eslint-disable-next-line react/prop-types
    const listItem = props.children[0] && props.children[0].props.parent.data.get('listItem'); // eslint-disable-next-line react/prop-types

    const level = props.children[0] && props.children[0].props.parent.data.get('level'); // eslint-disable-next-line react/prop-types

    const style = props.children[0] && props.children[0].props.parent.data.get('style') || _constants.BLOCK_DEFAULT_STYLE;

    const contentComponent = slateTypeComponentMapping[style];
    return _react.default.createElement(_ListItem.default, _extends({
      contentComponent: contentComponent,
      level: level,
      listItem: listItem
    }, props));
  },

  blockquote: _Blockquote.default // Create a contentBlock component

};

function createContentBlock(props) {
  let component = null;
  const style = props.children[0] && props.children[0].props.parent.data.get('style');
  const isListItem = props.children[0] && props.children[0].props.parent.data.get('listItem');

  if (isListItem) {
    component = slateTypeComponentMapping.listItem;
  } else {
    component = slateTypeComponentMapping[style];
  }

  if (!component) {
    // eslint-disable-next-line no-console
    console.warn(`No mapping for style '${style}' exists, using 'normal'`);
    component = slateTypeComponentMapping.normal;
  }

  return component(props);
}

function prepareSlateForBlockEditor(blockEditor) {
  const type = blockEditor.props.type;
  const blockType = type.of.find(ofType => ofType.name === 'block');

  if (!blockType) {
    throw new Error("'block' type is not defined in the schema (required).");
  }

  const styleField = blockType.fields.find(btField => btField.name === 'style');

  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }

  const textStyles = styleField.type.options.list && styleField.type.options.list.filter(style => style.value);

  if (!textStyles || textStyles.length === 0) {
    throw new Error('The style fields need at least one style ' + "defined. I.e: {title: 'Normal', value: 'normal'}.");
  }

  const listField = blockType.fields.find(btField => btField.name === 'list');
  let listItems = [];

  if (listField) {
    listItems = listField.type.options.list && listField.type.options.list.filter(listStyle => listStyle.value);
  }

  const memberTypesExceptBlock = type.of.filter(ofType => ofType.name !== 'block');
  const spanType = (0, _spanHelpers.getSpanType)(type);
  const allowedDecorators = spanType.decorators.map(decorator => decorator.value);
  const FormBuilderBlock = (0, _createBlockNode.default)(type, blockEditor.handleNodePatch);
  const FormBuilderInline = (0, _createInlineNode.default)(type, blockEditor.handleNodePatch);
  const slateSchema = {
    nodes: _objectSpread({}, (0, _mapToObject.default)(memberTypesExceptBlock, ofType => [ofType.name, ofType.options && ofType.options.inline ? FormBuilderInline : FormBuilderBlock]), {
      __unknown: FormBuilderBlock,
      span: (0, _createSpanNode.default)(spanType),
      contentBlock: createContentBlock
    }),
    marks: (0, _mapToObject.default)(allowedDecorators, decorator => {
      return [decorator, _Decorator.default];
    }),
    rules: [// Rule to insert a default block when document is empty,
    // or only contains one empty contentBlock
    {
      match: node => {
        return node.kind === 'document';
      },
      validate: document => {
        return document.nodes.size === 0 || document.nodes.size === 1 && document.nodes.first().type === _constants.SLATE_DEFAULT_BLOCK.type && document.nodes.first().text === '' && document.nodes.first().data.get('style') !== _constants.BLOCK_DEFAULT_STYLE ? document : null;
      },
      normalize: (change, document) => {
        change.deselect();
        const hasEmptySingleContentBlock = document.nodes.size === 1;
        change.insertNodeByKey(document.key, 0, _slate.Block.create(_constants.SLATE_DEFAULT_BLOCK));

        if (hasEmptySingleContentBlock) {
          change.removeNodeByKey(document.nodes.first().key);
        }

        return change.collapseToStartOf(change.state.document.nodes.first()).focus();
      }
    }, // Rule to ensure that every non-void block has a style
    {
      match: node => {
        if (node.kind === 'block' && !node.isVoid) {
          return node;
        }

        return undefined;
      },
      validate: block => {
        return block.data.get('style') === undefined ? block : null;
      },
      normalize: (change, block) => {
        const data = _objectSpread({}, block.data.toObject(), {
          style: _constants.BLOCK_DEFAULT_STYLE
        });

        return change.setNodeByKey(block.key, {
          data
        });
      }
    }, // Rule to ensure that annotation _key's within a block is unique
    // Duplication can happen when copy/pasting annotation spans within the same block
    {
      match: node => {
        // contentBlock with annotations
        return node.kind === 'block' && node.type === 'contentBlock' && node.filterDescendants(desc => {
          const annotations = desc.data && desc.data.get('annotations');
          return annotations && Object.keys(annotations).length;
        }).size;
      },
      validate: contentBlock => {
        // return the last occurence of nodes with annotations that has the same _key
        const duplicateKeyNodes = contentBlock.filterDescendants(desc => desc.data && desc.data.get('annotations')).toArray().map(aNode => {
          const annotations = aNode.data.get('annotations');
          return Object.keys(annotations).map(name => annotations[name]._key);
        }).reduce((a, b) => {
          return a.concat(b);
        }, []).filter((key, i, keys) => keys.lastIndexOf(key) !== i);

        if (duplicateKeyNodes.length) {
          return duplicateKeyNodes.map(key => {
            return {
              dupKey: key,
              dupNode: contentBlock.filterDescendants(desc => {
                const annotations = desc.data && desc.data.get('annotations');
                return annotations && Object.keys(annotations).find(name => annotations[name]._key === key);
              }).toArray().slice(-1)[0] // Last occurence

            };
          });
        }

        return null;
      },
      normalize: (change, node, dupNodes) => {
        dupNodes.forEach(dup => {
          const dupKey = dup.dupKey,
                dupNode = dup.dupNode;

          const annotations = _objectSpread({}, dupNode.data.get('annotations'));

          const newAnnotations = {};
          Object.keys(annotations).forEach(name => {
            newAnnotations[name] = _objectSpread({}, annotations[name]);

            if (annotations[name]._key === dupKey) {
              newAnnotations[name]._key = (0, _randomKey.default)(12);
            }
          });

          const data = _objectSpread({}, dupNode.data.toObject(), {
            annotations: newAnnotations
          });

          change.setNodeByKey(dupNode.key, {
            data
          });
        });
        return change;
      }
    }]
  };
  return {
    listItems: listItems,
    textStyles: textStyles,
    annotationTypes: spanType.annotations,
    decorators: spanType.decorators,
    customBlocks: memberTypesExceptBlock,
    slateSchema: slateSchema
  };
}