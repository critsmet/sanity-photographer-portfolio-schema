"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _patch = require("../patch");

var _luid = _interopRequireDefault(require("./luid"));

var _debug = _interopRequireDefault(require("./debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// A mutation describing a number of operations on a single document
// This should be considered an immutable structure. Mutations are compiled
// on first application, and any changes in properties will not effectively
// change its behavior after that.
var Mutation =
/*#__PURE__*/
function () {
  function Mutation(options) {
    _classCallCheck(this, Mutation);

    _defineProperty(this, "params", void 0);

    _defineProperty(this, "compiled", void 0);

    _defineProperty(this, "_appliesToMissingDocument", void 0);

    this.params = options;
  }

  _createClass(Mutation, [{
    key: "assignRandomTransactionId",
    value: function assignRandomTransactionId() {
      this.params.resultRev = this.params.transactionId = (0, _luid.default)();
    }
  }, {
    key: "appliesToMissingDocument",
    value: function appliesToMissingDocument() {
      if (typeof this._appliesToMissingDocument !== 'undefined') {
        return this._appliesToMissingDocument;
      } // Only mutations starting with a create operation apply to documents that do not exist ...


      var firstMut = this.mutations[0];

      if (firstMut) {
        this._appliesToMissingDocument = firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace;
      } else {
        this._appliesToMissingDocument = true;
      }

      return this._appliesToMissingDocument;
    } // Compiles all mutations into a handy function

  }, {
    key: "compile",
    value: function compile() {
      var _this = this;

      var operations = [];
      this.mutations.forEach(function (mutation) {
        if (mutation.create) {
          // TODO: Fail entire patch if document did exist
          operations.push(function (doc) {
            return doc === null ? Object.assign(mutation.create, {
              _createdAt: mutation.create._createdAt || _this.params.timestamp
            }) : doc;
          });
        } else if (mutation.createIfNotExists) {
          operations.push(function (doc) {
            return doc === null ? Object.assign(mutation.createIfNotExists, {
              _createdAt: mutation.createIfNotExists._createdAt || _this.params.timestamp
            }) : doc;
          });
        } else if (mutation.createOrReplace) {
          operations.push(function () {
            return Object.assign(mutation.createOrReplace, {
              _createdAt: mutation.createOrReplace._createdAt || _this.params.timestamp
            });
          });
        } else if (mutation.delete) {
          operations.push(function () {
            return null;
          });
        } else if (mutation.patch) {
          var patch = new _patch.Patcher(mutation.patch);
          operations.push(function (doc) {
            return patch.apply(doc);
          });
        } else {
          throw new Error("Unsupported mutation ".concat(JSON.stringify(mutation, null, 2)));
        }
      });

      if (typeof this.params.timestamp === 'string') {
        operations.push(function (doc) {
          if (doc) {
            return Object.assign(doc, {
              _updatedAt: _this.params.timestamp
            });
          }

          return doc;
        });
      }

      var prevRev = this.previousRev;
      var rev = this.resultRev || this.transactionId;

      this.compiled = function (doc) {
        if (prevRev && prevRev != doc._rev) {
          throw new Error("Previous revision for this mutation was ".concat(prevRev, ", but the document revision is ").concat(doc._rev));
        }

        var result = operations.reduce(function (revision, operation) {
          return operation(revision);
        }, doc); // Should update _rev?

        if (result && rev) {
          // Ensure that result is a unique object, even if the operation was a no-op
          if (result === doc) {
            result = Object.assign({}, doc);
          }

          result._rev = rev;
        }

        return result;
      };
    }
  }, {
    key: "apply",
    value: function apply(document) {
      (0, _debug.default)('Applying mutation %O to document %O', this.mutations, document);

      if (!this.compiled) {
        this.compile();
      }

      var result = this.compiled(document);
      (0, _debug.default)('  => %O', result);
      return result;
    }
  }, {
    key: "transactionId",
    get: function get() {
      return this.params.transactionId;
    }
  }, {
    key: "transition",
    get: function get() {
      return this.params.transition;
    }
  }, {
    key: "identity",
    get: function get() {
      return this.params.identity;
    }
  }, {
    key: "previousRev",
    get: function get() {
      return this.params.previousRev;
    }
  }, {
    key: "resultRev",
    get: function get() {
      return this.params.resultRev;
    }
  }, {
    key: "mutations",
    get: function get() {
      return this.params.mutations;
    }
  }, {
    key: "timestamp",
    get: function get() {
      if (typeof this.params.timestamp == 'string') {
        return new Date(this.params.timestamp);
      }

      return undefined;
    }
  }], [{
    key: "applyAll",
    value: function applyAll(document, mutations) {
      return mutations.reduce(function (doc, mutation) {
        return mutation.apply(doc);
      }, document);
    } // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation
    // any metadata like transactionId is ignored and must be submitted by the client. It is assumed
    // that all mutations are on the same document.
    // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!

  }, {
    key: "squash",
    value: function squash(document, mutations) {
      var squashed = mutations.reduce(function (result, mutation) {
        return result.concat.apply(result, _toConsumableArray(mutation.mutations));
      }, []);
      return new Mutation({
        mutations: squashed
      });
    }
  }]);

  return Mutation;
}();

exports.default = Mutation;