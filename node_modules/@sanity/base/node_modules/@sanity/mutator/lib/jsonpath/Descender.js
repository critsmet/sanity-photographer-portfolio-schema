"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _Expression = _interopRequireDefault(require("./Expression"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Descender =
/*#__PURE__*/
function () {
  function Descender(head, tail) {
    _classCallCheck(this, Descender);

    _defineProperty(this, "head", void 0);

    _defineProperty(this, "tail", void 0);

    this.head = head;
    this.tail = tail;
  } // Iterate this descender once processing any constraints that are
  // resolvable on the current value. Returns an array of new descenders
  // that are guaranteed to be without constraints in the head


  _createClass(Descender, [{
    key: "iterate",
    value: function iterate(probe) {
      var result = [this];

      if (this.head && this.head.isConstraint()) {
        var anyConstraints = true; // Keep rewriting constraints until there are none left

        while (anyConstraints) {
          result = (0, _flatten2.default)(result.map(function (descender) {
            return descender.iterateConstraints(probe);
          }));
          anyConstraints = result.find(function (descender) {
            return descender.head && descender.head.isConstraint();
          });
        }
      }

      return result;
    }
  }, {
    key: "isRecursive",
    value: function isRecursive() {
      return this.head && this.head.isRecursive();
    }
  }, {
    key: "hasArrived",
    value: function hasArrived() {
      return this.head === null && this.tail === null;
    }
  }, {
    key: "extractRecursives",
    value: function extractRecursives() {
      if (this.head.isRecursive()) {
        var term = this.head.unwrapRecursive();
        return new Descender(null, term.concat(this.tail)).descend();
      }

      return [];
    }
  }, {
    key: "iterateConstraints",
    value: function iterateConstraints(probe) {
      var head = this.head;

      if (head === null || !head.isConstraint()) {
        // Not a constraint, no rewrite
        return [this];
      }

      var result = [];

      if (probe.containerType() === 'primitive' && head.constraintTargetIsSelf()) {
        if (head.testConstraint(probe)) {
          result.push.apply(result, _toConsumableArray(this.descend()));
        }

        return result;
      } // The value is an array


      if (probe.containerType() === 'array') {
        var length = probe.length();

        for (var i = 0; i < length; i++) {
          // Push new descenders with constraint translated to literal indices
          // where they match
          if (head.testConstraint(probe.getIndex(i))) {
            result.push(new Descender(new _Expression.default({
              type: 'index',
              value: i
            }), this.tail));
          }
        }

        return result;
      } // The value is an object


      if (probe.containerType() == 'object') {
        if (this.head.constraintTargetIsSelf()) {
          // There are no matches for target self ('@') on a plain object
          return [];
        }

        if (this.head.testConstraint(probe)) {
          return this.descend();
        }

        return result;
      }

      return result;
    }
  }, {
    key: "descend",
    value: function descend() {
      if (!this.tail) {
        return [new Descender(null, null)];
      }

      return this.tail.descend().map(function (ht) {
        return new Descender(ht.head, ht.tail);
      });
    }
  }, {
    key: "toString",
    value: function toString() {
      var result = ['<'];

      if (this.head) {
        result.push(this.head.toString());
      }

      result.push('|');

      if (this.tail) {
        result.push(this.tail.toString());
      }

      result.push('>');
      return result.join('');
    }
  }]);

  return Descender;
}();

exports.default = Descender;