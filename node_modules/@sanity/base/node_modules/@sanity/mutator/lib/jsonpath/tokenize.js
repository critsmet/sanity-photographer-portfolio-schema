"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tokenize;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Tokenizes a jsonpath2 expression
// TODO: Support '*'
var digitChar = /[0-9]/;
var attributeCharMatcher = /^[a-zA-Z0-9_]$/;
var attributeFirstCharMatcher = /^[a-zA-Z_]$/;
var symbols = {
  operator: ['..', '.', ',', ':', '?'],
  comparator: ['>', '>=', '<', '<=', '==', '!='],
  keyword: ['$', '@'],
  boolean: ['true', 'false'],
  paren: ['[', ']']
};

var Tokenizer =
/*#__PURE__*/
function () {
  function Tokenizer(path) {
    var _this = this;

    _classCallCheck(this, Tokenizer);

    _defineProperty(this, "source", void 0);

    _defineProperty(this, "i", void 0);

    _defineProperty(this, "length", void 0);

    this.source = path;
    this.length = path.length;
    this.i = 0;
    this.tokenizers = [this.tokenizeSymbol, this.tokenizeIdentifier, this.tokenizeNumber, this.tokenizeQuoted].map(function (fn) {
      return fn.bind(_this);
    });
  }

  _createClass(Tokenizer, [{
    key: "tokenize",
    value: function tokenize() {
      var _this2 = this;

      var result = [];

      var _loop = function _loop() {
        var token = void 0;

        _this2.chompWhitespace();

        var found = _this2.tokenizers.find(function (tokenizer) {
          token = tokenizer();
          return !!token;
        });

        if (!found) {
          throw new Error("Invalid tokens in jsonpath '".concat(_this2.source, "' @ ").concat(_this2.i));
        }

        result.push(token);
      };

      while (!this.EOF()) {
        _loop();
      }

      return result;
    }
  }, {
    key: "takeWhile",
    value: function takeWhile(fn) {
      var start = this.i;
      var result = '';

      while (!this.EOF()) {
        var nextChar = fn(this.source[this.i]);

        if (nextChar === null) {
          break;
        }

        result += nextChar;
        this.i++;
      }

      if (this.i === start) {
        return null;
      }

      return result;
    }
  }, {
    key: "EOF",
    value: function EOF() {
      return this.i >= this.length;
    }
  }, {
    key: "peek",
    value: function peek() {
      if (this.EOF()) {
        return null;
      }

      return this.source[this.i];
    }
  }, {
    key: "consume",
    value: function consume(str) {
      if (this.i + str.length > this.length) {
        throw new Error("Expected ".concat(str, " at end of jsonpath"));
      }

      if (str == this.source.slice(this.i, this.i + str.length)) {
        this.i += str.length;
      } else {
        throw new Error("Expected \"".concat(str, "\", but source contained \"").concat(this.source.slice(this.start)));
      }
    } // Tries to match the upcoming bit of string with the provided string. If it matches, returns
    // the string, then advances the read pointer to the next bit. If not, returns null and nothing
    // happens.

  }, {
    key: "tryConsume",
    value: function tryConsume(str) {
      if (this.i + str.length > this.length) {
        return null;
      }

      if (str == this.source.slice(this.i, this.i + str.length)) {
        this.i += str.length;
        return str;
      }

      return null;
    }
  }, {
    key: "chompWhitespace",
    value: function chompWhitespace() {
      this.takeWhile(function (char) {
        return char == ' ' ? '' : null;
      });
    }
  }, {
    key: "tokenizeQuoted",
    value: function tokenizeQuoted() {
      var quote = this.peek();

      if (quote == "'" || quote == '"') {
        this.consume(quote);
        var _escape = false;
        var inner = this.takeWhile(function (char) {
          if (_escape) {
            _escape = false;
            return char;
          }

          if (char == '\\') {
            _escape = true;
            return '';
          }

          if (char != quote) {
            return char;
          }

          return null;
        });
        this.consume(quote);
        return {
          type: 'quoted',
          value: inner,
          quote: quote == '"' ? 'double' : 'single'
        };
      }

      return null;
    }
  }, {
    key: "tokenizeIdentifier",
    value: function tokenizeIdentifier() {
      var first = true;
      var identifier = this.takeWhile(function (char) {
        if (first) {
          first = false;
          return char.match(attributeFirstCharMatcher) ? char : null;
        }

        return char.match(attributeCharMatcher) ? char : null;
      });

      if (identifier !== null) {
        return {
          type: 'identifier',
          name: identifier
        };
      }

      return null;
    }
  }, {
    key: "tokenizeNumber",
    value: function tokenizeNumber() {
      var start = this.i;
      var dotSeen = false;
      var digitSeen = false;
      var negative = false;

      if (this.peek() == '-') {
        negative = true;
        this.consume('-');
      }

      var number = this.takeWhile(function (char) {
        if (char == '.' && !dotSeen && digitSeen) {
          dotSeen = true;
          return char;
        }

        digitSeen = true;
        return char.match(digitChar) ? char : null;
      });

      if (number !== null) {
        return {
          type: 'number',
          value: negative ? -number : +number,
          raw: negative ? "-".concat(number) : number
        };
      } // No number, rewind


      this.i = start;
      return null;
    }
  }, {
    key: "tokenizeSymbol",
    value: function tokenizeSymbol() {
      var _this3 = this;

      var result = null;
      Object.keys(symbols).find(function (symbolClass) {
        var patterns = symbols[symbolClass];
        var found = patterns.find(function (pattern) {
          return _this3.tryConsume(pattern);
        });

        if (found) {
          result = {
            type: symbolClass,
            symbol: found
          };
          return true;
        }
      });
      return result;
    }
  }]);

  return Tokenizer;
}();

function tokenize(jsonpath) {
  return new Tokenizer(jsonpath).tokenize();
}