"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _descend2 = _interopRequireDefault(require("./descend"));

var _toPath = _interopRequireDefault(require("./toPath"));

var _parse = _interopRequireDefault(require("./parse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Expression =
/*#__PURE__*/
function () {
  function Expression(expr) {
    _classCallCheck(this, Expression);

    _defineProperty(this, "expr", void 0);

    // This is a wrapped expr
    if (expr.expr) {
      this.expr = expr.expr;
    } else {
      this.expr = expr;
    }

    if (!this.expr.type) {
      throw new Error('Attempt to create Expression for expression with no type');
    }
  }

  _createClass(Expression, [{
    key: "isPath",
    value: function isPath() {
      return this.expr.type == 'path';
    }
  }, {
    key: "isUnion",
    value: function isUnion() {
      return this.expr.type == 'union';
    }
  }, {
    key: "isCollection",
    value: function isCollection() {
      return this.isPath() || this.isUnion();
    }
  }, {
    key: "isConstraint",
    value: function isConstraint() {
      return this.expr.type == 'constraint';
    }
  }, {
    key: "isRecursive",
    value: function isRecursive() {
      return this.expr.type == 'recursive';
    }
  }, {
    key: "isExistenceConstraint",
    value: function isExistenceConstraint() {
      return this.isConstraint() && this.expr.operator == '?';
    }
  }, {
    key: "isIndex",
    value: function isIndex() {
      return this.expr.type == 'index';
    }
  }, {
    key: "isRange",
    value: function isRange() {
      return this.expr.type == 'range';
    }
  }, {
    key: "expandRange",
    value: function expandRange(probe) {
      var start = this.expr.start || 0;
      start = interpretNegativeIndex(start, probe);
      var end = this.expr.end || probe.length();
      end = interpretNegativeIndex(end, probe);
      var step = this.expr.step || 1;
      return {
        start: start,
        end: end,
        step: step
      };
    }
  }, {
    key: "isAttributeReference",
    value: function isAttributeReference() {
      return this.expr.type == 'attribute';
    } // Is a range or index -> something referencing indexes

  }, {
    key: "isIndexReference",
    value: function isIndexReference() {
      return this.isIndex() || this.isRange();
    }
  }, {
    key: "name",
    value: function name() {
      return this.expr.name;
    }
  }, {
    key: "isSelfReference",
    value: function isSelfReference() {
      return this.expr.type == 'alias' && this.expr.target == 'self';
    }
  }, {
    key: "constraintTargetIsSelf",
    value: function constraintTargetIsSelf() {
      return this.isConstraint() && this.expr.lhs.type == 'alias' && this.expr.lhs.target == 'self';
    }
  }, {
    key: "constraintTargetIsAttribute",
    value: function constraintTargetIsAttribute() {
      return this.isConstraint() && this.expr.lhs.type == 'attribute';
    }
  }, {
    key: "testConstraint",
    value: function testConstraint(probe) {
      if (this.constraintTargetIsSelf()) {
        if (probe.containerType() != 'primitive') {
          return false;
        }

        if (this.isExistenceConstraint()) {
          return true;
        }

        var _lhs = probe.get();

        var _rhs = this.expr.rhs.value;
        return testBinaryOperator(_lhs, this.expr.operator, _rhs);
      }

      if (!this.constraintTargetIsAttribute()) {
        throw new Error("Constraint target ".concat(this.expr.lhs.type, " not supported"));
      }

      if (probe.containerType() != 'object') {
        return false;
      }

      var lhs = probe.getAttribute(this.expr.lhs.name);

      if (lhs === undefined || lhs === null || lhs.containerType() != 'primitive') {
        // LHS is void and empty, or it is a collection
        return false;
      }

      if (this.isExistenceConstraint()) {
        // There is no rhs, and if we're here the key did exist
        return true;
      }

      var rhs = this.expr.rhs.value;
      return testBinaryOperator(lhs.get(), this.expr.operator, rhs);
    }
  }, {
    key: "pathNodes",
    value: function pathNodes() {
      if (this.isPath()) {
        return this.expr.nodes;
      }

      return [this.expr];
    }
  }, {
    key: "prepend",
    value: function prepend(node) {
      if (!node) {
        return this;
      }

      return new Expression({
        type: 'path',
        nodes: node.pathNodes().concat(this.pathNodes())
      });
    }
  }, {
    key: "concat",
    value: function concat(other) {
      if (!other) {
        return this;
      }

      return other.prepend(this);
    }
  }, {
    key: "descend",
    value: function descend() {
      return (0, _descend2.default)(this.expr).map(function (headTail) {
        var _headTail = _slicedToArray(headTail, 2),
            head = _headTail[0],
            tail = _headTail[1];

        return {
          head: head ? new Expression(head) : null,
          tail: tail ? new Expression(tail) : null
        };
      });
    }
  }, {
    key: "unwrapRecursive",
    value: function unwrapRecursive() {
      if (!this.isRecursive()) {
        throw new Error("Attempt to unwrap recursive on type ".concat(this.expr.type));
      }

      return new Expression(this.expr.term);
    }
  }, {
    key: "toIndicies",
    value: function toIndicies(probe) {
      if (!this.isIndexReference()) {
        throw new Error('Node cannot be converted to indexes');
      }

      if (this.expr.type == 'index') {
        return [interpretNegativeIndex(this.expr.value, probe)];
      } else if (this.expr.type == 'range') {
        var result = [];

        var _this$expandRange = this.expandRange(probe),
            start = _this$expandRange.start,
            end = _this$expandRange.end,
            step = _this$expandRange.step;

        if (step < 0) {
          ;
          var _ref = [end, start];
          start = _ref[0];
          end = _ref[1];
        }

        for (var i = start; i < end; i++) {
          result.push(i);
        }

        return result;
      }

      throw new Error("Unable to convert ".concat(this.expr.type, " to indices"));
    }
  }, {
    key: "toFieldReferences",
    value: function toFieldReferences() {
      if (this.isIndexReference()) {
        return this.toIndicies();
      }

      if (this.isAttributeReference()) {
        return [this.name()];
      }

      throw new Error("Can't convert ".concat(this.expr.type, " to field references"));
    }
  }, {
    key: "toString",
    value: function toString() {
      return (0, _toPath.default)(this.expr);
    }
  }], [{
    key: "fromPath",
    value: function fromPath(path) {
      return new Expression((0, _parse.default)(path));
    }
  }, {
    key: "attributeReference",
    value: function attributeReference(name) {
      return new Expression({
        type: 'attribute',
        name: name
      });
    }
  }, {
    key: "indexReference",
    value: function indexReference(i) {
      return new Expression({
        type: 'index',
        value: i
      });
    }
  }]);

  return Expression;
}(); // Tests an operator on two given primitive values


exports.default = Expression;

function testBinaryOperator(lhsValue, operator, rhsValue) {
  switch (operator) {
    case '>':
      return lhsValue > rhsValue;

    case '>=':
      return lhsValue >= rhsValue;

    case '<':
      return lhsValue < rhsValue;

    case '<=':
      return lhsValue <= rhsValue;

    case '==':
      return lhsValue == rhsValue;

    case '!=':
      return lhsValue != rhsValue;

    default:
      throw new Error("Unsupported binary operator ".concat(operator));
  }
}

function interpretNegativeIndex(index, probe) {
  if (index < 0) {
    return index + probe.length();
  }

  return index;
}