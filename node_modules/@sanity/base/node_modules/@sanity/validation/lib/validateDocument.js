"use strict";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const Type = require('type-of-is');

const _require = require('lodash'),
      flatten = _require.flatten;

const ValidationError = require('./ValidationError');
/* eslint-disable no-console */


module.exports =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (doc, schema) {
    const documentType = schema.get(doc._type);

    if (!documentType) {
      console.warn('Schema type for object type "%s" not found, skipping validation', doc._type);
      return [];
    }

    try {
      return yield validateItem(doc, documentType, [], {
        document: doc
      });
    } catch (err) {
      console.error(err);
      return [{
        type: 'validation',
        level: 'error',
        path: [],
        item: new ValidationError(err.message)
      }];
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function validateItem(item, type, path, options) {
  if (Array.isArray(item)) {
    return validateArray(item, type, path, options);
  }

  if (typeof item === 'object') {
    return validateObject(item, type, path, options);
  }

  return validatePrimitive(item, type, path, options);
}

function validateObject(obj, type, path, options) {
  if (!type) {
    return [];
  } // Validate actual object itself


  let objChecks = [];

  if (type.validation) {
    objChecks = type.validation.map(
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(function* (rule) {
        const ruleResults = yield rule.validate(obj, {
          parent: options.parent,
          document: options.document,
          path,
          type
        });
        return applyPath(ruleResults, path);
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    }());
  } // Validate fields within object


  const fields = type.fields || [];
  const fieldChecks = fields.map(field => {
    const validation = field.type.validation;

    if (!validation) {
      return [];
    }

    const fieldPath = appendPath(path, field.name);
    const fieldValue = obj[field.name];
    return validateItem(fieldValue, field.type, fieldPath, {
      parent: obj,
      document: options.document,
      path: fieldPath,
      type: field.type
    });
  });
  return Promise.all([...objChecks, ...fieldChecks]).then(flatten);
}

function validateArray(items, type, path, options) {
  // Validate actual array itself
  let arrayChecks = [];

  if (type.validation) {
    arrayChecks = type.validation.map(
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(function* (rule) {
        const ruleResults = yield rule.validate(items, {
          parent: options.parent,
          document: options.document,
          path,
          type
        });
        return applyPath(ruleResults, path);
      });

      return function (_x4) {
        return _ref3.apply(this, arguments);
      };
    }());
  } // Validate items within array


  const itemChecks = items.map((item, i) => {
    const pathSegment = item._key ? {
      _key: item._key
    } : i;
    const itemType = resolveTypeForArrayItem(item, type.of);
    const itemPath = appendPath(path, [pathSegment]);
    return validateItem(item, itemType, itemPath, {
      parent: items,
      document: options.document,
      path: itemPath
    });
  });
  return Promise.all([...arrayChecks, ...itemChecks]).then(flatten);
}

function validatePrimitive(item, type, path, options) {
  if (!type.validation) {
    return [];
  }

  const results = type.validation.map(rule => rule.validate(item, {
    parent: options.parent,
    document: options.document,
    path
  }).then(currRuleResults => applyPath(currRuleResults, path)));
  return Promise.all(results).then(flatten);
}

function resolveTypeForArrayItem(item, candidates) {
  const primitive = !item._type && Type.string(item).toLowerCase();

  if (primitive) {
    return candidates.find(candidate => candidate.jsonType === primitive);
  }

  return candidates.find(candidate => candidate.type.name === item._type) || candidates.find(candidate => candidate.name === item._type);
}

function appendPath(base, next) {
  return base.concat(next);
}

function applyPath(results, pathPrefix) {
  return results.map(result => {
    const path = typeof result.path === 'undefined' ? pathPrefix : pathPrefix.concat(result.path);
    return _objectSpread({
      type: 'validation'
    }, result, {
      path
    });
  });
}