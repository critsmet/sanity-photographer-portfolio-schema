"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withMaxConcurrency = withMaxConcurrency;
exports.createThrottler = createThrottler;

var _operators = require("rxjs/operators");

var _rxjs = require("rxjs");

// Takes a observable-returning function and returns a new function that limits on the number of
// concurrent observables.
const DEFAULT_CONCURRENCY = 4;

function remove(array, item) {
  const index = array.indexOf(item);

  if (index > -1) {
    array.splice(index, 1);
  }

  return array;
}

function withMaxConcurrency(func, concurrency = DEFAULT_CONCURRENCY) {
  const throttler = createThrottler(concurrency);
  return (...args) => (0, _rxjs.from)(throttler(func(...args)));
}

function createThrottler(concurrency = DEFAULT_CONCURRENCY) {
  const currentSubscriptions = [];
  const pendingObservables = [];
  const ready$ = new _rxjs.Subject();
  return request;

  function request(observable) {
    return new _rxjs.Observable(observer => {
      if (currentSubscriptions.length >= concurrency) {
        return scheduleAndWait(observable).pipe((0, _operators.mergeMap)(request)).subscribe(observer);
      }

      const subscription = observable.subscribe(observer);
      currentSubscriptions.push(subscription);
      return () => {
        remove(currentSubscriptions, subscription);
        remove(pendingObservables, observable);
        subscription.unsubscribe();
        check();
      };
    });
  }

  function scheduleAndWait(observable) {
    pendingObservables.push(observable);
    return ready$.asObservable().pipe((0, _operators.first)(obs => obs === observable));
  }

  function check() {
    while (pendingObservables.length > 0 && currentSubscriptions.length < concurrency) {
      ready$.next(pendingObservables.shift());
    }
  }
}