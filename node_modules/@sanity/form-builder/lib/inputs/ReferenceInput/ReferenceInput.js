"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _searchable = _interopRequireDefault(require("part:@sanity/components/selects/searchable"));

var _default = _interopRequireDefault(require("part:@sanity/components/formfields/default"));

var _Preview = _interopRequireDefault(require("../../Preview"));

var _subscriptionManager = _interopRequireDefault(require("../../utils/subscriptionManager"));

var _PatchEvent = _interopRequireWildcard(require("../../../PatchEvent"));

var _linkIcon = _interopRequireDefault(require("part:@sanity/base/link-icon"));

var _router = require("part:@sanity/base/router");

var _ReferenceInput = _interopRequireDefault(require("./styles/ReferenceInput.css"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MISSING_SNAPSHOT = {};

const getInitialState = () => {
  return {
    isFetching: false,
    hits: [],
    previewSnapshot: null,
    refCache: {}
  };
};

class ReferenceInput extends _react.default.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "_lastQuery", void 0);

    _defineProperty(this, "_input", void 0);

    _defineProperty(this, "state", getInitialState());

    _defineProperty(this, "subscriptions", (0, _subscriptionManager.default)('search', 'previewSnapshot'));

    _defineProperty(this, "_lastQuery", '');

    _defineProperty(this, "handleFocus", () => {
      if (this._lastQuery) {
        this.search(this._lastQuery);
      }
    });

    _defineProperty(this, "handleChange", item => {
      const type = this.props.type;
      this.props.onChange(_PatchEvent.default.from((0, _PatchEvent.setIfMissing)({
        _type: type.name,
        _ref: item._id
      }), type.weak === true ? (0, _PatchEvent.set)(true, ['_weak']) : (0, _PatchEvent.unset)(['_weak']), (0, _PatchEvent.set)(item._id, ['_ref'])));
    });

    _defineProperty(this, "handleFixWeak", () => {
      const type = this.props.type;
      this.props.onChange(_PatchEvent.default.from(type.weak === true ? (0, _PatchEvent.set)(true, ['_weak']) : (0, _PatchEvent.unset)(['_weak'])));
    });

    _defineProperty(this, "handleClear", () => {
      this.props.onChange(_PatchEvent.default.from((0, _PatchEvent.unset)()));
    });

    _defineProperty(this, "handleSearch", query => {
      this.search(query);
    });

    _defineProperty(this, "handleOpen", () => {
      this.search('');
    });

    _defineProperty(this, "search", query => {
      const _this$props = this.props,
            type = _this$props.type,
            onSearch = _this$props.onSearch;
      this.setState({
        isFetching: true
      });
      this.subscriptions.replace('search', onSearch(query, type).subscribe(items => {
        const updatedCache = items.reduce((cache, item) => {
          cache[item._id] = item;
          return cache;
        }, Object.assign({}, this.state.refCache));
        this.setState({
          hits: items,
          isFetching: false,
          refCache: updatedCache
        });
      }));
    });

    _defineProperty(this, "renderHit", item => {
      const type = this.getMemberTypeFor(item._type);
      return _react.default.createElement(_Preview.default, {
        type: type,
        value: item,
        layout: "default"
      });
    });

    _defineProperty(this, "renderOpenItemElement", () => {
      const value = this.props.value;
      const previewSnapshot = this.state.previewSnapshot;

      if (!value || !value._ref || previewSnapshot === MISSING_SNAPSHOT) {
        return null;
      }

      return _react.default.createElement(_router.IntentLink, {
        title: previewSnapshot && `Open ${previewSnapshot.title}`,
        intent: "edit",
        params: {
          id: value._ref
        }
      }, _react.default.createElement(_linkIcon.default, null));
    });

    _defineProperty(this, "setInput", input => {
      this._input = input;
    });
  }

  componentWillUnmount() {
    this.subscriptions.unsubscribeAll();
  }

  componentDidMount() {
    this.getPreviewSnapshot(this.props.value);
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.value !== this.props.value) {
      this.setState(getInitialState());
      this.getPreviewSnapshot(nextProps.value);
    }
  }

  getPreviewSnapshot(value) {
    if (!value || !value._ref) {
      return;
    }

    const _this$props2 = this.props,
          getPreviewSnapshot = _this$props2.getPreviewSnapshot,
          type = _this$props2.type;
    this.subscriptions.replace('previewSnapshot', getPreviewSnapshot(value, type).subscribe(snapshot => {
      this.setState({
        previewSnapshot: snapshot || MISSING_SNAPSHOT
      });
    }));
  }

  getMemberTypeFor(typeName) {
    const type = this.props.type;
    return type.to.find(ofType => ofType.type.name === typeName);
  }

  focus() {
    if (this._input) {
      this._input.focus();
    }
  }

  render() {
    const _this$props3 = this.props,
          type = _this$props3.type,
          value = _this$props3.value,
          level = _this$props3.level,
          markers = _this$props3.markers,
          readOnly = _this$props3.readOnly,
          onSearch = _this$props3.onSearch,
          getPreviewSnapshot = _this$props3.getPreviewSnapshot,
          rest = _objectWithoutProperties(_this$props3, ["type", "value", "level", "markers", "readOnly", "onSearch", "getPreviewSnapshot"]);

    const _this$state = this.state,
          previewSnapshot = _this$state.previewSnapshot,
          isFetching = _this$state.isFetching,
          hits = _this$state.hits;
    const valueFromHit = value && hits.find(hit => hit._id === value._ref);
    const weakIs = value && value._weak ? 'weak' : 'strong';
    const weakShouldBe = type.weak === true ? 'weak' : 'strong';
    const isMissing = previewSnapshot === MISSING_SNAPSHOT;
    const hasRef = value && value._ref;
    const hasWeakMismatch = hasRef && !isMissing && weakIs !== weakShouldBe;
    const validation = markers.filter(marker => marker.type === 'validation');
    const errors = validation.filter(marker => marker.level === 'error');
    let inputValue = value ? previewSnapshot && previewSnapshot.title : undefined;

    if (previewSnapshot && !previewSnapshot.title) {
      inputValue = 'Untitled document';
    }

    return _react.default.createElement(_default.default, {
      markers: markers,
      label: type.title,
      level: level,
      description: type.description
    }, _react.default.createElement("div", {
      className: hasWeakMismatch || isMissing ? _ReferenceInput.default.hasWarnings : ''
    }, hasWeakMismatch && _react.default.createElement("div", {
      className: _ReferenceInput.default.weakRefMismatchWarning
    }, "Warning: This reference is ", _react.default.createElement("em", null, weakIs), ", but should be ", _react.default.createElement("em", null, weakShouldBe), ' ', "according to schema.", _react.default.createElement("div", null, _react.default.createElement(_default2.default, {
      onClick: this.handleFixWeak
    }, "Convert to ", weakShouldBe))), _react.default.createElement(_searchable.default, {
      placeholder: "Type to search\u2026",
      title: isMissing && hasRef ? `Document id: ${value._ref || 'unknown'}` : previewSnapshot && previewSnapshot.description,
      customValidity: errors.length > 0 ? errors[0].item.message : '',
      onOpen: this.handleOpen,
      onFocus: this.handleFocus,
      onSearch: this.handleSearch,
      onChange: this.handleChange,
      onClear: this.handleClear,
      openItemElement: this.renderOpenItemElement,
      value: valueFromHit || value,
      inputValue: isMissing ? '<Unpublished or missing document>' : inputValue,
      renderItem: this.renderHit,
      isLoading: isFetching,
      items: hits,
      ref: this.setInput,
      readOnly: readOnly
    })));
  }

}

exports.default = ReferenceInput;