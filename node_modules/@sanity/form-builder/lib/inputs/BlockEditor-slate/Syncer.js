"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _blockTools = _interopRequireDefault(require("@sanity/block-tools"));

var _generateHelpUrl = _interopRequireDefault(require("@sanity/generate-help-url"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/formfields/default"));

var _BlockEditor = _interopRequireDefault(require("./BlockEditor"));

var _slate = require("slate");

var _PatchEvent = _interopRequireWildcard(require("../../PatchEvent"));

var _withPatchSubscriber = _interopRequireDefault(require("../../utils/withPatchSubscriber"));

var _default3 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _Syncer = _interopRequireDefault(require("./styles/Syncer.css"));

var _simplePatch = _interopRequireDefault(require("../../simplePatch"));

var _class, _temp;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function deserialize(value, type) {
  return _slate.State.fromJSON(_blockTools.default.blocksToSlateState(value, type));
}

function serialize(state, type) {
  return _blockTools.default.slateStateToBlocks(state.toJSON({
    preserveKeys: true
  }), type);
}

function isDocumentEqual(slateState, otherSlateState) {
  return slateState.get('document') === otherSlateState.get('document');
}

function isDeprecatedBlockSchema(type) {
  const blockType = type.of.find(ofType => ofType.name === 'block');

  if (blockType.span !== undefined) {
    return true;
  }

  return false;
}

function isDeprecatedBlockValue(value) {
  if (!value) {
    return false;
  }

  const block = value.find(item => item._type === 'block');

  if (block && Object.keys(block).includes('spans')) {
    return true;
  }

  return false;
}

var _default = (0, _withPatchSubscriber.default)((_temp = _class = class Syncer extends _react.default.PureComponent {
  constructor(props) {
    super();

    _defineProperty(this, "_blockEditor", void 0);

    _defineProperty(this, "handleNodePatch", patchEvent => {
      this.setState(prevState => {
        if (prevState.isOutOfSync) {
          return prevState;
        }

        const nextValue = patchEvent.patches.reduce((state, patch) => {
          const _patch$path = _toArray(patch.path),
                root = _patch$path[0],
                path = _patch$path.slice(1);

          const nodeValue = state.document.getDescendant(root._key).data.get('value');
          const change = state.change().setNodeByKey(root._key, {
            data: {
              value: _objectSpread({}, (0, _simplePatch.default)(nodeValue, _objectSpread({}, patch, {
                path
              })), {
                _key: root._key
              })
            }
          });
          return change.state;
        }, prevState.value);
        return {
          value: nextValue
        };
      });
    });

    _defineProperty(this, "handleChange", slateChange => {
      this.setState(prevState => prevState.isOutOfSync ? {} : {
        value: slateChange.state
      });
    });

    _defineProperty(this, "receivePatches", ({
      snapshot,
      shouldReset,
      patches
    }) => {
      if (patches.some(patch => patch.origin === 'remote')) {
        this.setState({
          isOutOfSync: true
        });
      }

      if (shouldReset) {} // @todo
      // eslint-disable-next-line no-console
      // console.warn('[BlockEditor] Reset state due to set patch that targeted ancestor path:', patches)
      // this.setState({value: deserialize(snapshot, this.props.type)})
      // else {
      //   // console.log('TODO: Apply patches:', patches)
      // }

    });

    _defineProperty(this, "handleSynchronize", () => {
      this.setState({
        value: deserialize(this.props.value, this.props.type),
        isOutOfSync: false
      });
    });

    _defineProperty(this, "emitSet", (0, _throttle2.default)(() => {
      const onChange = this.props.onChange; // const onChange = event => console.log(event.patch.type, event.patch.value)

      const value = this.state.value;
      const nextVal = serialize(value);
      onChange(_PatchEvent.default.from(nextVal ? (0, _PatchEvent.set)(nextVal) : (0, _PatchEvent.unset)()));
    }, 1000, {
      trailing: true
    }));

    const deprecatedSchema = isDeprecatedBlockSchema(props.type);
    const deprecatedBlockValue = isDeprecatedBlockValue(props.value);
    this.state = {
      isOutOfSync: false,
      deprecatedSchema,
      deprecatedBlockValue,
      value: deprecatedSchema || deprecatedBlockValue ? undefined : deserialize(props.value, props.type)
    };
    this.unsubscribe = props.subscribe(this.receivePatches);
  }

  focus() {
    if (this._blockEditor) {
      this._blockEditor.focus();
    }
  }

  setBlockEditor(blockEditor) {
    this._blockEditor = blockEditor;
  }

  componentWillUnmount() {
    // This is a defensive workaround for an issue causing content to be overwritten
    // It cancels any pending saves, so if the component gets unmounted within the
    // 1 second window, work may be lost.
    // This is by no means ideal, but preferable to overwriting content in other documents
    // Should be fixed by making the block editor "real" realtime
    this.emitSet.cancel();
    this.unsubscribe();
  }

  componentDidUpdate(prevProps, prevState) {
    const didSync = prevState.isOutOfSync && !this.state.isOutOfSync;

    if (!didSync && !isDocumentEqual(prevState.value, this.state.value)) {
      this.emitSet();
    }
  }

  render() {
    const _this$state = this.state,
          value = _this$state.value,
          isOutOfSync = _this$state.isOutOfSync,
          deprecatedSchema = _this$state.deprecatedSchema,
          deprecatedBlockValue = _this$state.deprecatedBlockValue;
    const isDeprecated = deprecatedSchema || deprecatedBlockValue;
    const type = this.props.type;
    return _react.default.createElement("div", {
      className: _Syncer.default.root
    }, !isDeprecated && _react.default.createElement(_BlockEditor.default, _extends({}, this.props, {
      disabled: isOutOfSync,
      onChange: this.handleChange,
      onNodePatch: this.handleNodePatch,
      value: value,
      ref: this._setBlockEditor
    })), isDeprecated && _react.default.createElement(_default2.default, {
      label: type.title
    }, _react.default.createElement("div", {
      className: _Syncer.default.disabledEditor
    }, _react.default.createElement("strong", null, "Heads up!"), _react.default.createElement("p", null, "You're using a new version of the Studio with", deprecatedSchema && " a block schema that hasn't been updated.", deprecatedSchema && deprecatedBlockValue && ' Also block text needs to be updated.', deprecatedBlockValue && !deprecatedSchema && " block text that hasn't been updated."), _react.default.createElement("p", null, _react.default.createElement("a", {
      href: (0, _generateHelpUrl.default)('migrate-to-block-children'),
      rel: "noopener noreferrer",
      target: "_blank"
    }, "Read more")))), isOutOfSync && _react.default.createElement("div", {
      className: _Syncer.default.isOutOfSyncWarning
    }, "Heads up! Someone else edited this field. Make sure to let your co-workers know that you are working on this part of the document!", _react.default.createElement("br", null), "We're sorry for the inconvenience and working hard to get it working properly.", _react.default.createElement("p", null, _react.default.createElement(_default3.default, {
      inverted: true,
      onClick: this.handleSynchronize
    }, "Load remote changes"))));
  }

}, _defineProperty(_class, "propTypes", {
  schema: _propTypes.default.object,
  value: _propTypes.default.array,
  type: _propTypes.default.object.isRequired,
  onChange: _propTypes.default.func,
  subscribe: _propTypes.default.func
}), _temp));

exports.default = _default;