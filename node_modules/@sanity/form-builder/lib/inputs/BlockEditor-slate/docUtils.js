"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitTextNodeIntoArraysOfCharacterBySpan = splitTextNodeIntoArraysOfCharacterBySpan;
exports.spanAccessorsToSlateNodes = spanAccessorsToSlateNodes;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _immutable = _interopRequireDefault(require("immutable"));

var _slate = require("slate");

var _accessors = require("./accessors");

var _conversion = require("./conversion");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Given marks extracts the embedded special mark that tells us which span index that char
// is in according to the document structure in Sanity
function extractSpanIndexFromMarks(marks) {
  const indexMark = marks.find(mark => mark.get('type') == '__spanIdx');

  if (indexMark) {
    return indexMark.get('data').get('index');
  }

  return null;
} // Take a slate text node and split it into an array of arrays of characters splitting every time
// marks change so that each array corresponds to one consecutive "span" of characters with identical
// formatting.


function splitTextNodeIntoArraysOfCharacterBySpan(textNode) {
  const result = textNode.characters.reduce((acc, char, idx) => {
    const prevChar = idx > 0 && textNode.characters.get(idx - 1);

    if (prevChar && _immutable.default.is(prevChar.marks, char.marks)) {
      acc[acc.length - 1].push(char);
    } else {
      // Find the span index of the next character and insert empty spans if need be to
      // make that next char still be in a span of that index. This is to ensure that the document structure
      // stays as described in the source Sanity document.
      const nextSpanIndex = extractSpanIndexFromMarks(char.marks) || 0;

      while (acc.length < nextSpanIndex) {
        acc.push([]);
      }

      acc.push([char]);
    }

    return acc;
  }, []);
  return result;
} // Take a number of consecutive sanity spans and join them together into an immutable character array for use with slate


function consecutiveSanitySpansToSlateText(key, spans, firstIndex) {
  let index = firstIndex;
  const chars = (0, _flatten2.default)(spans.map(span => {
    // Convert the marks from the span and add the book-keeping tag to keep track of which span each character belongs to
    const marks = (0, _conversion.sanityMarksToSlate)(span.marks).add(_slate.Mark.create({
      type: '__spanIdx',
      data: {
        index
      }
    }));
    index += 1;
    return span.content.split('').map(char => ({
      text: char,
      marks: marks
    }));
  }));
  return _slate.Text.create({
    key,
    characters: _immutable.default.List(chars.map(({
      text,
      marks
    }) => _slate.Character.create({
      text,
      marks
    })))
  });
} // Takes an array of span accessors and converts them into the corresponding list of immutable slate spans


function spanAccessorsToSlateNodes(spans) {
  let joined = _immutable.default.List();

  let i = 0;

  while (i < spans.length) {
    const span = spans[i];

    if (span instanceof _accessors.TextSpanAccessor) {
      const firstIndex = i; // consume until we get something else

      let next = i;

      while (next < spans.length && spans[next] instanceof _accessors.TextSpanAccessor) {
        // eslint-disable-line max-depth
        next++;
      }

      joined = joined.push(consecutiveSanitySpansToSlateText(span.key, spans.slice(i, next), firstIndex));
      i = next;
    }
  }

  return joined;
}