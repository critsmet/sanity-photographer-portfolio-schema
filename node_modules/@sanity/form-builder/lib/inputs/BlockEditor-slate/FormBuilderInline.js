"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _offsetKey = _interopRequireDefault(require("slate-react/lib/utils/offset-key"));

var _setTransferData = _interopRequireDefault(require("slate-react/lib/utils/set-transfer-data"));

var _transferTypes = _interopRequireDefault(require("slate-react/lib/constants/transfer-types"));

var _slateBase64Serializer = _interopRequireDefault(require("slate-base64-serializer"));

var _slate = require("slate");

var _ItemForm = _interopRequireDefault(require("./ItemForm"));

var _popover = _interopRequireDefault(require("part:@sanity/components/dialogs/popover"));

var _content = _interopRequireDefault(require("part:@sanity/components/dialogs/content"));

var _Preview = _interopRequireDefault(require("../../Preview"));

var _FormBuilderInline = _interopRequireDefault(require("./styles/FormBuilderInline.css"));

var _createRange = _interopRequireDefault(require("./util/createRange"));

var _simplePatch = require("../../simplePatch");

var _resolveTypeName = require("../../utils/resolveTypeName");

var _InvalidValueInput = _interopRequireDefault(require("../InvalidValueInput"));

var _StopPropagation = _interopRequireDefault(require("./StopPropagation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FormBuilderInline extends _react.default.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isSelected: false,
      isEditing: false,
      isDragging: false
    });

    _defineProperty(this, "_dropTarget", null);

    _defineProperty(this, "_editorNode", null);

    _defineProperty(this, "handleChange", event => {
      const _this$props = this.props,
            onPatch = _this$props.onPatch,
            node = _this$props.node;
      onPatch(event.prefixAll(node.key));
    });

    _defineProperty(this, "handleInvalidValueChange", event => {
      const _this$props2 = this.props,
            onPatch = _this$props2.onPatch,
            node = _this$props2.node;
      onPatch(event.prefixAll(node.key));
    });

    _defineProperty(this, "handleDragStart", event => {
      const editor = this.props.editor;
      this._editorNode = _reactDom.default.findDOMNode(editor);
      this.setState({
        isDragging: true
      });
      this.addDragHandlers();

      const element = _reactDom.default.findDOMNode(this.previewContainer);

      const encoded = _slateBase64Serializer.default.serializeNode(this.props.node, {
        preserveKeys: true
      });

      (0, _setTransferData.default)(event.dataTransfer, _transferTypes.default.NODE, encoded);
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setDragImage(element, element.clientWidth / 2, -10);
    });

    _defineProperty(this, "handleSelectionChange", event => {
      if (!this._editorNode || !this._editorNode.contains(event.target)) {
        return;
      }

      const selection = document.getSelection();
      const isSelected = selection.containsNode && selection.containsNode(this.formBuilderInline);
      this.setState({
        isSelected
      });
    });

    _defineProperty(this, "handleDragLeave", event => {
      if (event.target === this._editorNode) {
        this._dropTarget = null;
      }
    });

    _defineProperty(this, "handleDragOverOtherNode", event => {
      if (!this.state.isDragging) {
        return;
      }

      const targetDOMNode = event.target; // As the event is registered on the editor parent node
      // ignore the event if it is coming from from the editor node itself

      if (targetDOMNode === this._editorNode) {
        this._dropTarget = null;
        return;
      }

      const offsetKey = _offsetKey.default.findKey(targetDOMNode, 0);

      if (!offsetKey) {
        return;
      }

      const key = offsetKey.key; // If this is 'our' node, return

      if (this.props.node.hasDescendant(key)) {
        return;
      }

      const editor = this.props.editor;
      const state = editor.getState();
      const document = state.document;
      const range = (0, _createRange.default)(event);

      if (range === null) {
        return;
      }

      const rangeOffset = range.rangeOffset;
      const node = document.getDescendant(key);

      if (!node) {
        this._dropTarget = null;
        return;
      } // If we are dragging over a custom type block return


      const block = document.getClosestBlock(node.key);

      if (block && block.type !== 'contentBlock') {
        return;
      } // If we are dragging over another inline return


      if (document.getClosestInline(node.key)) {
        return;
      }

      this._dropTarget = {
        node: node,
        offset: rangeOffset
      };
      this.moveCursor(rangeOffset, node);
    });

    _defineProperty(this, "handleDragEnd", event => {
      this.setState({
        isDragging: false
      });
      this.removeDragHandlers();

      if (!this._dropTarget) {
        return;
      }

      const _this$props3 = this.props,
            editor = _this$props3.editor,
            node = _this$props3.node;
      const state = editor.getState();
      const change = state.change().removeNodeByKey(node.key).insertInline(node).focus();
      this._dropTarget = null;
      editor.onChange(change);
    });

    _defineProperty(this, "handleCancelEvent", event => {
      event.preventDefault();
    });

    _defineProperty(this, "handleToggleEdit", () => {
      this.setState({
        isEditing: true
      });
    });

    _defineProperty(this, "handleClose", () => {
      this.setState({
        isEditing: false
      });
    });

    _defineProperty(this, "refFormBuilderInline", formBuilderInline => {
      this.formBuilderInline = formBuilderInline;
    });

    _defineProperty(this, "refPreview", previewContainer => {
      this.previewContainer = previewContainer;
    });

    _defineProperty(this, "handleDialogAction", action => {
      if (action.name === 'close') {
        this.handleClose();
      }
    });
  }

  componentDidMount() {
    this.addSelectionHandler();
  }

  componentWillUnmount() {
    this.removeSelectionHandler();
  }

  addSelectionHandler() {
    document.addEventListener('selectionchange', this.handleSelectionChange);
  }

  removeSelectionHandler() {
    document.removeEventListener('selectionchange', this.handleSelectionChange);
  }

  addDragHandlers() {
    this._editorNode.addEventListener('dragover', this.handleDragOverOtherNode);

    this._editorNode.addEventListener('dragleave', this.handleDragLeave);
  }

  removeDragHandlers() {
    this._editorNode.removeEventListener('dragover', this.handleDragOverOtherNode);

    this._editorNode.removeEventListener('dragleave', this.handleDragLeave);
  }

  getValue() {
    return this.props.node.data.get('value');
  }

  getMemberTypeOf(value) {
    const typeName = (0, _resolveTypeName.resolveTypeName)(value);
    return this.props.type.of.find(memberType => memberType.name === typeName);
  }

  renderPreview() {
    const value = this.getValue();
    const memberType = this.getMemberTypeOf(value);

    if (!memberType) {
      const validMemberTypes = this.props.type.of.map(type => type.name);
      const actualType = (0, _resolveTypeName.resolveTypeName)(value);
      return _react.default.createElement(_InvalidValueInput.default, {
        validTypes: validMemberTypes,
        actualType: actualType,
        value: value,
        onChange: this.handleInvalidValueChange
      });
    }

    return _react.default.createElement("span", null, _react.default.createElement(_Preview.default, {
      type: memberType,
      value: this.getValue(),
      layout: "inline"
    }));
  }

  renderInput() {
    const value = this.getValue();
    const memberType = this.getMemberTypeOf(value);
    return _react.default.createElement(_popover.default, {
      title: this.props.node.title,
      onClose: this.handleClose,
      onClickOutside: this.handleClose,
      onEscape: this.handleClose,
      onAction: this.handleDialogAction,
      modifiers: {
        flip: {
          boundariesElement: 'viewport'
        },
        preventOverflow: {
          priority: ['bottom', 'top', 'right', 'left'],
          boundariesElement: 'viewport'
        }
      },
      showCloseButton: false,
      actions: [{
        index: '1',
        name: 'close',
        title: 'Close'
      }]
    }, _react.default.createElement(_content.default, {
      size: "medium"
    }, _react.default.createElement(_ItemForm.default, {
      onDrop: this.handleCancelEvent,
      type: memberType,
      level: 0,
      value: this.getValue(),
      onChange: this.handleChange
    })));
  }

  moveCursor(offset, node) {
    if (node.kind !== 'text') {
      return;
    }

    const editor = this.props.editor;
    const state = editor.getState();
    const document = state.document;
    let theOffset = offset; // Check if it is acceptable to move the cursor here

    const nextChars = document.getCharactersAtRange(_slate.Selection.create({
      anchorKey: node.key,
      focusKey: node.key,
      anchorOffset: offset - 1,
      focusOffset: offset,
      isFocused: true,
      isBackward: false
    }));

    if (!nextChars.size) {
      theOffset = 0;
    }

    const change = state.change().collapseToStartOf(node).move(theOffset).focus();
    editor.onChange(change);
  }

  render() {
    const isEditing = this.state.isEditing;
    const attributes = this.props.attributes;
    const _this$props4 = this.props,
          node = _this$props4.node,
          editor = _this$props4.editor;
    const isFocused = editor.props.blockEditor.props.value.selection.hasFocusIn(node);
    let className;

    if (isFocused && !this.state.isSelected) {
      className = _FormBuilderInline.default.focused;
    } else if (this.state.isSelected) {
      className = _FormBuilderInline.default.selected;
    } else {
      className = _FormBuilderInline.default.root;
    }

    return _react.default.createElement("span", _extends({}, attributes, {
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd,
      onDragEnter: this.handleCancelEvent,
      onDragLeave: this.handleCancelEvent,
      onDrop: this.handleCancelEvent,
      draggable: true,
      ref: this.refFormBuilderInline,
      className: className
    }), _react.default.createElement("span", {
      ref: this.refPreview,
      className: _FormBuilderInline.default.previewContainer,
      onClick: this.handleToggleEdit
    }, this.renderPreview()), isEditing && _react.default.createElement("span", {
      className: _FormBuilderInline.default.editInlineContainer
    }, _react.default.createElement(_StopPropagation.default, {
      tagName: "span"
    }, this.renderInput())));
  }

}

exports.default = FormBuilderInline;

_defineProperty(FormBuilderInline, "propTypes", {
  // Note: type refers to the array type, not the value type
  type: _propTypes.default.object,
  node: _propTypes.default.object,
  editor: _propTypes.default.object,
  state: _propTypes.default.object,
  attributes: _propTypes.default.object,
  onPatch: _propTypes.default.func
});