"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEqual = isEqual;
exports.isSegmentEqual = isSegmentEqual;
exports.hasFocus = hasFocus;
exports.hasItemFocus = hasItemFocus;
exports.isExpanded = isExpanded;
exports.startsWith = startsWith;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.toString = toString;
exports.FOCUS_TERMINATOR = void 0;

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function isEqual(path, otherPath) {
  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));
}

const FOCUS_TERMINATOR = '$';
exports.FOCUS_TERMINATOR = FOCUS_TERMINATOR;

function isSegmentEqual(pathSegment, otherPathSegment) {
  const pathSegmentType = typeof pathSegment;
  const otherPathSegmentType = typeof otherPathSegment;

  if (pathSegmentType !== otherPathSegmentType) {
    return false;
  }

  if (pathSegmentType === 'string' || pathSegmentType === 'number') {
    return pathSegment === otherPathSegment;
  }

  if (!pathSegment || !otherPathSegment) {
    return false;
  }

  return pathSegment._key === otherPathSegment._key;
}

function hasFocus(focusPath, path) {
  const _withoutFirst = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;

  return isEqual(_withoutFirst, path);
}

function hasItemFocus(focusPath, item) {
  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);
}

function isExpanded(segment, focusPath) {
  const _focusPath = _toArray(focusPath),
        head = _focusPath[0],
        tail = _focusPath.slice(1);

  return tail.length > 0 && isSegmentEqual(segment, head);
}

function startsWith(prefix, path) {
  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));
}

function trimLeft(prefix, path) {
  if (prefix.length === 0 || path.length === 0) {
    return path;
  }

  const _prefix = _toArray(prefix),
        prefixHead = _prefix[0],
        prefixTail = _prefix.slice(1);

  const _path = _toArray(path),
        pathHead = _path[0],
        pathTail = _path.slice(1);

  if (!isSegmentEqual(prefixHead, pathHead)) {
    return path;
  }

  return trimLeft(prefixTail, pathTail);
}

function trimRight(suffix, path) {
  const sufLen = suffix.length;
  const pathLen = path.length;

  if (sufLen === 0 || pathLen === 0) {
    return path;
  }

  let i = 0;

  while (i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])) {
    i++;
  }

  return path.slice(0, pathLen - i);
}

function toString(path) {
  return path.reduce((target, segment, i) => {
    const segmentType = typeof segment;

    if (segmentType === 'number') {
      return `${target}[${segment}]`;
    }

    if (segmentType === 'string') {
      const separator = i === 0 ? '' : '.';
      return `${target}${separator}${segment}`;
    }

    if (segment._key) {
      return `${target}[_key=="${segment._key}"]`;
    }

    throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
  }, '');
}