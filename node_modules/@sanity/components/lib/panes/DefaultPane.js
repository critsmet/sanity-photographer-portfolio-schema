"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _negate2 = _interopRequireDefault(require("lodash/negate"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _shallowEquals = _interopRequireDefault(require("shallow-equals"));

var _classnames = _interopRequireDefault(require("classnames"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/menus/default"));

var _moreVertIcon = _interopRequireDefault(require("part:@sanity/base/more-vert-icon"));

var _default3 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _intent = _interopRequireDefault(require("part:@sanity/components/buttons/intent"));

var _scrollContainer = _interopRequireDefault(require("part:@sanity/components/utilities/scroll-container"));

var _Styleable = _interopRequireDefault(require("../utilities/Styleable"));

var _DefaultPane = _interopRequireDefault(require("./styles/DefaultPane.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getActionKey(action, index) {
  return (typeof action.action === 'string' ? action.action + action.title : action.title) || index;
}

const getScrollShadowState = (scrollTop, prevState) => {
  const headerStyleRatio = prevState.headerStyleRatio;
  const threshold = 100;

  if (scrollTop < threshold) {
    // Round of the calculation to cut down rerenders that are not visible to the human eye
    // Example: 0.53 -> 0.55 or 0.91 -> 0.9
    const ratio = Math.round(scrollTop / threshold * 10 * 2) / 2 / 10;

    if (ratio === headerStyleRatio) {
      return null;
    }

    return {
      headerStyleRatio: ratio,
      headerStyle: {
        opacity: ratio + 0.5,
        boxShadow: `0 2px ${3 * ratio}px rgba(0, 0, 0, ${ratio * 0.3})`
      }
    };
  }

  if (scrollTop < 0 && headerStyleRatio !== -1) {
    return {
      headerStyleRatio: -1,
      headerStyle: {
        boxShadow: 'none'
      }
    };
  }

  if (headerStyleRatio !== 1) {
    return {
      headerStyleRatio: 1,
      headerStyle: {
        opacity: 1,
        boxShadow: '0 2px 3px rgba(0, 0, 0, 0.3)'
      }
    };
  }

  return null;
};

const noop = () => {
  /* intentional noop */
};

const isActionButton = item => item.showAsAction;

const isMenuButton = (0, _negate2.default)(isActionButton); // eslint-disable-next-line

class Pane extends _react.default.Component {
  constructor(props) {
    super(props); // Passed to rendered <Menu>. This prevents the "click outside" functionality
    // from kicking in when pressing the toggle menu button

    _defineProperty(this, "state", {
      menuIsOpen: false,
      headerStyleRatio: -1,
      headerStyle: {
        opacity: 0,
        boxShadow: 'none'
      }
    });

    _defineProperty(this, "handleToggleCollapsed", event => {
      if (this.props.isCollapsed) {
        this.props.onExpand(this);
      } else {
        this.props.onCollapse(this);
      }
    });

    _defineProperty(this, "handleContentScroll", event => {
      const shadowState = getScrollShadowState(event.target.scrollTop, this.state);

      if (shadowState) {
        this.setState(shadowState);
      }
    });

    _defineProperty(this, "handleCloseMenu", () => {
      this.setState({
        menuIsOpen: false
      });
    });

    _defineProperty(this, "handleMenuToggle", () => {
      this.setState(prev => ({
        menuIsOpen: !prev.menuIsOpen
      }));
    });

    _defineProperty(this, "handleMenuAction", item => {
      // When closing the menu outright, the menu button will be focused and the "enter" keypress
      // will bouble up to it and trigger a re-open of the menu. To work around this, use rAF to
      // ensure the current event is completed before closing the menu
      this.closeRequest = requestAnimationFrame(() => this.handleCloseMenu());

      if (typeof item.action === 'function') {
        item.action(item.params);
        return;
      }

      this.props.onAction(item);
    });

    _defineProperty(this, "renderIntentAction", (action, i) => {
      return _react.default.createElement(_intent.default, {
        key: getActionKey(action, i),
        title: action.title,
        icon: action.icon,
        color: "primary",
        kind: "simple",
        intent: action.intent.type,
        params: action.intent.params
      });
    });

    _defineProperty(this, "renderAction", (act, i) => {
      if (act.intent) {
        return this.renderIntentAction(act, i);
      }

      return _react.default.createElement(_default3.default, {
        key: getActionKey(act, i),
        title: act.title,
        icon: act.icon,
        color: "primary",
        kind: "simple",
        onClick: this.handleMenuAction.bind(this, act)
      });
    });

    this.paneMenuId = Math.random().toString(36).substr(2, 6);
  }

  static getDerivedStateFromProps(props, state) {
    if (typeof props.scrollTop === 'undefined') {
      return null;
    }

    return getScrollShadowState(props.scrollTop, state);
  }

  componentWillUnmount() {
    if (this.closeRequest) {
      cancelAnimationFrame(this.closeRequest);
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    // The pane header has a styling which gradually adds more shadow and tunes the opacity when
    // scrolling. In the case of "managed" lists (infinite scroll and such), the scroll position
    // is passed as a prop (`scrollTop`). However, passed a certain threshold we no longer need to
    // update, since the styling turns static. To prevent the prop from forcing a re-render,
    // explicitly check for a difference in the state here to short-circuit in this common scenario
    const scrollPropChanged = nextProps.scrollTop !== this.props.scrollTop;
    const headerStyleChanged = nextState.headerStyleRatio !== this.state.headerStyleRatio;

    if (scrollPropChanged && !headerStyleChanged) {
      return false;
    }

    return scrollPropChanged || headerStyleChanged || !(0, _shallowEquals.default)(nextProps, this.props) || !(0, _shallowEquals.default)(nextState, this.state);
  }

  renderMenu() {
    const _this$props = this.props,
          styles = _this$props.styles,
          menuItems = _this$props.menuItems,
          menuItemGroups = _this$props.menuItemGroups,
          isCollapsed = _this$props.isCollapsed;
    const menuIsOpen = this.state.menuIsOpen;
    const items = menuItems.filter(isMenuButton);

    if (items.length === 0) {
      return null;
    }

    return _react.default.createElement("div", {
      className: styles.menuWrapper
    }, _react.default.createElement("div", {
      className: styles.menuButtonContainer
    }, _react.default.createElement(_default3.default // Makes menu component ignore clicks on button (prevents double-toggling)
    , {
      "data-menu-button-id": this.paneMenuId,
      kind: "simple",
      icon: _moreVertIcon.default,
      onClick: this.handleMenuToggle,
      className: styles.menuButton
    })), _react.default.createElement("div", {
      className: styles.menuContainer
    }, menuIsOpen && _react.default.createElement(_default2.default, {
      id: this.paneMenuId,
      items: items,
      groups: menuItemGroups,
      origin: isCollapsed ? 'top-left' : 'top-right',
      onAction: this.handleMenuAction,
      onClose: this.handleCloseMenu,
      onClickOutside: this.handleCloseMenu
    })));
  }

  render() {
    const _this$props2 = this.props,
          title = _this$props2.title,
          children = _this$props2.children,
          isSelected = _this$props2.isSelected,
          isCollapsed = _this$props2.isCollapsed,
          menuItems = _this$props2.menuItems,
          styles = _this$props2.styles,
          renderActions = _this$props2.renderActions;
    const headerStyle = isCollapsed ? {} : this.state.headerStyle;
    const actions = menuItems.filter(act => act.showAsAction && (!isCollapsed || act.showAsAction.whenCollapsed));
    return _react.default.createElement("div", {
      className: (0, _classnames.default)([isCollapsed ? styles.isCollapsed : styles.root, isSelected ? styles.isActive : styles.isDisabled]),
      ref: this.setRootElement
    }, _react.default.createElement("div", {
      className: styles.header,
      style: {
        boxShadow: headerStyle.boxShadow
      }
    }, _react.default.createElement("div", {
      className: styles.headerContent
    }, _react.default.createElement("h2", {
      className: styles.title,
      onClick: this.handleToggleCollapsed
    }, title), renderActions ? renderActions(actions) : actions.map(this.renderAction)), this.renderMenu(), _react.default.createElement("div", {
      className: styles.headerBackground,
      style: {
        opacity: headerStyle.opacity
      }
    })), _react.default.createElement("div", {
      className: styles.main
    }, _react.default.createElement(_scrollContainer.default, {
      className: styles.scrollContainer,
      onScroll: this.handleContentScroll
    }, children)));
  }

}

_defineProperty(Pane, "propTypes", {
  title: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.node]),
  isCollapsed: _propTypes.default.bool,
  onExpand: _propTypes.default.func,
  onCollapse: _propTypes.default.func,
  children: _propTypes.default.node,
  isSelected: _propTypes.default.bool,
  scrollTop: _propTypes.default.number,
  onAction: _propTypes.default.func,
  renderActions: _propTypes.default.func,
  menuItems: _propTypes.default.arrayOf(_propTypes.default.shape({
    showAsAction: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.shape({
      whenCollapsed: _propTypes.default.bool
    })])
  })),
  menuItemGroups: _propTypes.default.arrayOf(_propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    title: _propTypes.default.string
  })),
  styles: _propTypes.default.object // eslint-disable-line react/forbid-prop-types

});

_defineProperty(Pane, "defaultProps", {
  title: 'Untitled',
  isCollapsed: false,
  isSelected: false,
  scrollTop: undefined,
  renderActions: undefined,
  styles: {},
  children: _react.default.createElement("div", null),
  onAction: noop,
  onCollapse: noop,
  onExpand: noop,
  menuItems: [],
  menuItemGroups: []
});

var _default = (0, _Styleable.default)(Pane, _DefaultPane.default);

exports.default = _default;