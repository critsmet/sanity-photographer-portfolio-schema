"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _simpleGet = _interopRequireDefault(require("simple-get"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _import = _interopRequireDefault(require("@sanity/import"));

var _padStart = _interopRequireDefault(require("lodash/padStart"));

var _prettyMs = _interopRequireDefault(require("pretty-ms"));

var _chooseDatasetPrompt = _interopRequireDefault(require("../../actions/dataset/chooseDatasetPrompt"));

var _debug = _interopRequireDefault(require("../../debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const helpText = `
Options
  --missing On duplicate document IDs, skip importing document in question
  --replace On duplicate document IDs, replace existing document with imported document

Examples
  # Import "moviedb.ndjson" from the current directory to the dataset called "moviedb"
  sanity dataset import moviedb.ndjson moviedb

  # Import "moviedb.tar.gz" from the current directory to the dataset called "moviedb",
  # replacing any documents encountered that have the same document IDs
  sanity dataset import moviedb.tar.gz moviedb --replace

  # Import from a folder containing an ndjson file, such as an extracted tarball
  # retrieved through "sanity dataset export".
  sanity dataset import ~/some/folder moviedb

  # Import from a remote URL. Will download and extract the tarball to a temporary
  # location before importing it.
  sanity dataset import https://some.url/moviedb.tar.gz moviedb --replace
`;
var _default = {
  name: 'import',
  group: 'dataset',
  signature: '[FILE | FOLDER | URL] [TARGET_DATASET]',
  description: 'Import documents to given dataset from ndjson file',
  helpText,
  action: function () {
    var _action = _asyncToGenerator(function* (args, context) {
      const apiClient = context.apiClient,
            output = context.output,
            chalk = context.chalk,
            fromInitCommand = context.fromInitCommand;
      const operation = getMutationOperation(args.extOptions);
      const client = apiClient();

      const _args$argsWithoutOpti = _slicedToArray(args.argsWithoutOptions, 2),
            file = _args$argsWithoutOpti[0],
            target = _args$argsWithoutOpti[1];

      if (!file) {
        throw new Error(`Source file name and target dataset must be specified ("sanity dataset import ${chalk.bold('[file]')} [dataset]")`);
      }

      const targetDataset = yield determineTargetDataset(target, context);
      (0, _debug.default)(`Target dataset has been set to "${targetDataset}"`);
      const isUrl = /^https?:\/\//i.test(file);
      let inputStream;
      let sourceIsFolder = false;

      if (isUrl) {
        (0, _debug.default)('Input is a URL, streaming from source URL');
        inputStream = yield getUrlStream(file);
      } else {
        const sourceFile = _path.default.resolve(process.cwd(), file);

        const fileStats = yield _fsExtra.default.stat(sourceFile).catch(() => null);

        if (!fileStats) {
          throw new Error(`${sourceFile} does not exist or is not readable`);
        }

        sourceIsFolder = fileStats.isDirectory();
        inputStream = sourceIsFolder ? sourceFile : yield _fsExtra.default.createReadStream(sourceFile);
      }

      const importClient = client.clone().config({
        dataset: targetDataset
      });
      let currentStep;
      let currentProgress;
      let stepStart;
      let spinInterval;
      let percent;

      function onProgress(opts) {
        const lengthComputable = opts.total;
        const sameStep = opts.step == currentStep;
        percent = getPercentage(opts);

        if (lengthComputable && opts.total === opts.current) {
          clearInterval(spinInterval);
          spinInterval = null;
        }

        if (sameStep) {
          return;
        } // Moved to a new step


        const prevStep = currentStep;
        const prevStepStart = stepStart || Date.now();
        stepStart = Date.now();
        currentStep = opts.step;

        if (currentProgress && currentProgress.succeed) {
          const timeSpent = (0, _prettyMs.default)(Date.now() - prevStepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `[100%] ${prevStep} (${timeSpent})`;
          currentProgress.succeed();
        }

        currentProgress = output.spinner(`[0%] ${opts.step} (0.00s)`).start();

        if (spinInterval) {
          clearInterval(spinInterval);
          spinInterval = null;
        }

        spinInterval = setInterval(() => {
          const timeSpent = (0, _prettyMs.default)(Date.now() - prevStepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `${percent}${opts.step} (${timeSpent})`;
        }, 60);
      }

      function endTask({
        success
      }) {
        clearInterval(spinInterval);
        spinInterval = null;

        if (success) {
          const timeSpent = (0, _prettyMs.default)(Date.now() - stepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `[100%] ${currentStep} (${timeSpent})`;
          currentProgress.succeed();
        } else if (currentProgress) {
          currentProgress.fail();
        }
      } // Start the import!


      try {
        const imported = yield (0, _import.default)(inputStream, {
          client: importClient,
          operation,
          onProgress
        });
        endTask({
          success: true
        });
        output.print('Done! Imported %d documents to dataset "%s"', imported, targetDataset);
      } catch (err) {
        endTask({
          success: false
        });
        let error = err.message;

        if (!fromInitCommand && err.response && err.response.statusCode === 409) {
          error = [err.message, '', 'You probably want either:', ' --replace (replace existing documents with same IDs)', ' --missing (only import documents that do not already exist)'].join('\n');
          err.message = error;
        }

        throw err;
      }
    });

    return function action(_x, _x2) {
      return _action.apply(this, arguments);
    };
  }()
};
exports.default = _default;

function determineTargetDataset(_x3, _x4) {
  return _determineTargetDataset.apply(this, arguments);
}

function _determineTargetDataset() {
  _determineTargetDataset = _asyncToGenerator(function* (target, context) {
    const apiClient = context.apiClient,
          output = context.output,
          prompt = context.prompt;
    const client = apiClient();
    (0, _debug.default)('[  0%] Fetching available datasets');
    const spinner = output.spinner('Fetching available datasets').start();
    const datasets = yield client.datasets.list();
    spinner.succeed('[100%] Fetching available datasets');
    let targetDataset = target ? `${target}` : null;

    if (!targetDataset) {
      targetDataset = yield (0, _chooseDatasetPrompt.default)(context, {
        message: 'Select target dataset',
        allowCreation: true
      });
    } else if (!datasets.find(dataset => dataset.name === targetDataset)) {
      (0, _debug.default)('Target dataset does not exist, prompting for creation');
      const shouldCreate = yield prompt.single({
        type: 'confirm',
        message: `Dataset "${targetDataset}" does not exist, would you like to create it?`,
        default: true
      });

      if (!shouldCreate) {
        throw new Error(`Dataset "${targetDataset}" does not exist`);
      }

      yield client.datasets.create(targetDataset);
    }

    return targetDataset;
  });
  return _determineTargetDataset.apply(this, arguments);
}

function getMutationOperation(flags) {
  const replace = flags.replace,
        missing = flags.missing;

  if (replace && missing) {
    throw new Error('Cannot use both --replace and --missing');
  }

  if (flags.replace) {
    return 'createOrReplace';
  }

  if (flags.missing) {
    return 'createIfNotExists';
  }

  return 'create';
}

function getPercentage(opts) {
  if (!opts.total) {
    return '';
  }

  const percent = Math.floor(opts.current / opts.total * 100);
  return `[${(0, _padStart.default)(percent, 3, ' ')}%] `;
}

function getUrlStream(url) {
  return new Promise((resolve, reject) => {
    (0, _simpleGet.default)(url, (err, res) => err ? reject(err) : resolve(res));
  });
}