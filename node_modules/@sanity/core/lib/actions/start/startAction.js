"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _es6Promisify = require("es6-promisify");

var _server = require("@sanity/server");

var _getConfig = _interopRequireDefault(require("@sanity/util/lib/getConfig"));

var _reinitializePluginConfigs = require("../../actions/config/reinitializePluginConfigs");

var _checkReactCompatibility = _interopRequireDefault(require("../../util/checkReactCompatibility"));

var _formatMessage = require("./formatMessage");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (args, context) {
    const flags = args.extOptions;
    const output = context.output,
          workDir = context.workDir;
    const sanityConfig = (0, _getConfig.default)(workDir);
    const config = sanityConfig.get('server');
    const port = config.port,
          hostname = config.hostname;
    const httpHost = flags.host === 'all' ? '0.0.0.0' : flags.host || hostname;
    const httpPort = flags.port || port;
    const serverOptions = {
      staticPath: resolveStaticPath(workDir, config),
      basePath: workDir,
      httpHost,
      httpPort,
      context,
      project: sanityConfig.get('project')
    };
    (0, _checkReactCompatibility.default)(workDir);
    let compileSpinner;
    const configSpinner = output.spinner('Checking configuration files...');
    yield (0, _reinitializePluginConfigs.tryInitializePluginConfigs)({
      workDir,
      output
    });
    configSpinner.succeed();
    const server = (0, _server.getDevServer)(serverOptions);
    const compiler = server.locals.compiler; // "invalid" doesn't mean the bundle is invalid, but that it is *invalidated*,
    // in other words, it's recompiling

    compiler.plugin('invalid', () => {
      output.clear();
      resetSpinner();
    }); // Start the server and try to create more user-friendly errors if we encounter issues

    try {
      yield (0, _es6Promisify.promisify)(server.listen.bind(server))(httpPort, httpHost);
    } catch (err) {
      gracefulDeath(httpHost, config, err);
    } // Hold off on showing the spinner until compilation has started


    compiler.plugin('compile', () => resetSpinner()); // "done" event fires when Webpack has finished recompiling the bundle.
    // Whether or not you have warnings or errors, you will get this event.

    compiler.plugin('done', stats => {
      if (compileSpinner) {
        compileSpinner.succeed();
      }

      const hasErrors = stats.hasErrors();
      const hasWarnings = stats.hasWarnings();

      if (!hasErrors && !hasWarnings) {
        output.print(_chalk.default.green(`Content Studio successfully compiled! Go to http://${httpHost}:${httpPort}`) // eslint-disable-line max-len
        );
        return;
      }

      const _stats$toJson = stats.toJson({}, true),
            errors = _stats$toJson.errors,
            warnings = _stats$toJson.warnings;

      if (hasErrors) {
        printErrors(output, errors);
        return; // If errors exist, ignore warnings.
      }

      if (hasWarnings) {
        printWarnings(output, warnings);
      }

      output.print(_chalk.default.green(`Content Studio listening on http://${httpHost}:${httpPort}`));
    });

    function resetSpinner() {
      if (compileSpinner) {
        compileSpinner.stop();
      }

      compileSpinner = output.spinner('Compiling...').start();
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = _default;

function resolveStaticPath(rootDir, config) {
  const staticPath = config.staticPath;
  return _path.default.isAbsolute(staticPath) ? staticPath : _path.default.resolve(_path.default.join(rootDir, staticPath));
}

function gracefulDeath(httpHost, config, err) {
  if (err.code === 'EADDRINUSE') {
    throw new Error('Port number is already in use, configure `server.port` in `sanity.json`');
  }

  if (err.code === 'EACCES') {
    const help = config.port < 1024 ? 'port numbers below 1024 requires root privileges' : `do you have access to listen to the given host (${httpHost})?`;
    throw new Error(`The Content Studio server does not have access to listen to given port - ${help}`); // eslint-disable-line max-len
  }

  throw err;
}

function printErrors(output, errors) {
  output.print(_chalk.default.red('Failed to compile.'));
  output.print('');
  const formattedErrors = (errors.some(_formatMessage.isLikelyASyntaxError) ? errors.filter(_formatMessage.isLikelyASyntaxError) : errors).map(message => `Error in ${(0, _formatMessage.formatMessage)(message)}`);
  formattedErrors.forEach(message => {
    output.print(message);
    output.print('');
  });
}

function printWarnings(output, warnings) {
  output.print(_chalk.default.yellow('Compiled with warnings.'));
  output.print();
  warnings.map(message => `Warning in ${(0, _formatMessage.formatMessage)(message)}`).forEach(message => {
    output.print(message);
    output.print();
  });
}