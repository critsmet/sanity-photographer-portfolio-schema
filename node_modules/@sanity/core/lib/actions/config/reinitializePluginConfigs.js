"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tryInitializePluginConfigs = tryInitializePluginConfigs;
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _pathExists = _interopRequireDefault(require("path-exists"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _resolver = _interopRequireDefault(require("@sanity/resolver"));

var _normalizePluginName = _interopRequireDefault(require("../../util/normalizePluginName"));

var _generateConfigChecksum = _interopRequireDefault(require("../../util/generateConfigChecksum"));

var _pluginChecksumManifest = require("../../util/pluginChecksumManifest");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function reinitializePluginConfigs(_x) {
  return _reinitializePluginConfigs.apply(this, arguments);
}

function _reinitializePluginConfigs() {
  _reinitializePluginConfigs = _asyncToGenerator(function* (options, flags = {}) {
    const workDir = options.workDir,
          output = options.output;
    const localChecksums = yield (0, _pluginChecksumManifest.getChecksums)(workDir);
    const allPlugins = yield (0, _resolver.default)({
      basePath: workDir
    });
    const pluginsWithDistConfig = (yield Promise.all(allPlugins.map(pluginHasDistConfig))).filter(Boolean);
    const distChecksums = yield Promise.all(pluginsWithDistConfig.map(getPluginConfigChecksum));
    const withLocalConfigs = yield Promise.all(distChecksums.map(hasLocalConfig));
    const missingConfigs = yield Promise.all(withLocalConfigs.map(createMissingConfig));
    const configPlugins = missingConfigs.map(warnOnDifferingChecksum);
    return missingConfigs.length > 0 ? saveNewChecksums(configPlugins) : Promise.resolve();

    function hasLocalConfig(plugin) {
      return (0, _pluginChecksumManifest.localConfigExists)(workDir, plugin.name).then(configDeployed => Object.assign({}, plugin, {
        configDeployed
      }));
    }

    function createMissingConfig(plugin) {
      if (plugin.configDeployed) {
        return plugin;
      }

      const srcPath = _path.default.join(plugin.path, 'config.dist.json');

      const dstPath = _path.default.join(workDir, 'config', `${(0, _normalizePluginName.default)(plugin.name)}.json`);

      const prtPath = _path.default.relative(workDir, dstPath);

      if (!flags.quiet) {
        output.print(`Plugin "${plugin.name}" is missing local configuration file, creating ${prtPath}`);
      }

      return _fsExtra.default.copy(srcPath, dstPath).then(() => plugin);
    }

    function warnOnDifferingChecksum(plugin) {
      return plugin; // Disabled for now, until we can provide a way to fix.
      // NOTE: A similar checksum diff check is also done when running the install command
      // See https://github.com/sanity-io/sanity/pull/298
      // if (flags.quiet) {
      //   return plugin
      // }
      //
      // const local = localChecksums[plugin.name]
      // if (typeof local !== 'undefined' && local !== plugin.configChecksum) {
      //   const name = normalizePluginName(plugin.name)
      //   output.print(
      //     `[WARN] Default configuration file for plugin "${name}" has changed since local copy was created`
      //   )
      // }
      //
      // return plugin
    }

    function saveNewChecksums(plugins) {
      const sums = Object.assign({}, localChecksums);
      plugins.forEach(plugin => {
        if (!sums[plugin.name]) {
          sums[plugin.name] = plugin.configChecksum;
        }
      });
      return (0, _pluginChecksumManifest.setChecksums)(workDir, sums);
    }
  });
  return _reinitializePluginConfigs.apply(this, arguments);
}

function tryInitializePluginConfigs(_x2) {
  return _tryInitializePluginConfigs.apply(this, arguments);
}

function _tryInitializePluginConfigs() {
  _tryInitializePluginConfigs = _asyncToGenerator(function* (options, flags = {}) {
    try {
      yield reinitializePluginConfigs(options, flags);
    } catch (err) {
      if (err.code !== 'PluginNotFound') {
        throw err;
      }

      const manifest = yield _fsExtra.default.readJson(_path.default.join(options.workDir, 'package.json')).catch(() => ({}));
      const dependencies = Object.keys(Object.assign({}, manifest.dependencies, manifest.devDependencies));
      const depName = err.plugin[0] === '@' ? err.plugin : `sanity-plugin-${err.plugin}`;

      if (dependencies.includes(depName)) {
        err.message = `${err.message}\n\nTry running "sanity install"?`;
      } else {
        err.message = `${err.message}\n\nTry running "sanity install ${depName}"?`;
      }

      throw err;
    }
  });
  return _tryInitializePluginConfigs.apply(this, arguments);
}

var _default = reinitializePluginConfigs;
exports.default = _default;

function getPluginConfigPath(plugin) {
  return _path.default.join(plugin.path, 'config.dist.json');
}

function pluginHasDistConfig(plugin) {
  const configPath = getPluginConfigPath(plugin);
  return (0, _pathExists.default)(configPath).then(exists => exists && plugin);
}

function getPluginConfigChecksum(plugin) {
  return (0, _generateConfigChecksum.default)(getPluginConfigPath(plugin)).then(configChecksum => Object.assign({}, plugin, {
    configChecksum
  }));
}