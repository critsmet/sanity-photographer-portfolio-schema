'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isPlainObject = require('is-plain-object');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _immutable = require('immutable');

var _modelTypes = require('../constants/model-types');

var _modelTypes2 = _interopRequireDefault(_modelTypes);

var _selection = require('./selection');

var _selection2 = _interopRequireDefault(_selection);

var _mark = require('./mark');

var _mark2 = _interopRequireDefault(_mark);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Default properties.
 *
 * @type {Object}
 */

var DEFAULTS = {
  range: null,
  marks: new _immutable.Set()
};

/**
 * Decoration.
 *
 * @type {Decoration}
 */

var Decoration = function (_Record) {
  _inherits(Decoration, _Record);

  function Decoration() {
    _classCallCheck(this, Decoration);

    return _possibleConstructorReturn(this, (Decoration.__proto__ || Object.getPrototypeOf(Decoration)).apply(this, arguments));
  }

  _createClass(Decoration, [{
    key: 'getCharacters',


    /**
     * Return range as a list of characters
     *
     * @return {List<Character>}
     */

    value: function getCharacters() {
      var marks = this.marks;

      var characters = Character.createList(this.text.split('').map(function (char) {
        return Character.create({
          text: char,
          marks: marks
        });
      }));

      return characters;
    }

    /**
     * Return a JSON representation of the range.
     *
     * @return {Object}
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var object = {
        kind: this.kind,
        marks: this.marks.toArray().map(function (m) {
          return m.toJSON();
        }),
        text: this.text
      };

      return object;
    }

    /**
     * Alias `toJS`.
     */

  }, {
    key: 'toJS',
    value: function toJS() {
      return this.toJSON();
    }
  }, {
    key: 'kind',


    /**
     * Get the node's kind.
     *
     * @return {String}
     */

    get: function get() {
      return 'range';
    }
  }], [{
    key: 'create',


    /**
     * Create a new `Decoration` with `attrs`.
     *
     * @param {Object|Decoration} attrs
     * @return {Decoration}
     */

    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (Decoration.isDecoration(attrs)) {
        return attrs;
      }

      if ((0, _isPlainObject2.default)(attrs)) {
        return Decoration.fromJSON(attrs);
      }

      throw new Error('`Decoration.create` only accepts objects or decorations, but you passed it: ' + attrs);
    }

    /**
     * Create a list of `Decorations` from `value`.
     *
     * @param {Array<Decoration|Object>|List<Decoration|Object>} value
     * @return {List<Decoration>}
     */

  }, {
    key: 'createList',
    value: function createList() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (_immutable.List.isList(value) || Array.isArray(value)) {
        var list = new _immutable.List(value.map(Decoration.create));
        return list;
      }

      throw new Error('`Decoration.createList` only accepts arrays or lists, but you passed it: ' + value);
    }

    /**
     * Create a `Decoration` from a JSON `object`.
     *
     * @param {Object} object
     * @return {Decoration}
     */

  }, {
    key: 'fromJSON',
    value: function fromJSON(object) {
      var range = object.range,
          _object$marks = object.marks,
          marks = _object$marks === undefined ? [] : _object$marks;


      var decoration = new Decoration({
        range: _selection2.default.fromJSON(range),
        marks: new _immutable.Set(marks.map(_mark2.default.fromJSON))
      });

      return decoration;
    }

    /**
     * Alias `fromJS`.
     */

  }, {
    key: 'isDecoration',


    /**
     * Check if a `value` is a `Decoration`.
     *
     * @param {Any} value
     * @return {Boolean}
     */

    value: function isDecoration(value) {
      return !!(value && value[_modelTypes2.default.RANGE]);
    }

    /**
     * Check if a `value` is a list of ranges.
     *
     * @param {Any} value
     * @return {Boolean}
     */

  }, {
    key: 'isDecorationList',
    value: function isDecorationList(value) {
      return _immutable.List.isList(value) && value.every(function (item) {
        return Decoration.isDecoration(item);
      });
    }
  }]);

  return Decoration;
}((0, _immutable.Record)(DEFAULTS));

/**
 * Attach a pseudo-symbol for type checking.
 */

Decoration.fromJS = Decoration.fromJSON;
Decoration.prototype[_modelTypes2.default.RANGE] = true;

/**
 * Export.
 *
 * @type {Decoration}
 */

exports.default = Decoration;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvZGVjb3JhdGlvbi5qcyJdLCJuYW1lcyI6WyJERUZBVUxUUyIsInJhbmdlIiwibWFya3MiLCJEZWNvcmF0aW9uIiwiY2hhcmFjdGVycyIsIkNoYXJhY3RlciIsImNyZWF0ZUxpc3QiLCJ0ZXh0Iiwic3BsaXQiLCJtYXAiLCJjaGFyIiwiY3JlYXRlIiwib2JqZWN0Iiwia2luZCIsInRvQXJyYXkiLCJtIiwidG9KU09OIiwiYXR0cnMiLCJpc0RlY29yYXRpb24iLCJmcm9tSlNPTiIsIkVycm9yIiwidmFsdWUiLCJpc0xpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJsaXN0IiwiZGVjb3JhdGlvbiIsIlJBTkdFIiwiZXZlcnkiLCJpdGVtIiwiZnJvbUpTIiwicHJvdG90eXBlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7O0FBTUEsSUFBTUEsV0FBVztBQUNmQyxTQUFPLElBRFE7QUFFZkMsU0FBTztBQUZRLENBQWpCOztBQUtBOzs7Ozs7SUFNTUMsVTs7Ozs7Ozs7Ozs7OztBQWdHSjs7Ozs7O29DQU1nQjtBQUFBLFVBQ05ELEtBRE0sR0FDSSxJQURKLENBQ05BLEtBRE07O0FBRWQsVUFBTUUsYUFBYUMsVUFBVUMsVUFBVixDQUFxQixLQUFLQyxJQUFMLENBQ3JDQyxLQURxQyxDQUMvQixFQUQrQixFQUVyQ0MsR0FGcUMsQ0FFakMsVUFBQ0MsSUFBRCxFQUFVO0FBQ2IsZUFBT0wsVUFBVU0sTUFBVixDQUFpQjtBQUN0QkosZ0JBQU1HLElBRGdCO0FBRXRCUjtBQUZzQixTQUFqQixDQUFQO0FBSUQsT0FQcUMsQ0FBckIsQ0FBbkI7O0FBU0EsYUFBT0UsVUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs2QkFNUztBQUNQLFVBQU1RLFNBQVM7QUFDYkMsY0FBTSxLQUFLQSxJQURFO0FBRWJYLGVBQU8sS0FBS0EsS0FBTCxDQUFXWSxPQUFYLEdBQXFCTCxHQUFyQixDQUF5QjtBQUFBLGlCQUFLTSxFQUFFQyxNQUFGLEVBQUw7QUFBQSxTQUF6QixDQUZNO0FBR2JULGNBQU0sS0FBS0E7QUFIRSxPQUFmOztBQU1BLGFBQU9LLE1BQVA7QUFDRDs7QUFFRDs7Ozs7OzJCQUlPO0FBQ0wsYUFBTyxLQUFLSSxNQUFMLEVBQVA7QUFDRDs7Ozs7QUFwREQ7Ozs7Ozt3QkFNVztBQUNULGFBQU8sT0FBUDtBQUNEOzs7OztBQTVGRDs7Ozs7Ozs2QkFPMEI7QUFBQSxVQUFaQyxLQUFZLHVFQUFKLEVBQUk7O0FBQ3hCLFVBQUlkLFdBQVdlLFlBQVgsQ0FBd0JELEtBQXhCLENBQUosRUFBb0M7QUFDbEMsZUFBT0EsS0FBUDtBQUNEOztBQUVELFVBQUksNkJBQWNBLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixlQUFPZCxXQUFXZ0IsUUFBWCxDQUFvQkYsS0FBcEIsQ0FBUDtBQUNEOztBQUVELFlBQU0sSUFBSUcsS0FBSixrRkFBMkZILEtBQTNGLENBQU47QUFDRDs7QUFFRDs7Ozs7Ozs7O2lDQU84QjtBQUFBLFVBQVpJLEtBQVksdUVBQUosRUFBSTs7QUFDNUIsVUFBSSxnQkFBS0MsTUFBTCxDQUFZRCxLQUFaLEtBQXNCRSxNQUFNQyxPQUFOLENBQWNILEtBQWQsQ0FBMUIsRUFBZ0Q7QUFDOUMsWUFBTUksT0FBTyxvQkFBU0osTUFBTVosR0FBTixDQUFVTixXQUFXUSxNQUFyQixDQUFULENBQWI7QUFDQSxlQUFPYyxJQUFQO0FBQ0Q7O0FBRUQsWUFBTSxJQUFJTCxLQUFKLCtFQUF3RkMsS0FBeEYsQ0FBTjtBQUNEOztBQUVEOzs7Ozs7Ozs7NkJBT2dCVCxNLEVBQVE7QUFBQSxVQUVwQlgsS0FGb0IsR0FJbEJXLE1BSmtCLENBRXBCWCxLQUZvQjtBQUFBLDBCQUlsQlcsTUFKa0IsQ0FHcEJWLEtBSG9CO0FBQUEsVUFHcEJBLEtBSG9CLGlDQUdaLEVBSFk7OztBQU10QixVQUFNd0IsYUFBYSxJQUFJdkIsVUFBSixDQUFlO0FBQ2hDRixlQUFPLG9CQUFVa0IsUUFBVixDQUFtQmxCLEtBQW5CLENBRHlCO0FBRWhDQyxlQUFPLG1CQUFRQSxNQUFNTyxHQUFOLENBQVUsZUFBS1UsUUFBZixDQUFSO0FBRnlCLE9BQWYsQ0FBbkI7O0FBS0EsYUFBT08sVUFBUDtBQUNEOztBQUVEOzs7Ozs7OztBQU1BOzs7Ozs7O2lDQU9vQkwsSyxFQUFPO0FBQ3pCLGFBQU8sQ0FBQyxFQUFFQSxTQUFTQSxNQUFNLHFCQUFZTSxLQUFsQixDQUFYLENBQVI7QUFDRDs7QUFFRDs7Ozs7Ozs7O3FDQU93Qk4sSyxFQUFPO0FBQzdCLGFBQU8sZ0JBQUtDLE1BQUwsQ0FBWUQsS0FBWixLQUFzQkEsTUFBTU8sS0FBTixDQUFZO0FBQUEsZUFBUXpCLFdBQVdlLFlBQVgsQ0FBd0JXLElBQXhCLENBQVI7QUFBQSxPQUFaLENBQTdCO0FBQ0Q7Ozs7RUFwRnNCLHVCQUFPN0IsUUFBUCxDOztBQThJekI7Ozs7QUE5SU1HLFUsQ0E4REcyQixNLEdBQVMzQixXQUFXZ0IsUTtBQW9GN0JoQixXQUFXNEIsU0FBWCxDQUFxQixxQkFBWUosS0FBakMsSUFBMEMsSUFBMUM7O0FBRUE7Ozs7OztrQkFNZXhCLFUiLCJmaWxlIjoiZGVjb3JhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnaXMtcGxhaW4tb2JqZWN0J1xuaW1wb3J0IHsgTGlzdCwgUmVjb3JkLCBTZXQgfSBmcm9tICdpbW11dGFibGUnXG5cbmltcG9ydCBNT0RFTF9UWVBFUyBmcm9tICcuLi9jb25zdGFudHMvbW9kZWwtdHlwZXMnXG5pbXBvcnQgU2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJ1xuaW1wb3J0IE1hcmsgZnJvbSAnLi9tYXJrJ1xuXG4vKipcbiAqIERlZmF1bHQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IERFRkFVTFRTID0ge1xuICByYW5nZTogbnVsbCxcbiAgbWFya3M6IG5ldyBTZXQoKSxcbn1cblxuLyoqXG4gKiBEZWNvcmF0aW9uLlxuICpcbiAqIEB0eXBlIHtEZWNvcmF0aW9ufVxuICovXG5cbmNsYXNzIERlY29yYXRpb24gZXh0ZW5kcyBSZWNvcmQoREVGQVVMVFMpIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBEZWNvcmF0aW9uYCB3aXRoIGBhdHRyc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fERlY29yYXRpb259IGF0dHJzXG4gICAqIEByZXR1cm4ge0RlY29yYXRpb259XG4gICAqL1xuXG4gIHN0YXRpYyBjcmVhdGUoYXR0cnMgPSB7fSkge1xuICAgIGlmIChEZWNvcmF0aW9uLmlzRGVjb3JhdGlvbihhdHRycykpIHtcbiAgICAgIHJldHVybiBhdHRyc1xuICAgIH1cblxuICAgIGlmIChpc1BsYWluT2JqZWN0KGF0dHJzKSkge1xuICAgICAgcmV0dXJuIERlY29yYXRpb24uZnJvbUpTT04oYXR0cnMpXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBcXGBEZWNvcmF0aW9uLmNyZWF0ZVxcYCBvbmx5IGFjY2VwdHMgb2JqZWN0cyBvciBkZWNvcmF0aW9ucywgYnV0IHlvdSBwYXNzZWQgaXQ6ICR7YXR0cnN9YClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsaXN0IG9mIGBEZWNvcmF0aW9uc2AgZnJvbSBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PERlY29yYXRpb258T2JqZWN0PnxMaXN0PERlY29yYXRpb258T2JqZWN0Pn0gdmFsdWVcbiAgICogQHJldHVybiB7TGlzdDxEZWNvcmF0aW9uPn1cbiAgICovXG5cbiAgc3RhdGljIGNyZWF0ZUxpc3QodmFsdWUgPSBbXSkge1xuICAgIGlmIChMaXN0LmlzTGlzdCh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IGxpc3QgPSBuZXcgTGlzdCh2YWx1ZS5tYXAoRGVjb3JhdGlvbi5jcmVhdGUpKVxuICAgICAgcmV0dXJuIGxpc3RcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYERlY29yYXRpb24uY3JlYXRlTGlzdFxcYCBvbmx5IGFjY2VwdHMgYXJyYXlzIG9yIGxpc3RzLCBidXQgeW91IHBhc3NlZCBpdDogJHt2YWx1ZX1gKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBEZWNvcmF0aW9uYCBmcm9tIGEgSlNPTiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtEZWNvcmF0aW9ufVxuICAgKi9cblxuICBzdGF0aWMgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmFuZ2UsXG4gICAgICBtYXJrcyA9IFtdLFxuICAgIH0gPSBvYmplY3RcblxuICAgIGNvbnN0IGRlY29yYXRpb24gPSBuZXcgRGVjb3JhdGlvbih7XG4gICAgICByYW5nZTogU2VsZWN0aW9uLmZyb21KU09OKHJhbmdlKSxcbiAgICAgIG1hcmtzOiBuZXcgU2V0KG1hcmtzLm1hcChNYXJrLmZyb21KU09OKSksXG4gICAgfSlcblxuICAgIHJldHVybiBkZWNvcmF0aW9uXG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgYGZyb21KU2AuXG4gICAqL1xuXG4gIHN0YXRpYyBmcm9tSlMgPSBEZWNvcmF0aW9uLmZyb21KU09OXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgYHZhbHVlYCBpcyBhIGBEZWNvcmF0aW9uYC5cbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG4gIHN0YXRpYyBpc0RlY29yYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbTU9ERUxfVFlQRVMuUkFOR0VdKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgYHZhbHVlYCBpcyBhIGxpc3Qgb2YgcmFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgc3RhdGljIGlzRGVjb3JhdGlvbkxpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gTGlzdC5pc0xpc3QodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGl0ZW0gPT4gRGVjb3JhdGlvbi5pc0RlY29yYXRpb24oaXRlbSkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBub2RlJ3Mga2luZC5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBnZXQga2luZCgpIHtcbiAgICByZXR1cm4gJ3JhbmdlJ1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiByYW5nZSBhcyBhIGxpc3Qgb2YgY2hhcmFjdGVyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtMaXN0PENoYXJhY3Rlcj59XG4gICAqL1xuXG4gIGdldENoYXJhY3RlcnMoKSB7XG4gICAgY29uc3QgeyBtYXJrcyB9ID0gdGhpc1xuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBDaGFyYWN0ZXIuY3JlYXRlTGlzdCh0aGlzLnRleHRcbiAgICAgIC5zcGxpdCgnJylcbiAgICAgIC5tYXAoKGNoYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIENoYXJhY3Rlci5jcmVhdGUoe1xuICAgICAgICAgIHRleHQ6IGNoYXIsXG4gICAgICAgICAgbWFya3NcbiAgICAgICAgfSlcbiAgICAgIH0pKVxuXG4gICAgcmV0dXJuIGNoYXJhY3RlcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByYW5nZS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3Qgb2JqZWN0ID0ge1xuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgbWFya3M6IHRoaXMubWFya3MudG9BcnJheSgpLm1hcChtID0+IG0udG9KU09OKCkpLFxuICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBgdG9KU2AuXG4gICAqL1xuXG4gIHRvSlMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU09OKClcbiAgfVxuXG59XG5cbi8qKlxuICogQXR0YWNoIGEgcHNldWRvLXN5bWJvbCBmb3IgdHlwZSBjaGVja2luZy5cbiAqL1xuXG5EZWNvcmF0aW9uLnByb3RvdHlwZVtNT0RFTF9UWVBFUy5SQU5HRV0gPSB0cnVlXG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtEZWNvcmF0aW9ufVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IERlY29yYXRpb25cbiJdfQ==