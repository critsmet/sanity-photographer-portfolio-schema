'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slateBase64Serializer = require('slate-base64-serializer');

var _slateBase64Serializer2 = _interopRequireDefault(_slateBase64Serializer);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _getWindow = require('get-window');

var _getWindow2 = _interopRequireDefault(_getWindow);

var _keycode = require('keycode');

var _keycode2 = _interopRequireDefault(_keycode);

var _slate = require('slate');

var _transferTypes = require('../constants/transfer-types');

var _transferTypes2 = _interopRequireDefault(_transferTypes);

var _getHtmlFromNativePaste = require('../utils/get-html-from-native-paste');

var _getHtmlFromNativePaste2 = _interopRequireDefault(_getHtmlFromNativePaste);

var _getPoint = require('../utils/get-point');

var _getPoint2 = _interopRequireDefault(_getPoint);

var _getTransferData = require('../utils/get-transfer-data');

var _getTransferData2 = _interopRequireDefault(_getTransferData);

var _setTransferData = require('../utils/set-transfer-data');

var _setTransferData2 = _interopRequireDefault(_setTransferData);

var _environment = require('../constants/environment');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:plugins:before');

/**
 * The core "before" plugin, which is designed to execute before any other
 * user-land plugins in the stack.
 *
 * @param {Object} options
 * @return {Object}
 */

function BeforePlugin() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var composingCount = 0;
  var isComposing = false;
  var isCopying = false;
  var isDragging = false;
  var isInternalDrag = null;
  var isShifting = false;

  /**
   * On before input.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onBeforeInput(event, data, change, editor) {
    debug('onBeforeInput', { event: event, data: data });

    var state = change.state;
    var selection = state.selection;
    var anchorKey = selection.anchorKey,
        anchorOffset = selection.anchorOffset,
        focusKey = selection.focusKey,
        focusOffset = selection.focusOffset;

    // Prevent default because input should never be handled by the browser.

    event.preventDefault();

    // COMPAT: In iOS, when using predictive text suggestions, the native
    // selection will be changed to span the existing word, so that the word is
    // replaced. But the `select` fires after the `beforeInput` event, even
    // though the native selection is updated. So we need to manually check if
    // the selection has gotten out of sync, and adjust it if so. (03/18/2017)
    var window = (0, _getWindow2.default)(event.target);
    var native = window.getSelection();
    var a = (0, _getPoint2.default)(native.anchorNode, native.anchorOffset, state, editor);
    var f = (0, _getPoint2.default)(native.focusNode, native.focusOffset, state, editor);
    var hasMismatch = a && f && (anchorKey != a.key || anchorOffset != a.offset || focusKey != f.key || focusOffset != f.offset);

    // If there is a mismatch, correct it for future plugins.
    if (hasMismatch) {
      change.select({
        anchorKey: a.key,
        anchorOffset: a.offset,
        focusKey: f.key,
        focusOffset: f.offset
      });
    }
  }

  /**
   * On blur.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onBlur(event, data, change) {
    debug('onBlur', { event: event, data: data });

    // If we're currently copying, the blur is actually from the after plugin's
    // copy logic blurring the editor as it focus the cloned node, so ignore it.
    if (isCopying) {
      return true;
    }
  }

  /**
   * On change.
   *
   * @param {Change} change
   * @param {Editor} editor
   */

  function onChange(change, editor) {
    debug('onChange', { change: change });

    var state = change.state;

    var schema = editor.getSchema();
    var prevState = editor.getState();

    // PERF: Skip normalizing if the document hasn't changed, since the core
    // schema only normalizes changes to the document, not selection.
    if (prevState && state.document == prevState.document) return;

    // Normalize the state against the user-land schema before any other
    // plugins interact with it.
    change.normalize(schema);
  }

  /**
   * On composition end.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onCompositionEnd(event, data, change) {
    debug('onCompositionEnd', { event: event, data: data });

    var count = composingCount;

    // After a timeout, unset the composing flag if no new compositions have
    // been started in the meantime.
    setTimeout(function () {
      if (composingCount > count) return;
      isComposing = false;
    });
  }

  /**
   * On composition start.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onCompositionStart(event, data, change) {
    debug('onCompositionStart', { event: event, data: data });

    // Set the is composing state.
    isComposing = true;

    // Keep track of how many compositions have started, so that we can know
    // when the composing state ends.
    composingCount++;
  }

  /**
   * On copy.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onCopy(event, data, change) {
    debug('onCopy', { event: event, data: data });
    onCutOrCopy(event, data, change);
  }

  /**
   * On cut.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onCut(event, data, change) {
    debug('onCut', { event: event, data: data });
    onCutOrCopy(event, data, change);
  }

  /**
   * On cut or copy.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onCutOrCopy(event, data, change) {
    debug('onCutOrCopy', { event: event, data: data });

    var window = (0, _getWindow2.default)(event.target);

    // Set the copying state.
    isCopying = true;

    // Unset the copying state after the copy has taken.
    window.requestAnimationFrame(function () {
      isCopying = false;
    });

    // Add the current document fragment to the data.
    var state = change.state;

    data.type = 'fragment';
    data.fragment = state.fragment;
  }

  /**
   * On drag end.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDragEnd(event, data, change) {
    debug('onDragEnd', { event: event, data: data });

    // Reset the dragging state.
    isDragging = false;
    isInternalDrag = null;
  }

  /**
   * On drag over.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDragOver(event, data, change) {
    debug('onDragOver', { event: event, data: data });

    // If the dragging state hasn't already been set, then set it, and that
    // means that this is not an internal drag since it didn't start here.
    if (!isDragging) {
      isDragging = true;
      isInternalDrag = false;
    }
  }

  /**
   * On drag start.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDragStart(event, data, change) {
    debug('onDragStart', { event: event, data: data });

    // Set the dragging state.
    isDragging = true;
    isInternalDrag = true;

    // Add the data from the native event's `dataTransfer` object.
    var dataTransfer = event.nativeEvent.dataTransfer;

    var transfer = (0, _getTransferData2.default)(dataTransfer);
    Object.keys(transfer).forEach(function (key) {
      data[key] = transfer[key];
    });

    // If it's not a node being dragging, then it's a fragment, so set the
    // current fragment as data on the `dataTransfer` object.
    if (!data.type == 'node') {
      var state = change.state;

      var encoded = _slateBase64Serializer2.default.serializeNode(state.fragment);
      (0, _setTransferData2.default)(dataTransfer, _transferTypes2.default.fragment, encoded);
    }
  }

  /**
   * On drop.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDrop(event, data, change) {
    debug('onDrop', { event: event, data: data });

    // Add the native event's drop data to the `data` object.
    var nativeEvent = event.nativeEvent;
    var dataTransfer = nativeEvent.dataTransfer,
        x = nativeEvent.x,
        y = nativeEvent.y;

    var transfer = (0, _getTransferData2.default)(dataTransfer);
    Object.keys(transfer).forEach(function (key) {
      data[key] = transfer[key];
    });

    // Resolve the point where the drop occured.
    var window = (0, _getWindow2.default)(event.target);
    var _props = this.props,
        state = _props.state,
        editor = _props.editor;

    var range = void 0;

    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)
    if (window.document.caretRangeFromPoint) {
      range = window.document.caretRangeFromPoint(x, y);
    } else {
      range = window.document.createRange();
      range.setStart(nativeEvent.rangeParent, nativeEvent.rangeOffset);
    }

    var _range = range,
        startContainer = _range.startContainer,
        startOffset = _range.startOffset;

    var point = (0, _getPoint2.default)(startContainer, startOffset, state, editor);
    if (!point) return;

    var target = _slate.Selection.create({
      anchorKey: point.key,
      anchorOffset: point.offset,
      focusKey: point.key,
      focusOffset: point.offset,
      isFocused: true,
      isBackward: false
    });

    // Add drop-specific information to the data.
    data.target = target;

    // COMPAT: Edge throws "Permission denied" errors when
    // accessing `dropEffect` or `effectAllowed` (2017/7/12)
    try {
      data.effect = dataTransfer.dropEffect;
    } catch (err) {
      data.effect = null;
    }

    // Set an `isInternal` flag on the data if the drag is internal, for other
    // plugins to use when making decisions.
    if (data.type == 'fragment' || data.type == 'node') {
      data.isInternal = isInternalDrag;
    }
  }

  /**
   * On focus.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onFocus(event, data, change) {
    debug('onFocus', { event: event, data: data });

    // If we're currently copying, the focus is actually from the after plugin's
    // copy logic focusing the editor again after the cloned node, so ignore it.
    if (isCopying) {
      return true;
    }
  }

  /**
   * On input.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onInput(event, data, change, editor) {
    debug('onInput', { event: event, data: data });

    var state = change.state;

    // If we're currently composing, abort.

    if (isComposing) {
      return true;
    }

    // Or if the editor isn't focus, abort.
    if (state.isBlurred) {
      return true;
    }

    // Get the native selection point.
    var window = (0, _getWindow2.default)(event.target);
    var native = window.getSelection();
    var anchorNode = native.anchorNode,
        anchorOffset = native.anchorOffset;

    var point = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);

    // If we're not able to resolve a native point, abort.
    if (!point) {
      return true;
    }

    // Get the range in question.
    var key = point.key,
        start = point.start,
        end = point.end;
    var selection = state.selection;

    var target = selection.moveAnchorTo(key, start).moveFocusTo(key, end);

    // Add the `target` to the `data` for other plugins to use.
    data.target = target;
  }

  /**
   * On key down.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDown(event, data, change) {
    debug('onKeyDown', { event: event, data: data });

    var altKey = event.altKey,
        ctrlKey = event.ctrlKey,
        metaKey = event.metaKey,
        shiftKey = event.shiftKey,
        which = event.which;

    var key = (0, _keycode2.default)(which);

    // Keep track of an `isShifting` flag, because it's often used to trigger
    // "Paste and Match Style" commands, but isn't available on the event in a
    // normal paste event.
    if (key == 'shift') {
      isShifting = true;
    }

    // When composing, these characters commit the composition but also move the
    // selection before we're able to handle it, so prevent their default,
    // selection-moving behavior.
    if (isComposing && (key == 'left' || key == 'right' || key == 'up' || key == 'down')) {
      event.preventDefault();
      return true;
    }

    // Add helpful properties for handling hotkeys to the data object.
    data.code = which;
    data.key = key;
    data.isAlt = altKey;
    data.isCmd = _environment.IS_MAC ? metaKey && !altKey : false;
    data.isCtrl = ctrlKey && !altKey;
    data.isLine = _environment.IS_MAC ? metaKey : false;
    data.isMeta = metaKey;
    data.isMod = _environment.IS_MAC ? metaKey && !altKey : ctrlKey && !altKey;
    data.isModAlt = _environment.IS_MAC ? metaKey && altKey : ctrlKey && altKey;
    data.isShift = shiftKey;
    data.isWord = _environment.IS_MAC ? altKey : ctrlKey;

    // These key commands have native behavior in contenteditable elements which
    // will cause our state to be out of sync, so prevent them.
    if (key == 'enter' || key == 'backspace' || key == 'delete' || key == 'b' && data.isMod || key == 'i' && data.isMod || key == 'y' && data.isMod || key == 'z' && data.isMod) {
      event.preventDefault();
    }
  }

  /**
   * On key up.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyUp(event, data, change) {
    debug('onKeyUp', { event: event, data: data });

    var key = (0, _keycode2.default)(which);

    // If it's the shift key, reset the shift state.
    if (key == 'shift') {
      this.tmp.isShifting = false;
    }

    // Add helpful properties for handling hotkeys to the data object.
    var altKey = event.altKey,
        ctrlKey = event.ctrlKey,
        metaKey = event.metaKey,
        shiftKey = event.shiftKey,
        which = event.which;

    data.code = which;
    data.key = key;
    data.isAlt = altKey;
    data.isCmd = _environment.IS_MAC ? metaKey && !altKey : false;
    data.isCtrl = ctrlKey && !altKey;
    data.isLine = _environment.IS_MAC ? metaKey : false;
    data.isMeta = metaKey;
    data.isMod = _environment.IS_MAC ? metaKey && !altKey : ctrlKey && !altKey;
    data.isModAlt = _environment.IS_MAC ? metaKey && altKey : ctrlKey && altKey;
    data.isShift = shiftKey;
    data.isWord = _environment.IS_MAC ? altKey : ctrlKey;
  }

  /**
   * On paste.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onPaste(event, data, change, editor) {
    debug('onPaste', { event: event, data: data });

    // Attach the `isShift` flag, so that people can use it to trigger "Paste
    // and Match Style" logic.
    data.isShift = isShifting;

    // Add the data from the native event's `clipboardData` object.
    var transfer = (0, _getTransferData2.default)(event.clipboardData);
    Object.keys(transfer).forEach(function (key) {
      data[key] = transfer[key];
    });

    // COMPAT: In IE 11, only plain text can be retrieved from the event's
    // `clipboardData`. To get HTML, use the browser's native paste action which
    // can only be handled synchronously. (2017/06/23)
    if (_environment.IS_IE) {
      // Do not use `event.preventDefault()` as we need the native paste action.
      (0, _getHtmlFromNativePaste2.default)(event.target, function (html) {
        // If pasted HTML can be retreived, it is added to the `data` object,
        // setting the `type` to `html`.
        var stack = editor.getStack();
        var newData = _extends({}, data, { html: html, type: 'html' });
        var newEvent = event.persist();
        stack.onPaste(newEvent, newData);
      });

      // Return true to prevent the stack from continuing.
      return true;
    }

    // Prevent the default paste from occuring.
    event.preventDefault();
  }

  /**
   * On select.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onSelect(event, data, change, editor) {
    debug('onSelect', { event: event, data: data });

    // If we're currently copying or composing, ignore it because these result
    // in temporary selection updates.
    if (isCopying || isComposing) {
      return true;
    }

    // Try to resolve a new `selection` object for plugins to use...
    var window = (0, _getWindow2.default)(event.target);
    var native = window.getSelection();
    var state = change.state;
    var document = state.document,
        selection = state.selection;

    // If there are no ranges, the editor was blurred natively.

    if (!native.rangeCount) {
      selection = selection.set('isFocused', false);
    }

    // Otherwise, determine the selection from the native one.
    else {
        var anchorNode = native.anchorNode,
            anchorOffset = native.anchorOffset,
            focusNode = native.focusNode,
            focusOffset = native.focusOffset;

        var anchor = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);
        var focus = (0, _getPoint2.default)(focusNode, focusOffset, state, editor);

        // If we're not able to resolve the anchor or focus, abort.
        if (!anchor || !focus) {
          return true;
        }

        var properties = {
          anchorKey: anchor.key,
          anchorOffset: anchor.offset,
          focusKey: focus.key,
          focusOffset: focus.offset,
          isFocused: true,
          isBackward: null
        };

        var anchorText = document.getNode(anchor.key);
        var focusText = document.getNode(focus.key);
        var anchorInline = document.getClosestInline(anchor.key);
        var focusInline = document.getClosestInline(focus.key);
        var focusBlock = document.getClosestBlock(focus.key);
        var anchorBlock = document.getClosestBlock(anchor.key);

        // COMPAT: If the anchor point is at the start of a non-void, and the
        // focus point is inside a void node with an offset that isn't `0`, set
        // the focus offset to `0`. This is due to void nodes <span>'s being
        // positioned off screen, resulting in the offset always being greater
        // than `0`. Since we can't know what it really should be, and since an
        // offset of `0` is less destructive because it creates a hanging
        // selection, go with `0`. (2017/09/07)
        if (anchorBlock && !anchorBlock.isVoid && anchor.offset == 0 && focusBlock && focusBlock.isVoid && focus.offset != 0) {
          properties.focusOffset = 0;
        }

        // COMPAT: If the selection is at the end of a non-void inline node, and
        // there is a node after it, put it in the node after instead. This
        // standardizes the behavior, since it's indistinguishable to the user.
        if (anchorInline && !anchorInline.isVoid && anchor.offset == anchorText.text.length) {
          var block = document.getClosestBlock(anchor.key);
          var next = block.getNextText(anchor.key);
          if (next) {
            properties.anchorKey = next.key;
            properties.anchorOffset = 0;
          }
        }

        if (focusInline && !focusInline.isVoid && focus.offset == focusText.text.length) {
          var _block = document.getClosestBlock(focus.key);
          var _next = _block.getNextText(focus.key);
          if (_next) {
            properties.focusKey = _next.key;
            properties.focusOffset = 0;
          }
        }

        selection = selection.merge(properties).normalize(document);
      }

    // Add the `selection` to the `data` object for plugins to use.
    data.selection = selection;
  }

  /**
   * Return the core plugin.
   *
   * @type {Object}
   */

  return {
    onBlur: onBlur,
    onCompositionEnd: onCompositionEnd,
    onCompositionStart: onCompositionStart,
    onChange: onChange,
    onBeforeInput: onBeforeInput,
    onCopy: onCopy,
    onCut: onCut,
    onDragEnd: onDragEnd,
    onDragOver: onDragOver,
    onDragStart: onDragStart,
    onDrop: onDrop,
    onFocus: onFocus,
    onInput: onInput,
    onKeyDown: onKeyDown,
    onKeyUp: onKeyUp,
    onPaste: onPaste,
    onSelect: onSelect
  };
}

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = BeforePlugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wbHVnaW5zL2JlZm9yZS5qcyJdLCJuYW1lcyI6WyJkZWJ1ZyIsIkJlZm9yZVBsdWdpbiIsIm9wdGlvbnMiLCJjb21wb3NpbmdDb3VudCIsImlzQ29tcG9zaW5nIiwiaXNDb3B5aW5nIiwiaXNEcmFnZ2luZyIsImlzSW50ZXJuYWxEcmFnIiwiaXNTaGlmdGluZyIsIm9uQmVmb3JlSW5wdXQiLCJldmVudCIsImRhdGEiLCJjaGFuZ2UiLCJlZGl0b3IiLCJzdGF0ZSIsInNlbGVjdGlvbiIsImFuY2hvcktleSIsImFuY2hvck9mZnNldCIsImZvY3VzS2V5IiwiZm9jdXNPZmZzZXQiLCJwcmV2ZW50RGVmYXVsdCIsIndpbmRvdyIsInRhcmdldCIsIm5hdGl2ZSIsImdldFNlbGVjdGlvbiIsImEiLCJhbmNob3JOb2RlIiwiZiIsImZvY3VzTm9kZSIsImhhc01pc21hdGNoIiwia2V5Iiwib2Zmc2V0Iiwic2VsZWN0Iiwib25CbHVyIiwib25DaGFuZ2UiLCJzY2hlbWEiLCJnZXRTY2hlbWEiLCJwcmV2U3RhdGUiLCJnZXRTdGF0ZSIsImRvY3VtZW50Iiwibm9ybWFsaXplIiwib25Db21wb3NpdGlvbkVuZCIsImNvdW50Iiwic2V0VGltZW91dCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29weSIsIm9uQ3V0T3JDb3B5Iiwib25DdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0eXBlIiwiZnJhZ21lbnQiLCJvbkRyYWdFbmQiLCJvbkRyYWdPdmVyIiwib25EcmFnU3RhcnQiLCJkYXRhVHJhbnNmZXIiLCJuYXRpdmVFdmVudCIsInRyYW5zZmVyIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJlbmNvZGVkIiwic2VyaWFsaXplTm9kZSIsIm9uRHJvcCIsIngiLCJ5IiwicHJvcHMiLCJyYW5nZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0IiwicmFuZ2VQYXJlbnQiLCJyYW5nZU9mZnNldCIsInN0YXJ0Q29udGFpbmVyIiwic3RhcnRPZmZzZXQiLCJwb2ludCIsImNyZWF0ZSIsImlzRm9jdXNlZCIsImlzQmFja3dhcmQiLCJlZmZlY3QiLCJkcm9wRWZmZWN0IiwiZXJyIiwiaXNJbnRlcm5hbCIsIm9uRm9jdXMiLCJvbklucHV0IiwiaXNCbHVycmVkIiwic3RhcnQiLCJlbmQiLCJtb3ZlQW5jaG9yVG8iLCJtb3ZlRm9jdXNUbyIsIm9uS2V5RG93biIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ3aGljaCIsImNvZGUiLCJpc0FsdCIsImlzQ21kIiwiaXNDdHJsIiwiaXNMaW5lIiwiaXNNZXRhIiwiaXNNb2QiLCJpc01vZEFsdCIsImlzU2hpZnQiLCJpc1dvcmQiLCJvbktleVVwIiwidG1wIiwib25QYXN0ZSIsImNsaXBib2FyZERhdGEiLCJodG1sIiwic3RhY2siLCJnZXRTdGFjayIsIm5ld0RhdGEiLCJuZXdFdmVudCIsInBlcnNpc3QiLCJvblNlbGVjdCIsInJhbmdlQ291bnQiLCJzZXQiLCJhbmNob3IiLCJmb2N1cyIsInByb3BlcnRpZXMiLCJhbmNob3JUZXh0IiwiZ2V0Tm9kZSIsImZvY3VzVGV4dCIsImFuY2hvcklubGluZSIsImdldENsb3Nlc3RJbmxpbmUiLCJmb2N1c0lubGluZSIsImZvY3VzQmxvY2siLCJnZXRDbG9zZXN0QmxvY2siLCJhbmNob3JCbG9jayIsImlzVm9pZCIsInRleHQiLCJsZW5ndGgiLCJibG9jayIsIm5leHQiLCJnZXROZXh0VGV4dCIsIm1lcmdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLFFBQVEscUJBQU0sc0JBQU4sQ0FBZDs7QUFFQTs7Ozs7Ozs7QUFRQSxTQUFTQyxZQUFULEdBQW9DO0FBQUEsTUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUNsQyxN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Q1R5SCxLQURTLENBQ0hoQixVQURHLEVBRVRoRixTQUZTLENBRUNELFFBRkQsQ0FBWjtBQUdEOztBQUVEO0FBQ0E1QixTQUFLSSxTQUFMLEdBQWlCQSxTQUFqQjtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFPO0FBQ0xrQixrQkFESztBQUVMUSxzQ0FGSztBQUdMRywwQ0FISztBQUlMVixzQkFKSztBQUtMekIsZ0NBTEs7QUFNTG9DLGtCQU5LO0FBT0xFLGdCQVBLO0FBUUxJLHdCQVJLO0FBU0xDLDBCQVRLO0FBVUxDLDRCQVZLO0FBV0xTLGtCQVhLO0FBWUxvQixvQkFaSztBQWFMQyxvQkFiSztBQWNMTSx3QkFkSztBQWVMZ0Isb0JBZks7QUFnQkxFLG9CQWhCSztBQWlCTFE7QUFqQkssR0FBUDtBQW1CRDs7QUFFRDs7Ozs7O2tCQU1lbEgsWSIsImZpbGUiOiJiZWZvcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBCYXNlNjQgZnJvbSAnc2xhdGUtYmFzZTY0LXNlcmlhbGl6ZXInXG5pbXBvcnQgRGVidWcgZnJvbSAnZGVidWcnXG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJ2dldC13aW5kb3cnXG5pbXBvcnQga2V5Y29kZSBmcm9tICdrZXljb2RlJ1xuaW1wb3J0IHsgU2VsZWN0aW9uIH0gZnJvbSAnc2xhdGUnXG5cbmltcG9ydCBUUkFOU0ZFUl9UWVBFUyBmcm9tICcuLi9jb25zdGFudHMvdHJhbnNmZXItdHlwZXMnXG5pbXBvcnQgZ2V0SHRtbEZyb21OYXRpdmVQYXN0ZSBmcm9tICcuLi91dGlscy9nZXQtaHRtbC1mcm9tLW5hdGl2ZS1wYXN0ZSdcbmltcG9ydCBnZXRQb2ludCBmcm9tICcuLi91dGlscy9nZXQtcG9pbnQnXG5pbXBvcnQgZ2V0VHJhbnNmZXJEYXRhIGZyb20gJy4uL3V0aWxzL2dldC10cmFuc2Zlci1kYXRhJ1xuaW1wb3J0IHNldFRyYW5zZmVyRGF0YSBmcm9tICcuLi91dGlscy9zZXQtdHJhbnNmZXItZGF0YSdcbmltcG9ydCB7IElTX01BQywgSVNfSUUgfSBmcm9tICcuLi9jb25zdGFudHMvZW52aXJvbm1lbnQnXG5cbi8qKlxuICogRGVidWcuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoJ3NsYXRlOnBsdWdpbnM6YmVmb3JlJylcblxuLyoqXG4gKiBUaGUgY29yZSBcImJlZm9yZVwiIHBsdWdpbiwgd2hpY2ggaXMgZGVzaWduZWQgdG8gZXhlY3V0ZSBiZWZvcmUgYW55IG90aGVyXG4gKiB1c2VyLWxhbmQgcGx1Z2lucyBpbiB0aGUgc3RhY2suXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBCZWZvcmVQbHVnaW4ob3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjb21wb3NpbmdDb3VudCA9IDBcbiAgbGV0IGlzQ29tcG9zaW5nID0gZmFsc2VcbiAgbGV0IGlzQ29weWluZyA9IGZhbHNlXG4gIGxldCBpc0RyYWdnaW5nID0gZmFsc2VcbiAgbGV0IGlzSW50ZXJuYWxEcmFnID0gbnVsbFxuICBsZXQgaXNTaGlmdGluZyA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIE9uIGJlZm9yZSBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKiBAcGFyYW0ge0VkaXRvcn0gZWRpdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQmVmb3JlSW5wdXQoZXZlbnQsIGRhdGEsIGNoYW5nZSwgZWRpdG9yKSB7XG4gICAgZGVidWcoJ29uQmVmb3JlSW5wdXQnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBjb25zdCB7IGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0tleSwgZm9jdXNPZmZzZXQgfSA9IHNlbGVjdGlvblxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGJlY2F1c2UgaW5wdXQgc2hvdWxkIG5ldmVyIGJlIGhhbmRsZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgLy8gQ09NUEFUOiBJbiBpT1MsIHdoZW4gdXNpbmcgcHJlZGljdGl2ZSB0ZXh0IHN1Z2dlc3Rpb25zLCB0aGUgbmF0aXZlXG4gICAgLy8gc2VsZWN0aW9uIHdpbGwgYmUgY2hhbmdlZCB0byBzcGFuIHRoZSBleGlzdGluZyB3b3JkLCBzbyB0aGF0IHRoZSB3b3JkIGlzXG4gICAgLy8gcmVwbGFjZWQuIEJ1dCB0aGUgYHNlbGVjdGAgZmlyZXMgYWZ0ZXIgdGhlIGBiZWZvcmVJbnB1dGAgZXZlbnQsIGV2ZW5cbiAgICAvLyB0aG91Z2ggdGhlIG5hdGl2ZSBzZWxlY3Rpb24gaXMgdXBkYXRlZC4gU28gd2UgbmVlZCB0byBtYW51YWxseSBjaGVjayBpZlxuICAgIC8vIHRoZSBzZWxlY3Rpb24gaGFzIGdvdHRlbiBvdXQgb2Ygc3luYywgYW5kIGFkanVzdCBpdCBpZiBzby4gKDAzLzE4LzIwMTcpXG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGV2ZW50LnRhcmdldClcbiAgICBjb25zdCBuYXRpdmUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKClcbiAgICBjb25zdCBhID0gZ2V0UG9pbnQobmF0aXZlLmFuY2hvck5vZGUsIG5hdGl2ZS5hbmNob3JPZmZzZXQsIHN0YXRlLCBlZGl0b3IpXG4gICAgY29uc3QgZiA9IGdldFBvaW50KG5hdGl2ZS5mb2N1c05vZGUsIG5hdGl2ZS5mb2N1c09mZnNldCwgc3RhdGUsIGVkaXRvcilcbiAgICBjb25zdCBoYXNNaXNtYXRjaCA9IGEgJiYgZiAmJiAoXG4gICAgICBhbmNob3JLZXkgIT0gYS5rZXkgfHxcbiAgICAgIGFuY2hvck9mZnNldCAhPSBhLm9mZnNldCB8fFxuICAgICAgZm9jdXNLZXkgIT0gZi5rZXkgfHxcbiAgICAgIGZvY3VzT2Zmc2V0ICE9IGYub2Zmc2V0XG4gICAgKVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBtaXNtYXRjaCwgY29ycmVjdCBpdCBmb3IgZnV0dXJlIHBsdWdpbnMuXG4gICAgaWYgKGhhc01pc21hdGNoKSB7XG4gICAgICBjaGFuZ2Uuc2VsZWN0KHtcbiAgICAgICAgYW5jaG9yS2V5OiBhLmtleSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0OiBhLm9mZnNldCxcbiAgICAgICAgZm9jdXNLZXk6IGYua2V5LFxuICAgICAgICBmb2N1c09mZnNldDogZi5vZmZzZXRcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGJsdXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25CbHVyKGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25CbHVyJywgeyBldmVudCwgZGF0YSB9KVxuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGNvcHlpbmcsIHRoZSBibHVyIGlzIGFjdHVhbGx5IGZyb20gdGhlIGFmdGVyIHBsdWdpbidzXG4gICAgLy8gY29weSBsb2dpYyBibHVycmluZyB0aGUgZWRpdG9yIGFzIGl0IGZvY3VzIHRoZSBjbG9uZWQgbm9kZSwgc28gaWdub3JlIGl0LlxuICAgIGlmIChpc0NvcHlpbmcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKiBAcGFyYW0ge0VkaXRvcn0gZWRpdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKGNoYW5nZSwgZWRpdG9yKSB7XG4gICAgZGVidWcoJ29uQ2hhbmdlJywgeyBjaGFuZ2UgfSlcblxuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgIGNvbnN0IHNjaGVtYSA9IGVkaXRvci5nZXRTY2hlbWEoKVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGVkaXRvci5nZXRTdGF0ZSgpXG5cbiAgICAvLyBQRVJGOiBTa2lwIG5vcm1hbGl6aW5nIGlmIHRoZSBkb2N1bWVudCBoYXNuJ3QgY2hhbmdlZCwgc2luY2UgdGhlIGNvcmVcbiAgICAvLyBzY2hlbWEgb25seSBub3JtYWxpemVzIGNoYW5nZXMgdG8gdGhlIGRvY3VtZW50LCBub3Qgc2VsZWN0aW9uLlxuICAgIGlmIChwcmV2U3RhdGUgJiYgc3RhdGUuZG9jdW1lbnQgPT0gcHJldlN0YXRlLmRvY3VtZW50KSByZXR1cm5cblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgc3RhdGUgYWdhaW5zdCB0aGUgdXNlci1sYW5kIHNjaGVtYSBiZWZvcmUgYW55IG90aGVyXG4gICAgLy8gcGx1Z2lucyBpbnRlcmFjdCB3aXRoIGl0LlxuICAgIGNoYW5nZS5ub3JtYWxpemUoc2NoZW1hKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGNvbXBvc2l0aW9uIGVuZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25Db21wb3NpdGlvbkVuZCcsIHsgZXZlbnQsIGRhdGEgfSlcblxuICAgIGNvbnN0IGNvdW50ID0gY29tcG9zaW5nQ291bnRcblxuICAgIC8vIEFmdGVyIGEgdGltZW91dCwgdW5zZXQgdGhlIGNvbXBvc2luZyBmbGFnIGlmIG5vIG5ldyBjb21wb3NpdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gc3RhcnRlZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY29tcG9zaW5nQ291bnQgPiBjb3VudCkgcmV0dXJuXG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBjb21wb3NpdGlvbiBzdGFydC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkNvbXBvc2l0aW9uU3RhcnQnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICAvLyBTZXQgdGhlIGlzIGNvbXBvc2luZyBzdGF0ZS5cbiAgICBpc0NvbXBvc2luZyA9IHRydWVcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgaG93IG1hbnkgY29tcG9zaXRpb25zIGhhdmUgc3RhcnRlZCwgc28gdGhhdCB3ZSBjYW4ga25vd1xuICAgIC8vIHdoZW4gdGhlIGNvbXBvc2luZyBzdGF0ZSBlbmRzLlxuICAgIGNvbXBvc2luZ0NvdW50KytcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBjb3B5LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQ29weShldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uQ29weScsIHsgZXZlbnQsIGRhdGEgfSlcbiAgICBvbkN1dE9yQ29weShldmVudCwgZGF0YSwgY2hhbmdlKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGN1dC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkN1dChldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uQ3V0JywgeyBldmVudCwgZGF0YSB9KVxuICAgIG9uQ3V0T3JDb3B5KGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG4gIH1cblxuICAvKipcbiAgICogT24gY3V0IG9yIGNvcHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25DdXRPckNvcHkoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkN1dE9yQ29weScsIHsgZXZlbnQsIGRhdGEgfSlcblxuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpXG5cbiAgICAvLyBTZXQgdGhlIGNvcHlpbmcgc3RhdGUuXG4gICAgaXNDb3B5aW5nID0gdHJ1ZVxuXG4gICAgLy8gVW5zZXQgdGhlIGNvcHlpbmcgc3RhdGUgYWZ0ZXIgdGhlIGNvcHkgaGFzIHRha2VuLlxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaXNDb3B5aW5nID0gZmFsc2VcbiAgICB9KVxuXG4gICAgLy8gQWRkIHRoZSBjdXJyZW50IGRvY3VtZW50IGZyYWdtZW50IHRvIHRoZSBkYXRhLlxuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgIGRhdGEudHlwZSA9ICdmcmFnbWVudCdcbiAgICBkYXRhLmZyYWdtZW50ID0gc3RhdGUuZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkcmFnIGVuZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRyYWdFbmQoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkRyYWdFbmQnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICAvLyBSZXNldCB0aGUgZHJhZ2dpbmcgc3RhdGUuXG4gICAgaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgaXNJbnRlcm5hbERyYWcgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogT24gZHJhZyBvdmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uRHJhZ092ZXIoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkRyYWdPdmVyJywgeyBldmVudCwgZGF0YSB9KVxuXG4gICAgLy8gSWYgdGhlIGRyYWdnaW5nIHN0YXRlIGhhc24ndCBhbHJlYWR5IGJlZW4gc2V0LCB0aGVuIHNldCBpdCwgYW5kIHRoYXRcbiAgICAvLyBtZWFucyB0aGF0IHRoaXMgaXMgbm90IGFuIGludGVybmFsIGRyYWcgc2luY2UgaXQgZGlkbid0IHN0YXJ0IGhlcmUuXG4gICAgaWYgKCFpc0RyYWdnaW5nKSB7XG4gICAgICBpc0RyYWdnaW5nID0gdHJ1ZVxuICAgICAgaXNJbnRlcm5hbERyYWcgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkcmFnIHN0YXJ0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25EcmFnU3RhcnQnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICAvLyBTZXQgdGhlIGRyYWdnaW5nIHN0YXRlLlxuICAgIGlzRHJhZ2dpbmcgPSB0cnVlXG4gICAgaXNJbnRlcm5hbERyYWcgPSB0cnVlXG5cbiAgICAvLyBBZGQgdGhlIGRhdGEgZnJvbSB0aGUgbmF0aXZlIGV2ZW50J3MgYGRhdGFUcmFuc2ZlcmAgb2JqZWN0LlxuICAgIGNvbnN0IHsgZGF0YVRyYW5zZmVyIH0gPSBldmVudC5uYXRpdmVFdmVudFxuICAgIGNvbnN0IHRyYW5zZmVyID0gZ2V0VHJhbnNmZXJEYXRhKGRhdGFUcmFuc2ZlcilcbiAgICBPYmplY3Qua2V5cyh0cmFuc2ZlcikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBkYXRhW2tleV0gPSB0cmFuc2ZlcltrZXldXG4gICAgfSlcblxuICAgIC8vIElmIGl0J3Mgbm90IGEgbm9kZSBiZWluZyBkcmFnZ2luZywgdGhlbiBpdCdzIGEgZnJhZ21lbnQsIHNvIHNldCB0aGVcbiAgICAvLyBjdXJyZW50IGZyYWdtZW50IGFzIGRhdGEgb24gdGhlIGBkYXRhVHJhbnNmZXJgIG9iamVjdC5cbiAgICBpZiAoIWRhdGEudHlwZSA9PSAnbm9kZScpIHtcbiAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgICAgY29uc3QgZW5jb2RlZCA9IEJhc2U2NC5zZXJpYWxpemVOb2RlKHN0YXRlLmZyYWdtZW50KVxuICAgICAgc2V0VHJhbnNmZXJEYXRhKGRhdGFUcmFuc2ZlciwgVFJBTlNGRVJfVFlQRVMuZnJhZ21lbnQsIGVuY29kZWQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRyb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25Ecm9wKGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25Ecm9wJywgeyBldmVudCwgZGF0YSB9KVxuXG4gICAgLy8gQWRkIHRoZSBuYXRpdmUgZXZlbnQncyBkcm9wIGRhdGEgdG8gdGhlIGBkYXRhYCBvYmplY3QuXG4gICAgY29uc3QgeyBuYXRpdmVFdmVudCB9ID0gZXZlbnRcbiAgICBjb25zdCB7IGRhdGFUcmFuc2ZlciwgeCwgeSB9ID0gbmF0aXZlRXZlbnRcbiAgICBjb25zdCB0cmFuc2ZlciA9IGdldFRyYW5zZmVyRGF0YShkYXRhVHJhbnNmZXIpXG4gICAgT2JqZWN0LmtleXModHJhbnNmZXIpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgZGF0YVtrZXldID0gdHJhbnNmZXJba2V5XVxuICAgIH0pXG5cbiAgICAvLyBSZXNvbHZlIHRoZSBwb2ludCB3aGVyZSB0aGUgZHJvcCBvY2N1cmVkLlxuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpXG4gICAgY29uc3QgeyBzdGF0ZSwgZWRpdG9yIH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHJhbmdlXG5cbiAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGBjYXJldFJhbmdlRnJvbVBvaW50YCBkb2Vzbid0IGV4aXN0LiAoMjAxNi8wNy8yNSlcbiAgICBpZiAod2luZG93LmRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIHJhbmdlID0gd2luZG93LmRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICAgICAgcmFuZ2Uuc2V0U3RhcnQobmF0aXZlRXZlbnQucmFuZ2VQYXJlbnQsIG5hdGl2ZUV2ZW50LnJhbmdlT2Zmc2V0KVxuICAgIH1cblxuICAgIGNvbnN0IHsgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0IH0gPSByYW5nZVxuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBzdGF0ZSwgZWRpdG9yKVxuICAgIGlmICghcG9pbnQpIHJldHVyblxuXG4gICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0aW9uLmNyZWF0ZSh7XG4gICAgICBhbmNob3JLZXk6IHBvaW50LmtleSxcbiAgICAgIGFuY2hvck9mZnNldDogcG9pbnQub2Zmc2V0LFxuICAgICAgZm9jdXNLZXk6IHBvaW50LmtleSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBwb2ludC5vZmZzZXQsXG4gICAgICBpc0ZvY3VzZWQ6IHRydWUsXG4gICAgICBpc0JhY2t3YXJkOiBmYWxzZSxcbiAgICB9KVxuXG4gICAgLy8gQWRkIGRyb3Atc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gdGhlIGRhdGEuXG4gICAgZGF0YS50YXJnZXQgPSB0YXJnZXRcblxuICAgIC8vIENPTVBBVDogRWRnZSB0aHJvd3MgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyB3aGVuXG4gICAgLy8gYWNjZXNzaW5nIGBkcm9wRWZmZWN0YCBvciBgZWZmZWN0QWxsb3dlZGAgKDIwMTcvNy8xMilcbiAgICB0cnkge1xuICAgICAgZGF0YS5lZmZlY3QgPSBkYXRhVHJhbnNmZXIuZHJvcEVmZmVjdFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGF0YS5lZmZlY3QgPSBudWxsXG4gICAgfVxuXG4gICAgLy8gU2V0IGFuIGBpc0ludGVybmFsYCBmbGFnIG9uIHRoZSBkYXRhIGlmIHRoZSBkcmFnIGlzIGludGVybmFsLCBmb3Igb3RoZXJcbiAgICAvLyBwbHVnaW5zIHRvIHVzZSB3aGVuIG1ha2luZyBkZWNpc2lvbnMuXG4gICAgaWYgKGRhdGEudHlwZSA9PSAnZnJhZ21lbnQnIHx8IGRhdGEudHlwZSA9PSAnbm9kZScpIHtcbiAgICAgIGRhdGEuaXNJbnRlcm5hbCA9IGlzSW50ZXJuYWxEcmFnXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGZvY3VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uRm9jdXMoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkZvY3VzJywgeyBldmVudCwgZGF0YSB9KVxuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGNvcHlpbmcsIHRoZSBmb2N1cyBpcyBhY3R1YWxseSBmcm9tIHRoZSBhZnRlciBwbHVnaW4nc1xuICAgIC8vIGNvcHkgbG9naWMgZm9jdXNpbmcgdGhlIGVkaXRvciBhZ2FpbiBhZnRlciB0aGUgY2xvbmVkIG5vZGUsIHNvIGlnbm9yZSBpdC5cbiAgICBpZiAoaXNDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKiBAcGFyYW0ge0VkaXRvcn0gZWRpdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uSW5wdXQoZXZlbnQsIGRhdGEsIGNoYW5nZSwgZWRpdG9yKSB7XG4gICAgZGVidWcoJ29uSW5wdXQnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBjb21wb3NpbmcsIGFib3J0LlxuICAgIGlmIChpc0NvbXBvc2luZykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBPciBpZiB0aGUgZWRpdG9yIGlzbid0IGZvY3VzLCBhYm9ydC5cbiAgICBpZiAoc3RhdGUuaXNCbHVycmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbmF0aXZlIHNlbGVjdGlvbiBwb2ludC5cbiAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KVxuICAgIGNvbnN0IG5hdGl2ZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxuICAgIGNvbnN0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSBuYXRpdmVcbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgc3RhdGUsIGVkaXRvcilcblxuICAgIC8vIElmIHdlJ3JlIG5vdCBhYmxlIHRvIHJlc29sdmUgYSBuYXRpdmUgcG9pbnQsIGFib3J0LlxuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSByYW5nZSBpbiBxdWVzdGlvbi5cbiAgICBjb25zdCB7IGtleSwgc3RhcnQsIGVuZCB9ID0gcG9pbnRcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3Rpb24ubW92ZUFuY2hvclRvKGtleSwgc3RhcnQpLm1vdmVGb2N1c1RvKGtleSwgZW5kKVxuXG4gICAgLy8gQWRkIHRoZSBgdGFyZ2V0YCB0byB0aGUgYGRhdGFgIGZvciBvdGhlciBwbHVnaW5zIHRvIHVzZS5cbiAgICBkYXRhLnRhcmdldCA9IHRhcmdldFxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGtleSBkb3duLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uS2V5RG93bicsIHsgZXZlbnQsIGRhdGEgfSlcblxuICAgIGNvbnN0IHsgYWx0S2V5LCBjdHJsS2V5LCBtZXRhS2V5LCBzaGlmdEtleSwgd2hpY2ggfSA9IGV2ZW50XG4gICAgY29uc3Qga2V5ID0ga2V5Y29kZSh3aGljaClcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgYW4gYGlzU2hpZnRpbmdgIGZsYWcsIGJlY2F1c2UgaXQncyBvZnRlbiB1c2VkIHRvIHRyaWdnZXJcbiAgICAvLyBcIlBhc3RlIGFuZCBNYXRjaCBTdHlsZVwiIGNvbW1hbmRzLCBidXQgaXNuJ3QgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBpbiBhXG4gICAgLy8gbm9ybWFsIHBhc3RlIGV2ZW50LlxuICAgIGlmIChrZXkgPT0gJ3NoaWZ0Jykge1xuICAgICAgaXNTaGlmdGluZyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBXaGVuIGNvbXBvc2luZywgdGhlc2UgY2hhcmFjdGVycyBjb21taXQgdGhlIGNvbXBvc2l0aW9uIGJ1dCBhbHNvIG1vdmUgdGhlXG4gICAgLy8gc2VsZWN0aW9uIGJlZm9yZSB3ZSdyZSBhYmxlIHRvIGhhbmRsZSBpdCwgc28gcHJldmVudCB0aGVpciBkZWZhdWx0LFxuICAgIC8vIHNlbGVjdGlvbi1tb3ZpbmcgYmVoYXZpb3IuXG4gICAgaWYgKFxuICAgICAgKGlzQ29tcG9zaW5nKSAmJlxuICAgICAgKGtleSA9PSAnbGVmdCcgfHwga2V5ID09ICdyaWdodCcgfHwga2V5ID09ICd1cCcgfHwga2V5ID09ICdkb3duJylcbiAgICApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gQWRkIGhlbHBmdWwgcHJvcGVydGllcyBmb3IgaGFuZGxpbmcgaG90a2V5cyB0byB0aGUgZGF0YSBvYmplY3QuXG4gICAgZGF0YS5jb2RlID0gd2hpY2hcbiAgICBkYXRhLmtleSA9IGtleVxuICAgIGRhdGEuaXNBbHQgPSBhbHRLZXlcbiAgICBkYXRhLmlzQ21kID0gSVNfTUFDID8gbWV0YUtleSAmJiAhYWx0S2V5IDogZmFsc2VcbiAgICBkYXRhLmlzQ3RybCA9IGN0cmxLZXkgJiYgIWFsdEtleVxuICAgIGRhdGEuaXNMaW5lID0gSVNfTUFDID8gbWV0YUtleSA6IGZhbHNlXG4gICAgZGF0YS5pc01ldGEgPSBtZXRhS2V5XG4gICAgZGF0YS5pc01vZCA9IElTX01BQyA/IG1ldGFLZXkgJiYgIWFsdEtleSA6IGN0cmxLZXkgJiYgIWFsdEtleVxuICAgIGRhdGEuaXNNb2RBbHQgPSBJU19NQUMgPyBtZXRhS2V5ICYmIGFsdEtleSA6IGN0cmxLZXkgJiYgYWx0S2V5XG4gICAgZGF0YS5pc1NoaWZ0ID0gc2hpZnRLZXlcbiAgICBkYXRhLmlzV29yZCA9IElTX01BQyA/IGFsdEtleSA6IGN0cmxLZXlcblxuICAgIC8vIFRoZXNlIGtleSBjb21tYW5kcyBoYXZlIG5hdGl2ZSBiZWhhdmlvciBpbiBjb250ZW50ZWRpdGFibGUgZWxlbWVudHMgd2hpY2hcbiAgICAvLyB3aWxsIGNhdXNlIG91ciBzdGF0ZSB0byBiZSBvdXQgb2Ygc3luYywgc28gcHJldmVudCB0aGVtLlxuICAgIGlmIChcbiAgICAgIChrZXkgPT0gJ2VudGVyJykgfHxcbiAgICAgIChrZXkgPT0gJ2JhY2tzcGFjZScpIHx8XG4gICAgICAoa2V5ID09ICdkZWxldGUnKSB8fFxuICAgICAgKGtleSA9PSAnYicgJiYgZGF0YS5pc01vZCkgfHxcbiAgICAgIChrZXkgPT0gJ2knICYmIGRhdGEuaXNNb2QpIHx8XG4gICAgICAoa2V5ID09ICd5JyAmJiBkYXRhLmlzTW9kKSB8fFxuICAgICAgKGtleSA9PSAneicgJiYgZGF0YS5pc01vZClcbiAgICApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24ga2V5IHVwLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uS2V5VXAoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbktleVVwJywgeyBldmVudCwgZGF0YSB9KVxuXG4gICAgY29uc3Qga2V5ID0ga2V5Y29kZSh3aGljaClcblxuICAgIC8vIElmIGl0J3MgdGhlIHNoaWZ0IGtleSwgcmVzZXQgdGhlIHNoaWZ0IHN0YXRlLlxuICAgIGlmIChrZXkgPT0gJ3NoaWZ0Jykge1xuICAgICAgdGhpcy50bXAuaXNTaGlmdGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gQWRkIGhlbHBmdWwgcHJvcGVydGllcyBmb3IgaGFuZGxpbmcgaG90a2V5cyB0byB0aGUgZGF0YSBvYmplY3QuXG4gICAgY29uc3QgeyBhbHRLZXksIGN0cmxLZXksIG1ldGFLZXksIHNoaWZ0S2V5LCB3aGljaCB9ID0gZXZlbnRcbiAgICBkYXRhLmNvZGUgPSB3aGljaFxuICAgIGRhdGEua2V5ID0ga2V5XG4gICAgZGF0YS5pc0FsdCA9IGFsdEtleVxuICAgIGRhdGEuaXNDbWQgPSBJU19NQUMgPyBtZXRhS2V5ICYmICFhbHRLZXkgOiBmYWxzZVxuICAgIGRhdGEuaXNDdHJsID0gY3RybEtleSAmJiAhYWx0S2V5XG4gICAgZGF0YS5pc0xpbmUgPSBJU19NQUMgPyBtZXRhS2V5IDogZmFsc2VcbiAgICBkYXRhLmlzTWV0YSA9IG1ldGFLZXlcbiAgICBkYXRhLmlzTW9kID0gSVNfTUFDID8gbWV0YUtleSAmJiAhYWx0S2V5IDogY3RybEtleSAmJiAhYWx0S2V5XG4gICAgZGF0YS5pc01vZEFsdCA9IElTX01BQyA/IG1ldGFLZXkgJiYgYWx0S2V5IDogY3RybEtleSAmJiBhbHRLZXlcbiAgICBkYXRhLmlzU2hpZnQgPSBzaGlmdEtleVxuICAgIGRhdGEuaXNXb3JkID0gSVNfTUFDID8gYWx0S2V5IDogY3RybEtleVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIHBhc3RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gb25QYXN0ZShldmVudCwgZGF0YSwgY2hhbmdlLCBlZGl0b3IpIHtcbiAgICBkZWJ1Zygnb25QYXN0ZScsIHsgZXZlbnQsIGRhdGEgfSlcblxuICAgIC8vIEF0dGFjaCB0aGUgYGlzU2hpZnRgIGZsYWcsIHNvIHRoYXQgcGVvcGxlIGNhbiB1c2UgaXQgdG8gdHJpZ2dlciBcIlBhc3RlXG4gICAgLy8gYW5kIE1hdGNoIFN0eWxlXCIgbG9naWMuXG4gICAgZGF0YS5pc1NoaWZ0ID0gaXNTaGlmdGluZ1xuXG4gICAgLy8gQWRkIHRoZSBkYXRhIGZyb20gdGhlIG5hdGl2ZSBldmVudCdzIGBjbGlwYm9hcmREYXRhYCBvYmplY3QuXG4gICAgY29uc3QgdHJhbnNmZXIgPSBnZXRUcmFuc2ZlckRhdGEoZXZlbnQuY2xpcGJvYXJkRGF0YSlcbiAgICBPYmplY3Qua2V5cyh0cmFuc2ZlcikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBkYXRhW2tleV0gPSB0cmFuc2ZlcltrZXldXG4gICAgfSlcblxuICAgIC8vIENPTVBBVDogSW4gSUUgMTEsIG9ubHkgcGxhaW4gdGV4dCBjYW4gYmUgcmV0cmlldmVkIGZyb20gdGhlIGV2ZW50J3NcbiAgICAvLyBgY2xpcGJvYXJkRGF0YWAuIFRvIGdldCBIVE1MLCB1c2UgdGhlIGJyb3dzZXIncyBuYXRpdmUgcGFzdGUgYWN0aW9uIHdoaWNoXG4gICAgLy8gY2FuIG9ubHkgYmUgaGFuZGxlZCBzeW5jaHJvbm91c2x5LiAoMjAxNy8wNi8yMylcbiAgICBpZiAoSVNfSUUpIHtcbiAgICAgIC8vIERvIG5vdCB1c2UgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIGFzIHdlIG5lZWQgdGhlIG5hdGl2ZSBwYXN0ZSBhY3Rpb24uXG4gICAgICBnZXRIdG1sRnJvbU5hdGl2ZVBhc3RlKGV2ZW50LnRhcmdldCwgKGh0bWwpID0+IHtcbiAgICAgICAgLy8gSWYgcGFzdGVkIEhUTUwgY2FuIGJlIHJldHJlaXZlZCwgaXQgaXMgYWRkZWQgdG8gdGhlIGBkYXRhYCBvYmplY3QsXG4gICAgICAgIC8vIHNldHRpbmcgdGhlIGB0eXBlYCB0byBgaHRtbGAuXG4gICAgICAgIGNvbnN0IHN0YWNrID0gZWRpdG9yLmdldFN0YWNrKClcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IHsgLi4uZGF0YSwgaHRtbCwgdHlwZTogJ2h0bWwnIH1cbiAgICAgICAgY29uc3QgbmV3RXZlbnQgPSBldmVudC5wZXJzaXN0KClcbiAgICAgICAgc3RhY2sub25QYXN0ZShuZXdFdmVudCwgbmV3RGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIFJldHVybiB0cnVlIHRvIHByZXZlbnQgdGhlIHN0YWNrIGZyb20gY29udGludWluZy5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBwYXN0ZSBmcm9tIG9jY3VyaW5nLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBzZWxlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvclxuICAgKi9cblxuICBmdW5jdGlvbiBvblNlbGVjdChldmVudCwgZGF0YSwgY2hhbmdlLCBlZGl0b3IpIHtcbiAgICBkZWJ1Zygnb25TZWxlY3QnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgY29weWluZyBvciBjb21wb3NpbmcsIGlnbm9yZSBpdCBiZWNhdXNlIHRoZXNlIHJlc3VsdFxuICAgIC8vIGluIHRlbXBvcmFyeSBzZWxlY3Rpb24gdXBkYXRlcy5cbiAgICBpZiAoaXNDb3B5aW5nIHx8IGlzQ29tcG9zaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFRyeSB0byByZXNvbHZlIGEgbmV3IGBzZWxlY3Rpb25gIG9iamVjdCBmb3IgcGx1Z2lucyB0byB1c2UuLi5cbiAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KVxuICAgIGNvbnN0IG5hdGl2ZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgIGxldCB7IGRvY3VtZW50LCBzZWxlY3Rpb24gfSA9IHN0YXRlXG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcmFuZ2VzLCB0aGUgZWRpdG9yIHdhcyBibHVycmVkIG5hdGl2ZWx5LlxuICAgIGlmICghbmF0aXZlLnJhbmdlQ291bnQpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5zZXQoJ2lzRm9jdXNlZCcsIGZhbHNlKVxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgZGV0ZXJtaW5lIHRoZSBzZWxlY3Rpb24gZnJvbSB0aGUgbmF0aXZlIG9uZS5cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSBuYXRpdmVcbiAgICAgIGNvbnN0IGFuY2hvciA9IGdldFBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgc3RhdGUsIGVkaXRvcilcbiAgICAgIGNvbnN0IGZvY3VzID0gZ2V0UG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgc3RhdGUsIGVkaXRvcilcblxuICAgICAgLy8gSWYgd2UncmUgbm90IGFibGUgdG8gcmVzb2x2ZSB0aGUgYW5jaG9yIG9yIGZvY3VzLCBhYm9ydC5cbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBhbmNob3JLZXk6IGFuY2hvci5rZXksXG4gICAgICAgIGFuY2hvck9mZnNldDogYW5jaG9yLm9mZnNldCxcbiAgICAgICAgZm9jdXNLZXk6IGZvY3VzLmtleSxcbiAgICAgICAgZm9jdXNPZmZzZXQ6IGZvY3VzLm9mZnNldCxcbiAgICAgICAgaXNGb2N1c2VkOiB0cnVlLFxuICAgICAgICBpc0JhY2t3YXJkOiBudWxsLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBhbmNob3JUZXh0ID0gZG9jdW1lbnQuZ2V0Tm9kZShhbmNob3Iua2V5KVxuICAgICAgY29uc3QgZm9jdXNUZXh0ID0gZG9jdW1lbnQuZ2V0Tm9kZShmb2N1cy5rZXkpXG4gICAgICBjb25zdCBhbmNob3JJbmxpbmUgPSBkb2N1bWVudC5nZXRDbG9zZXN0SW5saW5lKGFuY2hvci5rZXkpXG4gICAgICBjb25zdCBmb2N1c0lubGluZSA9IGRvY3VtZW50LmdldENsb3Nlc3RJbmxpbmUoZm9jdXMua2V5KVxuICAgICAgY29uc3QgZm9jdXNCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhmb2N1cy5rZXkpXG4gICAgICBjb25zdCBhbmNob3JCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhhbmNob3Iua2V5KVxuXG4gICAgICAvLyBDT01QQVQ6IElmIHRoZSBhbmNob3IgcG9pbnQgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbm9uLXZvaWQsIGFuZCB0aGVcbiAgICAgIC8vIGZvY3VzIHBvaW50IGlzIGluc2lkZSBhIHZvaWQgbm9kZSB3aXRoIGFuIG9mZnNldCB0aGF0IGlzbid0IGAwYCwgc2V0XG4gICAgICAvLyB0aGUgZm9jdXMgb2Zmc2V0IHRvIGAwYC4gVGhpcyBpcyBkdWUgdG8gdm9pZCBub2RlcyA8c3Bhbj4ncyBiZWluZ1xuICAgICAgLy8gcG9zaXRpb25lZCBvZmYgc2NyZWVuLCByZXN1bHRpbmcgaW4gdGhlIG9mZnNldCBhbHdheXMgYmVpbmcgZ3JlYXRlclxuICAgICAgLy8gdGhhbiBgMGAuIFNpbmNlIHdlIGNhbid0IGtub3cgd2hhdCBpdCByZWFsbHkgc2hvdWxkIGJlLCBhbmQgc2luY2UgYW5cbiAgICAgIC8vIG9mZnNldCBvZiBgMGAgaXMgbGVzcyBkZXN0cnVjdGl2ZSBiZWNhdXNlIGl0IGNyZWF0ZXMgYSBoYW5naW5nXG4gICAgICAvLyBzZWxlY3Rpb24sIGdvIHdpdGggYDBgLiAoMjAxNy8wOS8wNylcbiAgICAgIGlmIChcbiAgICAgICAgYW5jaG9yQmxvY2sgJiZcbiAgICAgICAgIWFuY2hvckJsb2NrLmlzVm9pZCAmJlxuICAgICAgICBhbmNob3Iub2Zmc2V0ID09IDAgJiZcbiAgICAgICAgZm9jdXNCbG9jayAmJlxuICAgICAgICBmb2N1c0Jsb2NrLmlzVm9pZCAmJlxuICAgICAgICBmb2N1cy5vZmZzZXQgIT0gMFxuICAgICAgKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZm9jdXNPZmZzZXQgPSAwXG4gICAgICB9XG5cbiAgICAgIC8vIENPTVBBVDogSWYgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGEgbm9uLXZvaWQgaW5saW5lIG5vZGUsIGFuZFxuICAgICAgLy8gdGhlcmUgaXMgYSBub2RlIGFmdGVyIGl0LCBwdXQgaXQgaW4gdGhlIG5vZGUgYWZ0ZXIgaW5zdGVhZC4gVGhpc1xuICAgICAgLy8gc3RhbmRhcmRpemVzIHRoZSBiZWhhdmlvciwgc2luY2UgaXQncyBpbmRpc3Rpbmd1aXNoYWJsZSB0byB0aGUgdXNlci5cbiAgICAgIGlmIChcbiAgICAgICAgYW5jaG9ySW5saW5lICYmXG4gICAgICAgICFhbmNob3JJbmxpbmUuaXNWb2lkICYmXG4gICAgICAgIGFuY2hvci5vZmZzZXQgPT0gYW5jaG9yVGV4dC50ZXh0Lmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdEJsb2NrKGFuY2hvci5rZXkpXG4gICAgICAgIGNvbnN0IG5leHQgPSBibG9jay5nZXROZXh0VGV4dChhbmNob3Iua2V5KVxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIHByb3BlcnRpZXMuYW5jaG9yS2V5ID0gbmV4dC5rZXlcbiAgICAgICAgICBwcm9wZXJ0aWVzLmFuY2hvck9mZnNldCA9IDBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGZvY3VzSW5saW5lICYmXG4gICAgICAgICFmb2N1c0lubGluZS5pc1ZvaWQgJiZcbiAgICAgICAgZm9jdXMub2Zmc2V0ID09IGZvY3VzVGV4dC50ZXh0Lmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdEJsb2NrKGZvY3VzLmtleSlcbiAgICAgICAgY29uc3QgbmV4dCA9IGJsb2NrLmdldE5leHRUZXh0KGZvY3VzLmtleSlcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvY3VzS2V5ID0gbmV4dC5rZXlcbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvY3VzT2Zmc2V0ID0gMFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvblxuICAgICAgICAubWVyZ2UocHJvcGVydGllcylcbiAgICAgICAgLm5vcm1hbGl6ZShkb2N1bWVudClcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGBzZWxlY3Rpb25gIHRvIHRoZSBgZGF0YWAgb2JqZWN0IGZvciBwbHVnaW5zIHRvIHVzZS5cbiAgICBkYXRhLnNlbGVjdGlvbiA9IHNlbGVjdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29yZSBwbHVnaW4uXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHJldHVybiB7XG4gICAgb25CbHVyLFxuICAgIG9uQ29tcG9zaXRpb25FbmQsXG4gICAgb25Db21wb3NpdGlvblN0YXJ0LFxuICAgIG9uQ2hhbmdlLFxuICAgIG9uQmVmb3JlSW5wdXQsXG4gICAgb25Db3B5LFxuICAgIG9uQ3V0LFxuICAgIG9uRHJhZ0VuZCxcbiAgICBvbkRyYWdPdmVyLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJvcCxcbiAgICBvbkZvY3VzLFxuICAgIG9uSW5wdXQsXG4gICAgb25LZXlEb3duLFxuICAgIG9uS2V5VXAsXG4gICAgb25QYXN0ZSxcbiAgICBvblNlbGVjdCxcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IEJlZm9yZVBsdWdpblxuIl19