'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slateBase64Serializer = require('slate-base64-serializer');

var _slateBase64Serializer2 = _interopRequireDefault(_slateBase64Serializer);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _slatePlainSerializer = require('slate-plain-serializer');

var _slatePlainSerializer2 = _interopRequireDefault(_slatePlainSerializer);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _getWindow = require('get-window');

var _getWindow2 = _interopRequireDefault(_getWindow);

var _slate = require('slate');

var _content = require('../components/content');

var _content2 = _interopRequireDefault(_content);

var _placeholder = require('../components/placeholder');

var _placeholder2 = _interopRequireDefault(_placeholder);

var _getPoint = require('../utils/get-point');

var _getPoint2 = _interopRequireDefault(_getPoint);

var _findDomNode = require('../utils/find-dom-node');

var _findDomNode2 = _interopRequireDefault(_findDomNode);

var _environment = require('../constants/environment');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:plugins:after');

/**
 * The default plugin.
 *
 * @param {Object} options
 *   @property {Element} placeholder
 *   @property {String} placeholderClassName
 *   @property {Object} placeholderStyle
 * @return {Object}
 */

function Plugin() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var placeholder = options.placeholder,
      placeholderClassName = options.placeholderClassName,
      placeholderStyle = options.placeholderStyle;

  /**
   * On before input, correct any browser inconsistencies.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onBeforeInput(event, data, change, editor) {
    debug('onBeforeInput', { event: event, data: data });

    event.preventDefault();

    var state = change.state;
    var selection = state.selection;
    var anchorKey = selection.anchorKey,
        anchorOffset = selection.anchorOffset,
        focusKey = selection.focusKey,
        focusOffset = selection.focusOffset;

    // COMPAT: In iOS, when using predictive text suggestions, the native
    // selection will be changed to span the existing word, so that the word is
    // replaced. But the `select` fires after the `beforeInput` event, even
    // though the native selection is updated. So we need to manually check if
    // the selection has gotten out of sync, and adjust it if so. (03/18/2017)

    var window = (0, _getWindow2.default)(event.target);
    var native = window.getSelection();
    var a = (0, _getPoint2.default)(native.anchorNode, native.anchorOffset, state, editor);
    var f = (0, _getPoint2.default)(native.focusNode, native.focusOffset, state, editor);
    var hasMismatch = a && f && (anchorKey != a.key || anchorOffset != a.offset || focusKey != f.key || focusOffset != f.offset);

    if (hasMismatch) {
      change.select({
        anchorKey: a.key,
        anchorOffset: a.offset,
        focusKey: f.key,
        focusOffset: f.offset
      });
    }

    change.insertText(event.data);
  }

  /**
   * On blur.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onBlur(event, data, change) {
    debug('onBlur', { event: event, data: data });
    change.blur();
  }

  /**
   * On copy.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onCopy(event, data, change) {
    debug('onCopy', { event: event, data: data });
    onCutOrCopy(event, data, change);
  }

  /**
   * On cut.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onCut(event, data, change, editor) {
    debug('onCut', { event: event, data: data });
    onCutOrCopy(event, data, change);

    // Once the fake cut content has successfully been added to the clipboard,
    // delete the content in the current selection.
    var window = (0, _getWindow2.default)(event.target);
    window.requestAnimationFrame(function () {
      editor.change(function (t) {
        return t.delete();
      });
    });
  }

  /**
   * On cut or copy, create a fake selection so that we can add a Base 64
   * encoded copy of the fragment to the HTML, to decode on future pastes.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onCutOrCopy(event, data, change) {
    var window = (0, _getWindow2.default)(event.target);
    var native = window.getSelection();
    var state = change.state;
    var endBlock = state.endBlock,
        endInline = state.endInline;

    var isVoidBlock = endBlock && endBlock.isVoid;
    var isVoidInline = endInline && endInline.isVoid;
    var isVoid = isVoidBlock || isVoidInline;

    // If the selection is collapsed, and it isn't inside a void node, abort.
    if (native.isCollapsed && !isVoid) return;

    var fragment = data.fragment;

    var encoded = _slateBase64Serializer2.default.serializeNode(fragment);
    var range = native.getRangeAt(0);
    var contents = range.cloneContents();
    var attach = contents.childNodes[0];

    // If the end node is a void node, we need to move the end of the range from
    // the void node's spacer span, to the end of the void node's content.
    if (isVoid) {
      var _r = range.cloneRange();
      var node = (0, _findDomNode2.default)(isVoidBlock ? endBlock : endInline);
      _r.setEndAfter(node);
      contents = _r.cloneContents();
      attach = contents.childNodes[contents.childNodes.length - 1].firstChild;
    }

    // Remove any zero-width space spans from the cloned DOM so that they don't
    // show up elsewhere when pasted.
    var zws = [].slice.call(contents.querySelectorAll('[data-slate-zero-width]'));
    zws.forEach(function (zw) {
      return zw.parentNode.removeChild(zw);
    });

    // COMPAT: In Chrome and Safari, if the last element in the selection to
    // copy has `contenteditable="false"` the copy will fail, and nothing will
    // be put in the clipboard. So we remove them all. (2017/05/04)
    if (_environment.IS_CHROME || _environment.IS_SAFARI) {
      var els = [].slice.call(contents.querySelectorAll('[contenteditable="false"]'));
      els.forEach(function (el) {
        return el.removeAttribute('contenteditable');
      });
    }

    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up
    // in the HTML, and can be used for intra-Slate pasting. If it's a text
    // node, wrap it in a `<span>` so we have something to set an attribute on.
    if (attach.nodeType == 3) {
      var span = window.document.createElement('span');
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }

    attach.setAttribute('data-slate-fragment', encoded);

    // Add the phony content to the DOM, and select it, so it will be copied.
    var body = window.document.querySelector('body');
    var div = window.document.createElement('div');
    div.setAttribute('contenteditable', true);
    div.style.position = 'absolute';
    div.style.left = '-9999px';
    div.appendChild(contents);
    body.appendChild(div);

    // COMPAT: In Firefox, trying to use the terser `native.selectAllChildren`
    // throws an error, so we use the older `range` equivalent. (2016/06/21)
    var r = window.document.createRange();
    r.selectNodeContents(div);
    native.removeAllRanges();
    native.addRange(r);

    // Revert to the previous selection right after copying.
    window.requestAnimationFrame(function () {
      body.removeChild(div);
      native.removeAllRanges();
      native.addRange(range);
    });
  }

  /**
   * On drop.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDrop(event, data, change) {
    debug('onDrop', { event: event, data: data });

    switch (data.type) {
      case 'text':
      case 'html':
        return onDropText(event, data, change);
      case 'fragment':
        return onDropFragment(event, data, change);
      case 'node':
        return onDropNode(event, data, change);
    }
  }

  /**
   * On drop node, insert the node wherever it is dropped.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDropNode(event, data, change) {
    var state = change.state;
    var selection = state.selection;
    var node = data.node,
        target = data.target,
        isInternal = data.isInternal;

    // If the drag is internal and the target is after the selection, it
    // needs to account for the selection's content being deleted.

    if (isInternal && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {
      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset + selection.startOffset : 0 - selection.endOffset);
    }

    if (isInternal) {
      change.delete();
    }

    if (_slate.Block.isBlock(node)) {
      change.select(target).insertBlock(node).removeNodeByKey(node.key);
    }

    if (_slate.Inline.isInline(node)) {
      change.select(target).insertInline(node).removeNodeByKey(node.key);
    }
  }

  /**
   * On drop fragment.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDropFragment(event, data, change) {
    var state = change.state;
    var selection = state.selection;
    var fragment = data.fragment,
        target = data.target,
        isInternal = data.isInternal;

    // If the drag is internal and the target is after the selection, it
    // needs to account for the selection's content being deleted.

    if (isInternal && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {
      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset + selection.startOffset : 0 - selection.endOffset);
    }

    if (isInternal) {
      change.delete();
    }

    change.select(target).insertFragment(fragment);
  }

  /**
   * On drop text, split the blocks at new lines.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onDropText(event, data, change) {
    var state = change.state;
    var document = state.document;
    var text = data.text,
        target = data.target;
    var anchorKey = target.anchorKey;


    change.select(target);

    var hasVoidParent = document.hasVoidParent(anchorKey);

    // Insert text into nearest text node
    if (hasVoidParent) {
      var node = document.getNode(anchorKey);

      while (hasVoidParent) {
        node = document.getNextText(node.key);
        if (!node) break;
        hasVoidParent = document.hasVoidParent(node.key);
      }

      if (node) change.collapseToStartOf(node);
    }

    text.split('\n').forEach(function (line, i) {
      if (i > 0) change.splitBlock();
      change.insertText(line);
    });
  }

  /**
   * On input.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onInput(event, data, change, editor) {
    debug('onInput', { event: event, data: data });

    // Get the native selection point.
    var window = (0, _getWindow2.default)(event.target);
    var native = window.getSelection();
    var anchorNode = native.anchorNode,
        anchorOffset = native.anchorOffset;

    var point = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);
    var key = point.key,
        index = point.index;
    var target = data.target;
    var state = change.state;
    var document = state.document,
        selection = state.selection;

    var schema = editor.getSchema();
    var decorators = document.getDescendantDecorators(key, schema);
    var node = document.getDescendant(key);
    var block = document.getClosestBlock(node.key);
    var ranges = node.getRanges(decorators);
    var lastText = block.getLastText();

    // Get the text information.
    var textContent = anchorNode.textContent;

    var lastChar = textContent.charAt(textContent.length - 1);
    var isLastText = node == lastText;
    var isLastRange = index == ranges.size - 1;

    // If we're dealing with the last leaf, and the DOM text ends in a new line,
    // we will have added another new line in <Leaf>'s render method to account
    // for browsers collapsing a single trailing new lines, so remove it.
    if (isLastText && isLastRange && lastChar == '\n') {
      textContent = textContent.slice(0, -1);
    }

    // If the text is no different, abort.
    var range = ranges.get(index);
    var text = range.text,
        marks = range.marks;


    if (textContent == text) {
      return true;
    }

    // Determine what the selection should be after changing the text.
    var delta = textContent.length - text.length;
    var after = selection.collapseToEnd().move(delta);

    // Change the current state to have the text replaced.
    change.select(target).delete().insertText(textContent, marks).select(after);
  }

  /**
   * On key down.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDown(event, data, change) {
    debug('onKeyDown', { event: event, data: data });

    switch (data.key) {
      case 'enter':
        return onKeyDownEnter(event, data, change);
      case 'backspace':
        return onKeyDownBackspace(event, data, change);
      case 'delete':
        return onKeyDownDelete(event, data, change);
      case 'left':
        return onKeyDownLeft(event, data, change);
      case 'right':
        return onKeyDownRight(event, data, change);
      case 'up':
        return onKeyDownUp(event, data, change);
      case 'down':
        return onKeyDownDown(event, data, change);
      case 'd':
        return onKeyDownD(event, data, change);
      case 'h':
        return onKeyDownH(event, data, change);
      case 'k':
        return onKeyDownK(event, data, change);
      case 'y':
        return onKeyDownY(event, data, change);
      case 'z':
        return onKeyDownZ(event, data, change);
    }
  }

  /**
   * On `enter` key down, split the current block in half.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownEnter(event, data, change) {
    var state = change.state;
    var document = state.document,
        startKey = state.startKey;

    var hasVoidParent = document.hasVoidParent(startKey);

    // For void nodes, we don't want to split. Instead we just move to the start
    // of the next text node if one exists.
    if (hasVoidParent) {
      var text = document.getNextText(startKey);
      if (!text) return;
      change.collapseToStartOf(text);
      return;
    }

    change.splitBlock();
  }

  /**
   * On `backspace` key down, delete backwards.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownBackspace(event, data, change) {
    var boundary = 'Char';
    if (data.isWord) boundary = 'Word';
    if (data.isLine) boundary = 'Line';
    change['delete' + boundary + 'Backward']();
  }

  /**
   * On `delete` key down, delete forwards.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownDelete(event, data, change) {
    var boundary = 'Char';
    if (data.isWord) boundary = 'Word';
    if (data.isLine) boundary = 'Line';
    change['delete' + boundary + 'Forward']();
  }

  /**
   * On `left` key down, move backward.
   *
   * COMPAT: This is required to make navigating with the left arrow work when
   * a void node is selected.
   *
   * COMPAT: This is also required to solve for the case where an inline node is
   * surrounded by empty text nodes with zero-width spaces in them. Without this
   * the zero-width spaces will cause two arrow keys to jump to the next text.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownLeft(event, data, change) {
    var state = change.state;


    if (data.isCtrl) return;
    if (data.isAlt) return;
    if (state.isExpanded) return;

    var document = state.document,
        startKey = state.startKey,
        startText = state.startText;

    var hasVoidParent = document.hasVoidParent(startKey);

    // If the current text node is empty, or we're inside a void parent, we're
    // going to need to handle the selection behavior.
    if (startText.text == '' || hasVoidParent) {
      event.preventDefault();
      var previous = document.getPreviousText(startKey);

      // If there's no previous text node in the document, abort.
      if (!previous) return;

      // If the previous text is in the current block, and inside a non-void
      // inline node, move one character into the inline node.
      var startBlock = state.startBlock;

      var previousBlock = document.getClosestBlock(previous.key);
      var previousInline = document.getClosestInline(previous.key);

      if (previousBlock === startBlock && previousInline && !previousInline.isVoid) {
        var extendOrMove = data.isShift ? 'extend' : 'move';
        change.collapseToEndOf(previous)[extendOrMove](-1);
        return;
      }

      // Otherwise, move to the end of the previous node.
      change.collapseToEndOf(previous);
    }
  }

  /**
   * On `right` key down, move forward.
   *
   * COMPAT: This is required to make navigating with the right arrow work when
   * a void node is selected.
   *
   * COMPAT: This is also required to solve for the case where an inline node is
   * surrounded by empty text nodes with zero-width spaces in them. Without this
   * the zero-width spaces will cause two arrow keys to jump to the next text.
   *
   * COMPAT: In Chrome & Safari, selections that are at the zero offset of
   * an inline node will be automatically replaced to be at the last offset
   * of a previous inline node, which screws us up, so we never want to set the
   * selection to the very start of an inline node here. (2016/11/29)
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownRight(event, data, change) {
    var state = change.state;


    if (data.isCtrl) return;
    if (data.isAlt) return;
    if (state.isExpanded) return;

    var document = state.document,
        startKey = state.startKey,
        startText = state.startText;

    var hasVoidParent = document.hasVoidParent(startKey);

    // If the current text node is empty, or we're inside a void parent, we're
    // going to need to handle the selection behavior.
    if (startText.text == '' || hasVoidParent) {
      event.preventDefault();
      var next = document.getNextText(startKey);

      // If there's no next text node in the document, abort.
      if (!next) return;

      // If the next text is inside a void node, move to the end of it.
      if (document.hasVoidParent(next.key)) {
        change.collapseToEndOf(next);
        return;
      }

      // If the next text is in the current block, and inside an inline node,
      // move one character into the inline node.
      var startBlock = state.startBlock;

      var nextBlock = document.getClosestBlock(next.key);
      var nextInline = document.getClosestInline(next.key);

      if (nextBlock == startBlock && nextInline) {
        var extendOrMove = data.isShift ? 'extend' : 'move';
        change.collapseToStartOf(next)[extendOrMove](1);
        return;
      }

      // Otherwise, move to the start of the next text node.
      change.collapseToStartOf(next);
    }
  }

  /**
   * On `up` key down, for Macs, move the selection to start of the block.
   *
   * COMPAT: Certain browsers don't handle the selection updates properly. In
   * Chrome, option-shift-up doesn't properly extend the selection. And in
   * Firefox, option-up doesn't properly move the selection.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownUp(event, data, change) {
    if (!_environment.IS_MAC || data.isCtrl || !data.isAlt) return;

    var state = change.state;
    var selection = state.selection,
        document = state.document,
        focusKey = state.focusKey,
        focusBlock = state.focusBlock;

    var transform = data.isShift ? 'extendToStartOf' : 'collapseToStartOf';
    var block = selection.hasFocusAtStartOf(focusBlock) ? document.getPreviousBlock(focusKey) : focusBlock;

    if (!block) return;
    var text = block.getFirstText();

    event.preventDefault();
    change[transform](text);
  }

  /**
   * On `down` key down, for Macs, move the selection to end of the block.
   *
   * COMPAT: Certain browsers don't handle the selection updates properly. In
   * Chrome, option-shift-down doesn't properly extend the selection. And in
   * Firefox, option-down doesn't properly move the selection.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownDown(event, data, change) {
    if (!_environment.IS_MAC || data.isCtrl || !data.isAlt) return;

    var state = change.state;
    var selection = state.selection,
        document = state.document,
        focusKey = state.focusKey,
        focusBlock = state.focusBlock;

    var transform = data.isShift ? 'extendToEndOf' : 'collapseToEndOf';
    var block = selection.hasFocusAtEndOf(focusBlock) ? document.getNextBlock(focusKey) : focusBlock;

    if (!block) return;
    var text = block.getLastText();

    event.preventDefault();
    change[transform](text);
  }

  /**
   * On `d` key down, for Macs, delete one character forward.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownD(event, data, change) {
    if (!_environment.IS_MAC || !data.isCtrl) return;
    event.preventDefault();
    change.deleteCharForward();
  }

  /**
   * On `h` key down, for Macs, delete until the end of the line.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownH(event, data, change) {
    if (!_environment.IS_MAC || !data.isCtrl) return;
    event.preventDefault();
    change.deleteCharBackward();
  }

  /**
   * On `k` key down, for Macs, delete until the end of the line.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownK(event, data, change) {
    if (!_environment.IS_MAC || !data.isCtrl) return;
    event.preventDefault();
    change.deleteLineForward();
  }

  /**
   * On `y` key down, redo.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownY(event, data, change) {
    if (!data.isMod) return;
    change.redo();
  }

  /**
   * On `z` key down, undo or redo.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownZ(event, data, change) {
    if (!data.isMod) return;
    change[data.isShift ? 'redo' : 'undo']();
  }

  /**
   * On paste.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onPaste(event, data, change) {
    debug('onPaste', { event: event, data: data });

    switch (data.type) {
      case 'fragment':
        return onPasteFragment(event, data, change);
      case 'text':
      case 'html':
        return onPasteText(event, data, change);
    }
  }

  /**
   * On paste fragment.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onPasteFragment(event, data, change) {
    change.insertFragment(data.fragment);
  }

  /**
   * On paste text, split blocks at new lines.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onPasteText(event, data, change) {
    var state = change.state;
    var document = state.document,
        selection = state.selection,
        startBlock = state.startBlock;

    if (startBlock.isVoid) return;

    var text = data.text;

    var defaultBlock = startBlock;
    var defaultMarks = document.getMarksAtRange(selection.collapseToStart());
    var fragment = _slatePlainSerializer2.default.deserialize(text, { defaultBlock: defaultBlock, defaultMarks: defaultMarks }).document;
    change.insertFragment(fragment);
  }

  /**
   * On select.
   *
   * @param {Event} event
   * @param {Object} data
   * @param {Change} change
   */

  function onSelect(event, data, change) {
    debug('onSelect', { event: event, data: data });
    change.select(data.selection);
  }

  /**
   * Render.
   *
   * @param {Object} props
   * @param {State} state
   * @param {Editor} editor
   * @return {Object}
   */

  function render(props, state, editor) {
    return _react2.default.createElement(_content2.default, {
      autoCorrect: props.autoCorrect,
      autoFocus: props.autoFocus,
      className: props.className,
      children: props.children,
      editor: editor,
      onBeforeInput: editor.onBeforeInput,
      onBlur: editor.onBlur,
      onCompositionEnd: editor.onCompositionEnd,
      onCompositionStart: editor.onCompositionStart,
      onCopy: editor.onCopy,
      onCut: editor.onCut,
      onDragEnd: editor.onDragEnd,
      onDragOver: editor.onDragOver,
      onDragStart: editor.onDragStart,
      onDrop: editor.onDrop,
      onFocus: editor.onFocus,
      onInput: editor.onInput,
      onKeyDown: editor.onKeyDown,
      onKeyUp: editor.onKeyUp,
      onPaste: editor.onPaste,
      onSelect: editor.onSelect,
      readOnly: props.readOnly,
      role: props.role,
      schema: editor.getSchema(),
      spellCheck: props.spellCheck,
      state: state,
      style: props.style,
      tabIndex: props.tabIndex,
      tagName: props.tagName
    });
  }

  /**
   * A default schema rule to render block nodes.
   *
   * @type {Object}
   */

  var BLOCK_RENDER_RULE = {
    match: function match(node) {
      return node.kind == 'block';
    },
    render: function render(props) {
      return _react2.default.createElement(
        'div',
        _extends({}, props.attributes, { style: { position: 'relative' } }),
        props.children,
        placeholder ? _react2.default.createElement(
          _placeholder2.default,
          {
            className: placeholderClassName,
            node: props.node,
            parent: props.state.document,
            state: props.state,
            style: placeholderStyle
          },
          placeholder
        ) : null
      );
    }
  };

  /**
   * A default schema rule to render inline nodes.
   *
   * @type {Object}
   */

  var INLINE_RENDER_RULE = {
    match: function match(node) {
      return node.kind == 'inline';
    },
    render: function render(props) {
      return _react2.default.createElement(
        'span',
        _extends({}, props.attributes, { style: { position: 'relative' } }),
        props.children
      );
    }
  };

  /**
   * Add default rendering rules to the schema.
   *
   * @type {Object}
   */

  var schema = {
    rules: [BLOCK_RENDER_RULE, INLINE_RENDER_RULE]
  };

  /**
   * Return the core plugin.
   *
   * @type {Object}
   */

  return {
    onBeforeInput: onBeforeInput,
    onBlur: onBlur,
    onCopy: onCopy,
    onCut: onCut,
    onDrop: onDrop,
    onInput: onInput,
    onKeyDown: onKeyDown,
    onPaste: onPaste,
    onSelect: onSelect,
    render: render,
    schema: schema
  };
}

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Plugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wbHVnaW5zL2FmdGVyLmpzIl0sIm5hbWVzIjpbImRlYnVnIiwiUGx1Z2luIiwib3B0aW9ucyIsInBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJDbGFzc05hbWUiLCJwbGFjZWhvbGRlclN0eWxlIiwib25CZWZvcmVJbnB1dCIsImV2ZW50IiwiZGF0YSIsImNoYW5nZSIsImVkaXRvciIsInByZXZlbnREZWZhdWx0Iiwic3RhdGUiLCJzZWxlY3Rpb24iLCJhbmNob3JLZXkiLCJhbmNob3JPZmZzZXQiLCJmb2N1c0tleSIsImZvY3VzT2Zmc2V0Iiwid2luZG93IiwidGFyZ2V0IiwibmF0aXZlIiwiZ2V0U2VsZWN0aW9uIiwiYSIsImFuY2hvck5vZGUiLCJmIiwiZm9jdXNOb2RlIiwiaGFzTWlzbWF0Y2giLCJrZXkiLCJvZmZzZXQiLCJzZWxlY3QiLCJpbnNlcnRUZXh0Iiwib25CbHVyIiwiYmx1ciIsIm9uQ29weSIsIm9uQ3V0T3JDb3B5Iiwib25DdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0IiwiZGVsZXRlIiwiZW5kQmxvY2siLCJlbmRJbmxpbmUiLCJpc1ZvaWRCbG9jayIsImlzVm9pZCIsImlzVm9pZElubGluZSIsImlzQ29sbGFwc2VkIiwiZnJhZ21lbnQiLCJlbmNvZGVkIiwic2VyaWFsaXplTm9kZSIsInJhbmdlIiwiZ2V0UmFuZ2VBdCIsImNvbnRlbnRzIiwiY2xvbmVDb250ZW50cyIsImF0dGFjaCIsImNoaWxkTm9kZXMiLCJyIiwiY2xvbmVSYW5nZSIsIm5vZGUiLCJzZXRFbmRBZnRlciIsImxlbmd0aCIsImZpcnN0Q2hpbGQiLCJ6d3MiLCJzbGljZSIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsInp3IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZWxzIiwiZWwiLCJyZW1vdmVBdHRyaWJ1dGUiLCJub2RlVHlwZSIsInNwYW4iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJxdWVyeVNlbGVjdG9yIiwiZGl2Iiwic3R5bGUiLCJwb3NpdGlvbiIsImxlZnQiLCJjcmVhdGVSYW5nZSIsInNlbGVjdE5vZGVDb250ZW50cyIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwib25Ecm9wIiwidHlwZSIsIm9uRHJvcFRleHQiLCJvbkRyb3BGcmFnbWVudCIsIm9uRHJvcE5vZGUiLCJpc0ludGVybmFsIiwiZW5kS2V5IiwiZW5kT2Zmc2V0IiwibW92ZSIsInN0YXJ0S2V5Iiwic3RhcnRPZmZzZXQiLCJpc0Jsb2NrIiwiaW5zZXJ0QmxvY2siLCJyZW1vdmVOb2RlQnlLZXkiLCJpc0lubGluZSIsImluc2VydElubGluZSIsImluc2VydEZyYWdtZW50IiwidGV4dCIsImhhc1ZvaWRQYXJlbnQiLCJnZXROb2RlIiwiZ2V0TmV4dFRleHQiLCJjb2xsYXBzZVRvU3RhcnRPZiIsInNwbGl0IiwibGluZSIsImkiLCJzcGxpdEJsb2NrIiwib25JbnB1dCIsInBvaW50IiwiaW5kZXgiLCJzY2hlbWEiLCJnZXRTY2hlbWEiLCJkZWNvcmF0b3JzIiwiZ2V0RGVzY2VuZGFudERlY29yYXRvcnMiLCJnZXREZXNjZW5kYW50IiwiYmxvY2siLCJnZXRDbG9zZXN0QmxvY2siLCJyYW5nZXMiLCJnZXRSYW5nZXMiLCJsYXN0VGV4dCIsImdldExhc3RUZXh0IiwidGV4dENvbnRlbnQiLCJsYXN0Q2hhciIsImNoYXJBdCIsImlzTGFzdFRleHQiLCJpc0xhc3RSYW5nZSIsInNpemUiLCJnZXQiLCJtYXJrcyIsImRlbHRhIiwiYWZ0ZXIiLCJjb2xsYXBzZVRvRW5kIiwib25LZXlEb3duIiwib25LZXlEb3duRW50ZXIiLCJvbktleURvd25CYWNrc3BhY2UiLCJvbktleURvd25EZWxldGUiLCJvbktleURvd25MZWZ0Iiwib25LZXlEb3duUmlnaHQiLCJvbktleURvd25VcCIsIm9uS2V5RG93bkRvd24iLCJvbktleURvd25EIiwib25LZXlEb3duSCIsIm9uS2V5RG93bksiLCJvbktleURvd25ZIiwib25LZXlEb3duWiIsImJvdW5kYXJ5IiwiaXNXb3JkIiwiaXNMaW5lIiwiaXNDdHJsIiwiaXNBbHQiLCJpc0V4cGFuZGVkIiwic3RhcnRUZXh0IiwicHJldmlvdXMiLCJnZXRQcmV2aW91c1RleHQiLCJzdGFydEJsb2NrIiwicHJldmlvdXNCbG9jayIsInByZXZpb3VzSW5saW5lIiwiZ2V0Q2xvc2VzdElubGluZSIsImV4dGVuZE9yTW92ZSIsImlzU2hpZnQiLCJjb2xsYXBzZVRvRW5kT2YiLCJuZXh0IiwibmV4dEJsb2NrIiwibmV4dElubGluZSIsImZvY3VzQmxvY2siLCJ0cmFuc2Zvcm0iLCJoYXNGb2N1c0F0U3RhcnRPZiIsImdldFByZXZpb3VzQmxvY2siLCJnZXRGaXJzdFRleHQiLCJoYXNGb2N1c0F0RW5kT2YiLCJnZXROZXh0QmxvY2siLCJkZWxldGVDaGFyRm9yd2FyZCIsImRlbGV0ZUNoYXJCYWNrd2FyZCIsImRlbGV0ZUxpbmVGb3J3YXJkIiwiaXNNb2QiLCJyZWRvIiwib25QYXN0ZSIsIm9uUGFzdGVGcmFnbWVudCIsIm9uUGFzdGVUZXh0IiwiZGVmYXVsdEJsb2NrIiwiZGVmYXVsdE1hcmtzIiwiZ2V0TWFya3NBdFJhbmdlIiwiY29sbGFwc2VUb1N0YXJ0IiwiZGVzZXJpYWxpemUiLCJvblNlbGVjdCIsInJlbmRlciIsInByb3BzIiwiYXV0b0NvcnJlY3QiLCJhdXRvRm9jdXMiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkRyYWdFbmQiLCJvbkRyYWdPdmVyIiwib25EcmFnU3RhcnQiLCJvbkZvY3VzIiwib25LZXlVcCIsInJlYWRPbmx5Iiwicm9sZSIsInNwZWxsQ2hlY2siLCJ0YWJJbmRleCIsInRhZ05hbWUiLCJCTE9DS19SRU5ERVJfUlVMRSIsIm1hdGNoIiwia2luZCIsImF0dHJpYnV0ZXMiLCJJTkxJTkVfUkVOREVSX1JVTEUiLCJydWxlcyJdLCJtYXBwaW5ncyI6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MUosSUFBRCxFQUFVO0FBQ2YsYUFBT0EsS0FBSzJKLElBQUwsSUFBYSxRQUFwQjtBQUNELEtBSHdCO0FBSXpCcEIsWUFBUSxnQkFBQ0MsS0FBRCxFQUFXO0FBQ2pCLGFBQ0U7QUFBQTtBQUFBLHFCQUFVQSxNQUFNb0IsVUFBaEIsSUFBNEIsT0FBTyxFQUFFbkksVUFBVSxVQUFaLEVBQW5DO0FBQ0crRyxjQUFNSTtBQURULE9BREY7QUFLRDtBQVZ3QixHQUEzQjs7QUFhQTs7Ozs7O0FBTUEsTUFBTWhGLFNBQVM7QUFDYmtHLFdBQU8sQ0FDTEwsaUJBREssRUFFTEksa0JBRks7QUFETSxHQUFmOztBQU9BOzs7Ozs7QUFNQSxTQUFPO0FBQ0wvTSxnQ0FESztBQUVMeUIsa0JBRks7QUFHTEUsa0JBSEs7QUFJTEUsZ0JBSks7QUFLTG9ELGtCQUxLO0FBTUwwQixvQkFOSztBQU9MeUIsd0JBUEs7QUFRTDRDLG9CQVJLO0FBU0xRLHNCQVRLO0FBVUxDLGtCQVZLO0FBV0wzRTtBQVhLLEdBQVA7QUFhRDs7QUFFRDs7Ozs7O2tCQU1lbkgsTSIsImZpbGUiOiJhZnRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IEJhc2U2NCBmcm9tICdzbGF0ZS1iYXNlNjQtc2VyaWFsaXplcidcbmltcG9ydCBEZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCBQbGFpbiBmcm9tICdzbGF0ZS1wbGFpbi1zZXJpYWxpemVyJ1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICdnZXQtd2luZG93J1xuaW1wb3J0IHsgQmxvY2ssIElubGluZSB9IGZyb20gJ3NsYXRlJ1xuXG5pbXBvcnQgQ29udGVudCBmcm9tICcuLi9jb21wb25lbnRzL2NvbnRlbnQnXG5pbXBvcnQgUGxhY2Vob2xkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9wbGFjZWhvbGRlcidcbmltcG9ydCBnZXRQb2ludCBmcm9tICcuLi91dGlscy9nZXQtcG9pbnQnXG5pbXBvcnQgZmluZERPTU5vZGUgZnJvbSAnLi4vdXRpbHMvZmluZC1kb20tbm9kZSdcbmltcG9ydCB7IElTX0NIUk9NRSwgSVNfTUFDLCBJU19TQUZBUkkgfSBmcm9tICcuLi9jb25zdGFudHMvZW52aXJvbm1lbnQnXG5cbi8qKlxuICogRGVidWcuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoJ3NsYXRlOnBsdWdpbnM6YWZ0ZXInKVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0VsZW1lbnR9IHBsYWNlaG9sZGVyXG4gKiAgIEBwcm9wZXJ0eSB7U3RyaW5nfSBwbGFjZWhvbGRlckNsYXNzTmFtZVxuICogICBAcHJvcGVydHkge09iamVjdH0gcGxhY2Vob2xkZXJTdHlsZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIFBsdWdpbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVyQ2xhc3NOYW1lLFxuICAgIHBsYWNlaG9sZGVyU3R5bGUsXG4gIH0gPSBvcHRpb25zXG5cbiAgLyoqXG4gICAqIE9uIGJlZm9yZSBpbnB1dCwgY29ycmVjdCBhbnkgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvclxuICAgKi9cblxuICBmdW5jdGlvbiBvbkJlZm9yZUlucHV0KGV2ZW50LCBkYXRhLCBjaGFuZ2UsIGVkaXRvcikge1xuICAgIGRlYnVnKCdvbkJlZm9yZUlucHV0JywgeyBldmVudCwgZGF0YSB9KVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgY29uc3QgeyBhbmNob3JLZXksIGFuY2hvck9mZnNldCwgZm9jdXNLZXksIGZvY3VzT2Zmc2V0IH0gPSBzZWxlY3Rpb25cblxuICAgIC8vIENPTVBBVDogSW4gaU9TLCB3aGVuIHVzaW5nIHByZWRpY3RpdmUgdGV4dCBzdWdnZXN0aW9ucywgdGhlIG5hdGl2ZVxuICAgIC8vIHNlbGVjdGlvbiB3aWxsIGJlIGNoYW5nZWQgdG8gc3BhbiB0aGUgZXhpc3Rpbmcgd29yZCwgc28gdGhhdCB0aGUgd29yZCBpc1xuICAgIC8vIHJlcGxhY2VkLiBCdXQgdGhlIGBzZWxlY3RgIGZpcmVzIGFmdGVyIHRoZSBgYmVmb3JlSW5wdXRgIGV2ZW50LCBldmVuXG4gICAgLy8gdGhvdWdoIHRoZSBuYXRpdmUgc2VsZWN0aW9uIGlzIHVwZGF0ZWQuIFNvIHdlIG5lZWQgdG8gbWFudWFsbHkgY2hlY2sgaWZcbiAgICAvLyB0aGUgc2VsZWN0aW9uIGhhcyBnb3R0ZW4gb3V0IG9mIHN5bmMsIGFuZCBhZGp1c3QgaXQgaWYgc28uICgwMy8xOC8yMDE3KVxuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpXG4gICAgY29uc3QgbmF0aXZlID0gd2luZG93LmdldFNlbGVjdGlvbigpXG4gICAgY29uc3QgYSA9IGdldFBvaW50KG5hdGl2ZS5hbmNob3JOb2RlLCBuYXRpdmUuYW5jaG9yT2Zmc2V0LCBzdGF0ZSwgZWRpdG9yKVxuICAgIGNvbnN0IGYgPSBnZXRQb2ludChuYXRpdmUuZm9jdXNOb2RlLCBuYXRpdmUuZm9jdXNPZmZzZXQsIHN0YXRlLCBlZGl0b3IpXG4gICAgY29uc3QgaGFzTWlzbWF0Y2ggPSBhICYmIGYgJiYgKFxuICAgICAgYW5jaG9yS2V5ICE9IGEua2V5IHx8XG4gICAgICBhbmNob3JPZmZzZXQgIT0gYS5vZmZzZXQgfHxcbiAgICAgIGZvY3VzS2V5ICE9IGYua2V5IHx8XG4gICAgICBmb2N1c09mZnNldCAhPSBmLm9mZnNldFxuICAgIClcblxuICAgIGlmIChoYXNNaXNtYXRjaCkge1xuICAgICAgY2hhbmdlLnNlbGVjdCh7XG4gICAgICAgIGFuY2hvcktleTogYS5rZXksXG4gICAgICAgIGFuY2hvck9mZnNldDogYS5vZmZzZXQsXG4gICAgICAgIGZvY3VzS2V5OiBmLmtleSxcbiAgICAgICAgZm9jdXNPZmZzZXQ6IGYub2Zmc2V0XG4gICAgICB9KVxuICAgIH1cblxuICAgIGNoYW5nZS5pbnNlcnRUZXh0KGV2ZW50LmRhdGEpXG4gIH1cblxuICAvKipcbiAgICogT24gYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkJsdXIoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkJsdXInLCB7IGV2ZW50LCBkYXRhIH0pXG4gICAgY2hhbmdlLmJsdXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGNvcHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25Db3B5KGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25Db3B5JywgeyBldmVudCwgZGF0YSB9KVxuICAgIG9uQ3V0T3JDb3B5KGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG4gIH1cblxuICAvKipcbiAgICogT24gY3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gb25DdXQoZXZlbnQsIGRhdGEsIGNoYW5nZSwgZWRpdG9yKSB7XG4gICAgZGVidWcoJ29uQ3V0JywgeyBldmVudCwgZGF0YSB9KVxuICAgIG9uQ3V0T3JDb3B5KGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG5cbiAgICAvLyBPbmNlIHRoZSBmYWtlIGN1dCBjb250ZW50IGhhcyBzdWNjZXNzZnVsbHkgYmVlbiBhZGRlZCB0byB0aGUgY2xpcGJvYXJkLFxuICAgIC8vIGRlbGV0ZSB0aGUgY29udGVudCBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGV2ZW50LnRhcmdldClcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGVkaXRvci5jaGFuZ2UodCA9PiB0LmRlbGV0ZSgpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogT24gY3V0IG9yIGNvcHksIGNyZWF0ZSBhIGZha2Ugc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBhIEJhc2UgNjRcbiAgICogZW5jb2RlZCBjb3B5IG9mIHRoZSBmcmFnbWVudCB0byB0aGUgSFRNTCwgdG8gZGVjb2RlIG9uIGZ1dHVyZSBwYXN0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25DdXRPckNvcHkoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhldmVudC50YXJnZXQpXG4gICAgY29uc3QgbmF0aXZlID0gd2luZG93LmdldFNlbGVjdGlvbigpXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBlbmRCbG9jaywgZW5kSW5saW5lIH0gPSBzdGF0ZVxuICAgIGNvbnN0IGlzVm9pZEJsb2NrID0gZW5kQmxvY2sgJiYgZW5kQmxvY2suaXNWb2lkXG4gICAgY29uc3QgaXNWb2lkSW5saW5lID0gZW5kSW5saW5lICYmIGVuZElubGluZS5pc1ZvaWRcbiAgICBjb25zdCBpc1ZvaWQgPSBpc1ZvaWRCbG9jayB8fCBpc1ZvaWRJbmxpbmVcblxuICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLCBhbmQgaXQgaXNuJ3QgaW5zaWRlIGEgdm9pZCBub2RlLCBhYm9ydC5cbiAgICBpZiAobmF0aXZlLmlzQ29sbGFwc2VkICYmICFpc1ZvaWQpIHJldHVyblxuXG4gICAgY29uc3QgeyBmcmFnbWVudCB9ID0gZGF0YVxuICAgIGNvbnN0IGVuY29kZWQgPSBCYXNlNjQuc2VyaWFsaXplTm9kZShmcmFnbWVudClcbiAgICBjb25zdCByYW5nZSA9IG5hdGl2ZS5nZXRSYW5nZUF0KDApXG4gICAgbGV0IGNvbnRlbnRzID0gcmFuZ2UuY2xvbmVDb250ZW50cygpXG4gICAgbGV0IGF0dGFjaCA9IGNvbnRlbnRzLmNoaWxkTm9kZXNbMF1cblxuICAgIC8vIElmIHRoZSBlbmQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZSBlbmQgb2YgdGhlIHJhbmdlIGZyb21cbiAgICAvLyB0aGUgdm9pZCBub2RlJ3Mgc3BhY2VyIHNwYW4sIHRvIHRoZSBlbmQgb2YgdGhlIHZvaWQgbm9kZSdzIGNvbnRlbnQuXG4gICAgaWYgKGlzVm9pZCkge1xuICAgICAgY29uc3QgciA9IHJhbmdlLmNsb25lUmFuZ2UoKVxuICAgICAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKGlzVm9pZEJsb2NrID8gZW5kQmxvY2sgOiBlbmRJbmxpbmUpXG4gICAgICByLnNldEVuZEFmdGVyKG5vZGUpXG4gICAgICBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpXG4gICAgICBhdHRhY2ggPSBjb250ZW50cy5jaGlsZE5vZGVzW2NvbnRlbnRzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMV0uZmlyc3RDaGlsZFxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgemVyby13aWR0aCBzcGFjZSBzcGFucyBmcm9tIHRoZSBjbG9uZWQgRE9NIHNvIHRoYXQgdGhleSBkb24ndFxuICAgIC8vIHNob3cgdXAgZWxzZXdoZXJlIHdoZW4gcGFzdGVkLlxuICAgIGNvbnN0IHp3cyA9IFtdLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSlcbiAgICB6d3MuZm9yRWFjaCh6dyA9PiB6dy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHp3KSlcblxuICAgIC8vIENPTVBBVDogSW4gQ2hyb21lIGFuZCBTYWZhcmksIGlmIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHNlbGVjdGlvbiB0b1xuICAgIC8vIGNvcHkgaGFzIGBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiYCB0aGUgY29weSB3aWxsIGZhaWwsIGFuZCBub3RoaW5nIHdpbGxcbiAgICAvLyBiZSBwdXQgaW4gdGhlIGNsaXBib2FyZC4gU28gd2UgcmVtb3ZlIHRoZW0gYWxsLiAoMjAxNy8wNS8wNClcbiAgICBpZiAoSVNfQ0hST01FIHx8IElTX1NBRkFSSSkge1xuICAgICAgY29uc3QgZWxzID0gW10uc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0nKSlcbiAgICAgIGVscy5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZUF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpXG4gICAgfVxuXG4gICAgLy8gU2V0IGEgYGRhdGEtc2xhdGUtZnJhZ21lbnRgIGF0dHJpYnV0ZSBvbiBhIG5vbi1lbXB0eSBub2RlLCBzbyBpdCBzaG93cyB1cFxuICAgIC8vIGluIHRoZSBIVE1MLCBhbmQgY2FuIGJlIHVzZWQgZm9yIGludHJhLVNsYXRlIHBhc3RpbmcuIElmIGl0J3MgYSB0ZXh0XG4gICAgLy8gbm9kZSwgd3JhcCBpdCBpbiBhIGA8c3Bhbj5gIHNvIHdlIGhhdmUgc29tZXRoaW5nIHRvIHNldCBhbiBhdHRyaWJ1dGUgb24uXG4gICAgaWYgKGF0dGFjaC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICBjb25zdCBzcGFuID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgc3Bhbi5hcHBlbmRDaGlsZChhdHRhY2gpXG4gICAgICBjb250ZW50cy5hcHBlbmRDaGlsZChzcGFuKVxuICAgICAgYXR0YWNoID0gc3BhblxuICAgIH1cblxuICAgIGF0dGFjaC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKVxuXG4gICAgLy8gQWRkIHRoZSBwaG9ueSBjb250ZW50IHRvIHRoZSBET00sIGFuZCBzZWxlY3QgaXQsIHNvIGl0IHdpbGwgYmUgY29waWVkLlxuICAgIGNvbnN0IGJvZHkgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpXG4gICAgY29uc3QgZGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSlcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgZGl2LnN0eWxlLmxlZnQgPSAnLTk5OTlweCdcbiAgICBkaXYuYXBwZW5kQ2hpbGQoY29udGVudHMpXG4gICAgYm9keS5hcHBlbmRDaGlsZChkaXYpXG5cbiAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIHRyeWluZyB0byB1c2UgdGhlIHRlcnNlciBgbmF0aXZlLnNlbGVjdEFsbENoaWxkcmVuYFxuICAgIC8vIHRocm93cyBhbiBlcnJvciwgc28gd2UgdXNlIHRoZSBvbGRlciBgcmFuZ2VgIGVxdWl2YWxlbnQuICgyMDE2LzA2LzIxKVxuICAgIGNvbnN0IHIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICAgIHIuc2VsZWN0Tm9kZUNvbnRlbnRzKGRpdilcbiAgICBuYXRpdmUucmVtb3ZlQWxsUmFuZ2VzKClcbiAgICBuYXRpdmUuYWRkUmFuZ2UocilcblxuICAgIC8vIFJldmVydCB0byB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIHJpZ2h0IGFmdGVyIGNvcHlpbmcuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBib2R5LnJlbW92ZUNoaWxkKGRpdilcbiAgICAgIG5hdGl2ZS5yZW1vdmVBbGxSYW5nZXMoKVxuICAgICAgbmF0aXZlLmFkZFJhbmdlKHJhbmdlKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogT24gZHJvcC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRyb3AoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkRyb3AnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIG9uRHJvcFRleHQoZXZlbnQsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ2ZyYWdtZW50JzpcbiAgICAgICAgcmV0dXJuIG9uRHJvcEZyYWdtZW50KGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICdub2RlJzpcbiAgICAgICAgcmV0dXJuIG9uRHJvcE5vZGUoZXZlbnQsIGRhdGEsIGNoYW5nZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gZHJvcCBub2RlLCBpbnNlcnQgdGhlIG5vZGUgd2hlcmV2ZXIgaXQgaXMgZHJvcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRyb3BOb2RlKGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBsZXQgeyBub2RlLCB0YXJnZXQsIGlzSW50ZXJuYWwgfSA9IGRhdGFcblxuICAgIC8vIElmIHRoZSBkcmFnIGlzIGludGVybmFsIGFuZCB0aGUgdGFyZ2V0IGlzIGFmdGVyIHRoZSBzZWxlY3Rpb24sIGl0XG4gICAgLy8gbmVlZHMgdG8gYWNjb3VudCBmb3IgdGhlIHNlbGVjdGlvbidzIGNvbnRlbnQgYmVpbmcgZGVsZXRlZC5cbiAgICBpZiAoXG4gICAgICBpc0ludGVybmFsICYmXG4gICAgICBzZWxlY3Rpb24uZW5kS2V5ID09IHRhcmdldC5lbmRLZXkgJiZcbiAgICAgIHNlbGVjdGlvbi5lbmRPZmZzZXQgPCB0YXJnZXQuZW5kT2Zmc2V0XG4gICAgKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQubW92ZShzZWxlY3Rpb24uc3RhcnRLZXkgPT0gc2VsZWN0aW9uLmVuZEtleVxuICAgICAgICA/IDAgLSBzZWxlY3Rpb24uZW5kT2Zmc2V0ICsgc2VsZWN0aW9uLnN0YXJ0T2Zmc2V0XG4gICAgICAgIDogMCAtIHNlbGVjdGlvbi5lbmRPZmZzZXQpXG4gICAgfVxuXG4gICAgaWYgKGlzSW50ZXJuYWwpIHtcbiAgICAgIGNoYW5nZS5kZWxldGUoKVxuICAgIH1cblxuICAgIGlmIChCbG9jay5pc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBjaGFuZ2VcbiAgICAgICAgLnNlbGVjdCh0YXJnZXQpXG4gICAgICAgIC5pbnNlcnRCbG9jayhub2RlKVxuICAgICAgICAucmVtb3ZlTm9kZUJ5S2V5KG5vZGUua2V5KVxuICAgIH1cblxuICAgIGlmIChJbmxpbmUuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgIGNoYW5nZVxuICAgICAgICAuc2VsZWN0KHRhcmdldClcbiAgICAgICAgLmluc2VydElubGluZShub2RlKVxuICAgICAgICAucmVtb3ZlTm9kZUJ5S2V5KG5vZGUua2V5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkcm9wIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uRHJvcEZyYWdtZW50KGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBsZXQgeyBmcmFnbWVudCwgdGFyZ2V0LCBpc0ludGVybmFsIH0gPSBkYXRhXG5cbiAgICAvLyBJZiB0aGUgZHJhZyBpcyBpbnRlcm5hbCBhbmQgdGhlIHRhcmdldCBpcyBhZnRlciB0aGUgc2VsZWN0aW9uLCBpdFxuICAgIC8vIG5lZWRzIHRvIGFjY291bnQgZm9yIHRoZSBzZWxlY3Rpb24ncyBjb250ZW50IGJlaW5nIGRlbGV0ZWQuXG4gICAgaWYgKFxuICAgICAgaXNJbnRlcm5hbCAmJlxuICAgICAgc2VsZWN0aW9uLmVuZEtleSA9PSB0YXJnZXQuZW5kS2V5ICYmXG4gICAgICBzZWxlY3Rpb24uZW5kT2Zmc2V0IDwgdGFyZ2V0LmVuZE9mZnNldFxuICAgICkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lm1vdmUoc2VsZWN0aW9uLnN0YXJ0S2V5ID09IHNlbGVjdGlvbi5lbmRLZXlcbiAgICAgICAgPyAwIC0gc2VsZWN0aW9uLmVuZE9mZnNldCArIHNlbGVjdGlvbi5zdGFydE9mZnNldFxuICAgICAgICA6IDAgLSBzZWxlY3Rpb24uZW5kT2Zmc2V0KVxuICAgIH1cblxuICAgIGlmIChpc0ludGVybmFsKSB7XG4gICAgICBjaGFuZ2UuZGVsZXRlKClcbiAgICB9XG5cbiAgICBjaGFuZ2VcbiAgICAgIC5zZWxlY3QodGFyZ2V0KVxuICAgICAgLmluc2VydEZyYWdtZW50KGZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRyb3AgdGV4dCwgc3BsaXQgdGhlIGJsb2NrcyBhdCBuZXcgbGluZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25Ecm9wVGV4dChldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgICBjb25zdCB7IHRleHQsIHRhcmdldCB9ID0gZGF0YVxuICAgIGNvbnN0IHsgYW5jaG9yS2V5IH0gPSB0YXJnZXRcblxuICAgIGNoYW5nZS5zZWxlY3QodGFyZ2V0KVxuXG4gICAgbGV0IGhhc1ZvaWRQYXJlbnQgPSBkb2N1bWVudC5oYXNWb2lkUGFyZW50KGFuY2hvcktleSlcblxuICAgIC8vIEluc2VydCB0ZXh0IGludG8gbmVhcmVzdCB0ZXh0IG5vZGVcbiAgICBpZiAoaGFzVm9pZFBhcmVudCkge1xuICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5nZXROb2RlKGFuY2hvcktleSlcblxuICAgICAgd2hpbGUgKGhhc1ZvaWRQYXJlbnQpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldE5leHRUZXh0KG5vZGUua2V5KVxuICAgICAgICBpZiAoIW5vZGUpIGJyZWFrXG4gICAgICAgIGhhc1ZvaWRQYXJlbnQgPSBkb2N1bWVudC5oYXNWb2lkUGFyZW50KG5vZGUua2V5KVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSkgY2hhbmdlLmNvbGxhcHNlVG9TdGFydE9mKG5vZGUpXG4gICAgfVxuXG4gICAgdGV4dFxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmZvckVhY2goKGxpbmUsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPiAwKSBjaGFuZ2Uuc3BsaXRCbG9jaygpXG4gICAgICAgIGNoYW5nZS5pbnNlcnRUZXh0KGxpbmUpXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gb25JbnB1dChldmVudCwgZGF0YSwgY2hhbmdlLCBlZGl0b3IpIHtcbiAgICBkZWJ1Zygnb25JbnB1dCcsIHsgZXZlbnQsIGRhdGEgfSlcblxuICAgIC8vIEdldCB0aGUgbmF0aXZlIHNlbGVjdGlvbiBwb2ludC5cbiAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KVxuICAgIGNvbnN0IG5hdGl2ZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxuICAgIGNvbnN0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSBuYXRpdmVcbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgc3RhdGUsIGVkaXRvcilcbiAgICBjb25zdCB7IGtleSwgaW5kZXggfSA9IHBvaW50XG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gZGF0YVxuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgIGNvbnN0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBjb25zdCBzY2hlbWEgPSBlZGl0b3IuZ2V0U2NoZW1hKClcbiAgICBjb25zdCBkZWNvcmF0b3JzID0gZG9jdW1lbnQuZ2V0RGVzY2VuZGFudERlY29yYXRvcnMoa2V5LCBzY2hlbWEpXG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmdldERlc2NlbmRhbnQoa2V5KVxuICAgIGNvbnN0IGJsb2NrID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdEJsb2NrKG5vZGUua2V5KVxuICAgIGNvbnN0IHJhbmdlcyA9IG5vZGUuZ2V0UmFuZ2VzKGRlY29yYXRvcnMpXG4gICAgY29uc3QgbGFzdFRleHQgPSBibG9jay5nZXRMYXN0VGV4dCgpXG5cbiAgICAvLyBHZXQgdGhlIHRleHQgaW5mb3JtYXRpb24uXG4gICAgbGV0IHsgdGV4dENvbnRlbnQgfSA9IGFuY2hvck5vZGVcbiAgICBjb25zdCBsYXN0Q2hhciA9IHRleHRDb250ZW50LmNoYXJBdCh0ZXh0Q29udGVudC5sZW5ndGggLSAxKVxuICAgIGNvbnN0IGlzTGFzdFRleHQgPSBub2RlID09IGxhc3RUZXh0XG4gICAgY29uc3QgaXNMYXN0UmFuZ2UgPSBpbmRleCA9PSByYW5nZXMuc2l6ZSAtIDFcblxuICAgIC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCB0aGUgbGFzdCBsZWFmLCBhbmQgdGhlIERPTSB0ZXh0IGVuZHMgaW4gYSBuZXcgbGluZSxcbiAgICAvLyB3ZSB3aWxsIGhhdmUgYWRkZWQgYW5vdGhlciBuZXcgbGluZSBpbiA8TGVhZj4ncyByZW5kZXIgbWV0aG9kIHRvIGFjY291bnRcbiAgICAvLyBmb3IgYnJvd3NlcnMgY29sbGFwc2luZyBhIHNpbmdsZSB0cmFpbGluZyBuZXcgbGluZXMsIHNvIHJlbW92ZSBpdC5cbiAgICBpZiAoaXNMYXN0VGV4dCAmJiBpc0xhc3RSYW5nZSAmJiBsYXN0Q2hhciA9PSAnXFxuJykge1xuICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCAtMSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGV4dCBpcyBubyBkaWZmZXJlbnQsIGFib3J0LlxuICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzLmdldChpbmRleClcbiAgICBjb25zdCB7IHRleHQsIG1hcmtzIH0gPSByYW5nZVxuXG4gICAgaWYgKHRleHRDb250ZW50ID09IHRleHQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHdoYXQgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgYWZ0ZXIgY2hhbmdpbmcgdGhlIHRleHQuXG4gICAgY29uc3QgZGVsdGEgPSB0ZXh0Q29udGVudC5sZW5ndGggLSB0ZXh0Lmxlbmd0aFxuICAgIGNvbnN0IGFmdGVyID0gc2VsZWN0aW9uLmNvbGxhcHNlVG9FbmQoKS5tb3ZlKGRlbHRhKVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBjdXJyZW50IHN0YXRlIHRvIGhhdmUgdGhlIHRleHQgcmVwbGFjZWQuXG4gICAgY2hhbmdlXG4gICAgICAuc2VsZWN0KHRhcmdldClcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmluc2VydFRleHQodGV4dENvbnRlbnQsIG1hcmtzKVxuICAgICAgLnNlbGVjdChhZnRlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBrZXkgZG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbktleURvd24nLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICBzd2l0Y2ggKGRhdGEua2V5KSB7XG4gICAgICBjYXNlICdlbnRlcic6IHJldHVybiBvbktleURvd25FbnRlcihldmVudCwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAnYmFja3NwYWNlJzogcmV0dXJuIG9uS2V5RG93bkJhY2tzcGFjZShldmVudCwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAnZGVsZXRlJzogcmV0dXJuIG9uS2V5RG93bkRlbGV0ZShldmVudCwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAnbGVmdCc6IHJldHVybiBvbktleURvd25MZWZ0KGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICdyaWdodCc6IHJldHVybiBvbktleURvd25SaWdodChldmVudCwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAndXAnOiByZXR1cm4gb25LZXlEb3duVXAoZXZlbnQsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ2Rvd24nOiByZXR1cm4gb25LZXlEb3duRG93bihldmVudCwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAnZCc6IHJldHVybiBvbktleURvd25EKGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICdoJzogcmV0dXJuIG9uS2V5RG93bkgoZXZlbnQsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ2snOiByZXR1cm4gb25LZXlEb3duSyhldmVudCwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAneSc6IHJldHVybiBvbktleURvd25ZKGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICd6JzogcmV0dXJuIG9uS2V5RG93blooZXZlbnQsIGRhdGEsIGNoYW5nZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gYGVudGVyYCBrZXkgZG93biwgc3BsaXQgdGhlIGN1cnJlbnQgYmxvY2sgaW4gaGFsZi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbktleURvd25FbnRlcihldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBkb2N1bWVudCwgc3RhcnRLZXkgfSA9IHN0YXRlXG4gICAgY29uc3QgaGFzVm9pZFBhcmVudCA9IGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQoc3RhcnRLZXkpXG5cbiAgICAvLyBGb3Igdm9pZCBub2Rlcywgd2UgZG9uJ3Qgd2FudCB0byBzcGxpdC4gSW5zdGVhZCB3ZSBqdXN0IG1vdmUgdG8gdGhlIHN0YXJ0XG4gICAgLy8gb2YgdGhlIG5leHQgdGV4dCBub2RlIGlmIG9uZSBleGlzdHMuXG4gICAgaWYgKGhhc1ZvaWRQYXJlbnQpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5nZXROZXh0VGV4dChzdGFydEtleSlcbiAgICAgIGlmICghdGV4dCkgcmV0dXJuXG4gICAgICBjaGFuZ2UuY29sbGFwc2VUb1N0YXJ0T2YodGV4dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNoYW5nZS5zcGxpdEJsb2NrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgYmFja3NwYWNlYCBrZXkgZG93biwgZGVsZXRlIGJhY2t3YXJkcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbktleURvd25CYWNrc3BhY2UoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGxldCBib3VuZGFyeSA9ICdDaGFyJ1xuICAgIGlmIChkYXRhLmlzV29yZCkgYm91bmRhcnkgPSAnV29yZCdcbiAgICBpZiAoZGF0YS5pc0xpbmUpIGJvdW5kYXJ5ID0gJ0xpbmUnXG4gICAgY2hhbmdlW2BkZWxldGUke2JvdW5kYXJ5fUJhY2t3YXJkYF0oKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGBkZWxldGVgIGtleSBkb3duLCBkZWxldGUgZm9yd2FyZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duRGVsZXRlKGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBsZXQgYm91bmRhcnkgPSAnQ2hhcidcbiAgICBpZiAoZGF0YS5pc1dvcmQpIGJvdW5kYXJ5ID0gJ1dvcmQnXG4gICAgaWYgKGRhdGEuaXNMaW5lKSBib3VuZGFyeSA9ICdMaW5lJ1xuICAgIGNoYW5nZVtgZGVsZXRlJHtib3VuZGFyeX1Gb3J3YXJkYF0oKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGBsZWZ0YCBrZXkgZG93biwgbW92ZSBiYWNrd2FyZC5cbiAgICpcbiAgICogQ09NUEFUOiBUaGlzIGlzIHJlcXVpcmVkIHRvIG1ha2UgbmF2aWdhdGluZyB3aXRoIHRoZSBsZWZ0IGFycm93IHdvcmsgd2hlblxuICAgKiBhIHZvaWQgbm9kZSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQ09NUEFUOiBUaGlzIGlzIGFsc28gcmVxdWlyZWQgdG8gc29sdmUgZm9yIHRoZSBjYXNlIHdoZXJlIGFuIGlubGluZSBub2RlIGlzXG4gICAqIHN1cnJvdW5kZWQgYnkgZW1wdHkgdGV4dCBub2RlcyB3aXRoIHplcm8td2lkdGggc3BhY2VzIGluIHRoZW0uIFdpdGhvdXQgdGhpc1xuICAgKiB0aGUgemVyby13aWR0aCBzcGFjZXMgd2lsbCBjYXVzZSB0d28gYXJyb3cga2V5cyB0byBqdW1wIHRvIHRoZSBuZXh0IHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duTGVmdChldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG5cbiAgICBpZiAoZGF0YS5pc0N0cmwpIHJldHVyblxuICAgIGlmIChkYXRhLmlzQWx0KSByZXR1cm5cbiAgICBpZiAoc3RhdGUuaXNFeHBhbmRlZCkgcmV0dXJuXG5cbiAgICBjb25zdCB7IGRvY3VtZW50LCBzdGFydEtleSwgc3RhcnRUZXh0IH0gPSBzdGF0ZVxuICAgIGNvbnN0IGhhc1ZvaWRQYXJlbnQgPSBkb2N1bWVudC5oYXNWb2lkUGFyZW50KHN0YXJ0S2V5KVxuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgdGV4dCBub2RlIGlzIGVtcHR5LCBvciB3ZSdyZSBpbnNpZGUgYSB2b2lkIHBhcmVudCwgd2UncmVcbiAgICAvLyBnb2luZyB0byBuZWVkIHRvIGhhbmRsZSB0aGUgc2VsZWN0aW9uIGJlaGF2aW9yLlxuICAgIGlmIChzdGFydFRleHQudGV4dCA9PSAnJyB8fCBoYXNWb2lkUGFyZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBjb25zdCBwcmV2aW91cyA9IGRvY3VtZW50LmdldFByZXZpb3VzVGV4dChzdGFydEtleSlcblxuICAgICAgLy8gSWYgdGhlcmUncyBubyBwcmV2aW91cyB0ZXh0IG5vZGUgaW4gdGhlIGRvY3VtZW50LCBhYm9ydC5cbiAgICAgIGlmICghcHJldmlvdXMpIHJldHVyblxuXG4gICAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGV4dCBpcyBpbiB0aGUgY3VycmVudCBibG9jaywgYW5kIGluc2lkZSBhIG5vbi12b2lkXG4gICAgICAvLyBpbmxpbmUgbm9kZSwgbW92ZSBvbmUgY2hhcmFjdGVyIGludG8gdGhlIGlubGluZSBub2RlLlxuICAgICAgY29uc3QgeyBzdGFydEJsb2NrIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgcHJldmlvdXNCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhwcmV2aW91cy5rZXkpXG4gICAgICBjb25zdCBwcmV2aW91c0lubGluZSA9IGRvY3VtZW50LmdldENsb3Nlc3RJbmxpbmUocHJldmlvdXMua2V5KVxuXG4gICAgICBpZiAocHJldmlvdXNCbG9jayA9PT0gc3RhcnRCbG9jayAmJiBwcmV2aW91c0lubGluZSAmJiAhcHJldmlvdXNJbmxpbmUuaXNWb2lkKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE9yTW92ZSA9IGRhdGEuaXNTaGlmdCA/ICdleHRlbmQnIDogJ21vdmUnXG4gICAgICAgIGNoYW5nZS5jb2xsYXBzZVRvRW5kT2YocHJldmlvdXMpW2V4dGVuZE9yTW92ZV0oLTEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIG1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgbm9kZS5cbiAgICAgIGNoYW5nZS5jb2xsYXBzZVRvRW5kT2YocHJldmlvdXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGByaWdodGAga2V5IGRvd24sIG1vdmUgZm9yd2FyZC5cbiAgICpcbiAgICogQ09NUEFUOiBUaGlzIGlzIHJlcXVpcmVkIHRvIG1ha2UgbmF2aWdhdGluZyB3aXRoIHRoZSByaWdodCBhcnJvdyB3b3JrIHdoZW5cbiAgICogYSB2b2lkIG5vZGUgaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIENPTVBBVDogVGhpcyBpcyBhbHNvIHJlcXVpcmVkIHRvIHNvbHZlIGZvciB0aGUgY2FzZSB3aGVyZSBhbiBpbmxpbmUgbm9kZSBpc1xuICAgKiBzdXJyb3VuZGVkIGJ5IGVtcHR5IHRleHQgbm9kZXMgd2l0aCB6ZXJvLXdpZHRoIHNwYWNlcyBpbiB0aGVtLiBXaXRob3V0IHRoaXNcbiAgICogdGhlIHplcm8td2lkdGggc3BhY2VzIHdpbGwgY2F1c2UgdHdvIGFycm93IGtleXMgdG8ganVtcCB0byB0aGUgbmV4dCB0ZXh0LlxuICAgKlxuICAgKiBDT01QQVQ6IEluIENocm9tZSAmIFNhZmFyaSwgc2VsZWN0aW9ucyB0aGF0IGFyZSBhdCB0aGUgemVybyBvZmZzZXQgb2ZcbiAgICogYW4gaW5saW5lIG5vZGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHRvIGJlIGF0IHRoZSBsYXN0IG9mZnNldFxuICAgKiBvZiBhIHByZXZpb3VzIGlubGluZSBub2RlLCB3aGljaCBzY3Jld3MgdXMgdXAsIHNvIHdlIG5ldmVyIHdhbnQgdG8gc2V0IHRoZVxuICAgKiBzZWxlY3Rpb24gdG8gdGhlIHZlcnkgc3RhcnQgb2YgYW4gaW5saW5lIG5vZGUgaGVyZS4gKDIwMTYvMTEvMjkpXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duUmlnaHQoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuXG4gICAgaWYgKGRhdGEuaXNDdHJsKSByZXR1cm5cbiAgICBpZiAoZGF0YS5pc0FsdCkgcmV0dXJuXG4gICAgaWYgKHN0YXRlLmlzRXhwYW5kZWQpIHJldHVyblxuXG4gICAgY29uc3QgeyBkb2N1bWVudCwgc3RhcnRLZXksIHN0YXJ0VGV4dCB9ID0gc3RhdGVcbiAgICBjb25zdCBoYXNWb2lkUGFyZW50ID0gZG9jdW1lbnQuaGFzVm9pZFBhcmVudChzdGFydEtleSlcblxuICAgIC8vIElmIHRoZSBjdXJyZW50IHRleHQgbm9kZSBpcyBlbXB0eSwgb3Igd2UncmUgaW5zaWRlIGEgdm9pZCBwYXJlbnQsIHdlJ3JlXG4gICAgLy8gZ29pbmcgdG8gbmVlZCB0byBoYW5kbGUgdGhlIHNlbGVjdGlvbiBiZWhhdmlvci5cbiAgICBpZiAoc3RhcnRUZXh0LnRleHQgPT0gJycgfHwgaGFzVm9pZFBhcmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgY29uc3QgbmV4dCA9IGRvY3VtZW50LmdldE5leHRUZXh0KHN0YXJ0S2V5KVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG5leHQgdGV4dCBub2RlIGluIHRoZSBkb2N1bWVudCwgYWJvcnQuXG4gICAgICBpZiAoIW5leHQpIHJldHVyblxuXG4gICAgICAvLyBJZiB0aGUgbmV4dCB0ZXh0IGlzIGluc2lkZSBhIHZvaWQgbm9kZSwgbW92ZSB0byB0aGUgZW5kIG9mIGl0LlxuICAgICAgaWYgKGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQobmV4dC5rZXkpKSB7XG4gICAgICAgIGNoYW5nZS5jb2xsYXBzZVRvRW5kT2YobmV4dClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBuZXh0IHRleHQgaXMgaW4gdGhlIGN1cnJlbnQgYmxvY2ssIGFuZCBpbnNpZGUgYW4gaW5saW5lIG5vZGUsXG4gICAgICAvLyBtb3ZlIG9uZSBjaGFyYWN0ZXIgaW50byB0aGUgaW5saW5lIG5vZGUuXG4gICAgICBjb25zdCB7IHN0YXJ0QmxvY2sgfSA9IHN0YXRlXG4gICAgICBjb25zdCBuZXh0QmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2sobmV4dC5rZXkpXG4gICAgICBjb25zdCBuZXh0SW5saW5lID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdElubGluZShuZXh0LmtleSlcblxuICAgICAgaWYgKG5leHRCbG9jayA9PSBzdGFydEJsb2NrICYmIG5leHRJbmxpbmUpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kT3JNb3ZlID0gZGF0YS5pc1NoaWZ0ID8gJ2V4dGVuZCcgOiAnbW92ZSdcbiAgICAgICAgY2hhbmdlLmNvbGxhcHNlVG9TdGFydE9mKG5leHQpW2V4dGVuZE9yTW92ZV0oMSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgbW92ZSB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdGV4dCBub2RlLlxuICAgICAgY2hhbmdlLmNvbGxhcHNlVG9TdGFydE9mKG5leHQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGB1cGAga2V5IGRvd24sIGZvciBNYWNzLCBtb3ZlIHRoZSBzZWxlY3Rpb24gdG8gc3RhcnQgb2YgdGhlIGJsb2NrLlxuICAgKlxuICAgKiBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3QgaGFuZGxlIHRoZSBzZWxlY3Rpb24gdXBkYXRlcyBwcm9wZXJseS4gSW5cbiAgICogQ2hyb21lLCBvcHRpb24tc2hpZnQtdXAgZG9lc24ndCBwcm9wZXJseSBleHRlbmQgdGhlIHNlbGVjdGlvbi4gQW5kIGluXG4gICAqIEZpcmVmb3gsIG9wdGlvbi11cCBkb2Vzbid0IHByb3Blcmx5IG1vdmUgdGhlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbktleURvd25VcChldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFJU19NQUMgfHwgZGF0YS5pc0N0cmwgfHwgIWRhdGEuaXNBbHQpIHJldHVyblxuXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvY3VtZW50LCBmb2N1c0tleSwgZm9jdXNCbG9jayB9ID0gc3RhdGVcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBkYXRhLmlzU2hpZnQgPyAnZXh0ZW5kVG9TdGFydE9mJyA6ICdjb2xsYXBzZVRvU3RhcnRPZidcbiAgICBjb25zdCBibG9jayA9IHNlbGVjdGlvbi5oYXNGb2N1c0F0U3RhcnRPZihmb2N1c0Jsb2NrKVxuICAgICAgPyBkb2N1bWVudC5nZXRQcmV2aW91c0Jsb2NrKGZvY3VzS2V5KVxuICAgICAgOiBmb2N1c0Jsb2NrXG5cbiAgICBpZiAoIWJsb2NrKSByZXR1cm5cbiAgICBjb25zdCB0ZXh0ID0gYmxvY2suZ2V0Rmlyc3RUZXh0KClcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBjaGFuZ2VbdHJhbnNmb3JtXSh0ZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGBkb3duYCBrZXkgZG93biwgZm9yIE1hY3MsIG1vdmUgdGhlIHNlbGVjdGlvbiB0byBlbmQgb2YgdGhlIGJsb2NrLlxuICAgKlxuICAgKiBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3QgaGFuZGxlIHRoZSBzZWxlY3Rpb24gdXBkYXRlcyBwcm9wZXJseS4gSW5cbiAgICogQ2hyb21lLCBvcHRpb24tc2hpZnQtZG93biBkb2Vzbid0IHByb3Blcmx5IGV4dGVuZCB0aGUgc2VsZWN0aW9uLiBBbmQgaW5cbiAgICogRmlyZWZveCwgb3B0aW9uLWRvd24gZG9lc24ndCBwcm9wZXJseSBtb3ZlIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duRG93bihldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFJU19NQUMgfHwgZGF0YS5pc0N0cmwgfHwgIWRhdGEuaXNBbHQpIHJldHVyblxuXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvY3VtZW50LCBmb2N1c0tleSwgZm9jdXNCbG9jayB9ID0gc3RhdGVcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBkYXRhLmlzU2hpZnQgPyAnZXh0ZW5kVG9FbmRPZicgOiAnY29sbGFwc2VUb0VuZE9mJ1xuICAgIGNvbnN0IGJsb2NrID0gc2VsZWN0aW9uLmhhc0ZvY3VzQXRFbmRPZihmb2N1c0Jsb2NrKVxuICAgICAgPyBkb2N1bWVudC5nZXROZXh0QmxvY2soZm9jdXNLZXkpXG4gICAgICA6IGZvY3VzQmxvY2tcblxuICAgIGlmICghYmxvY2spIHJldHVyblxuICAgIGNvbnN0IHRleHQgPSBibG9jay5nZXRMYXN0VGV4dCgpXG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY2hhbmdlW3RyYW5zZm9ybV0odGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgZGAga2V5IGRvd24sIGZvciBNYWNzLCBkZWxldGUgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bkQoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGlmICghSVNfTUFDIHx8ICFkYXRhLmlzQ3RybCkgcmV0dXJuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGNoYW5nZS5kZWxldGVDaGFyRm9yd2FyZCgpXG4gIH1cblxuICAvKipcbiAgICogT24gYGhgIGtleSBkb3duLCBmb3IgTWFjcywgZGVsZXRlIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duSChldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFJU19NQUMgfHwgIWRhdGEuaXNDdHJsKSByZXR1cm5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY2hhbmdlLmRlbGV0ZUNoYXJCYWNrd2FyZCgpXG4gIH1cblxuICAvKipcbiAgICogT24gYGtgIGtleSBkb3duLCBmb3IgTWFjcywgZGVsZXRlIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duSyhldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFJU19NQUMgfHwgIWRhdGEuaXNDdHJsKSByZXR1cm5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY2hhbmdlLmRlbGV0ZUxpbmVGb3J3YXJkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgeWAga2V5IGRvd24sIHJlZG8uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duWShldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFkYXRhLmlzTW9kKSByZXR1cm5cbiAgICBjaGFuZ2UucmVkbygpXG4gIH1cblxuICAvKipcbiAgICogT24gYHpgIGtleSBkb3duLCB1bmRvIG9yIHJlZG8uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duWihldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFkYXRhLmlzTW9kKSByZXR1cm5cbiAgICBjaGFuZ2VbZGF0YS5pc1NoaWZ0ID8gJ3JlZG8nIDogJ3VuZG8nXSgpXG4gIH1cblxuICAvKipcbiAgICogT24gcGFzdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25QYXN0ZShldmVudCwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uUGFzdGUnLCB7IGV2ZW50LCBkYXRhIH0pXG5cbiAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgY2FzZSAnZnJhZ21lbnQnOlxuICAgICAgICByZXR1cm4gb25QYXN0ZUZyYWdtZW50KGV2ZW50LCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICd0ZXh0JzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gb25QYXN0ZVRleHQoZXZlbnQsIGRhdGEsIGNoYW5nZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gcGFzdGUgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25QYXN0ZUZyYWdtZW50KGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjaGFuZ2UuaW5zZXJ0RnJhZ21lbnQoZGF0YS5mcmFnbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBwYXN0ZSB0ZXh0LCBzcGxpdCBibG9ja3MgYXQgbmV3IGxpbmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uUGFzdGVUZXh0KGV2ZW50LCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgICBjb25zdCB7IGRvY3VtZW50LCBzZWxlY3Rpb24sIHN0YXJ0QmxvY2sgfSA9IHN0YXRlXG4gICAgaWYgKHN0YXJ0QmxvY2suaXNWb2lkKSByZXR1cm5cblxuICAgIGNvbnN0IHsgdGV4dCB9ID0gZGF0YVxuICAgIGNvbnN0IGRlZmF1bHRCbG9jayA9IHN0YXJ0QmxvY2tcbiAgICBjb25zdCBkZWZhdWx0TWFya3MgPSBkb2N1bWVudC5nZXRNYXJrc0F0UmFuZ2Uoc2VsZWN0aW9uLmNvbGxhcHNlVG9TdGFydCgpKVxuICAgIGNvbnN0IGZyYWdtZW50ID0gUGxhaW4uZGVzZXJpYWxpemUodGV4dCwgeyBkZWZhdWx0QmxvY2ssIGRlZmF1bHRNYXJrcyB9KS5kb2N1bWVudFxuICAgIGNoYW5nZS5pbnNlcnRGcmFnbWVudChmcmFnbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBzZWxlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25TZWxlY3QoZXZlbnQsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvblNlbGVjdCcsIHsgZXZlbnQsIGRhdGEgfSlcbiAgICBjaGFuZ2Uuc2VsZWN0KGRhdGEuc2VsZWN0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gICAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiByZW5kZXIocHJvcHMsIHN0YXRlLCBlZGl0b3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPENvbnRlbnRcbiAgICAgICAgYXV0b0NvcnJlY3Q9e3Byb3BzLmF1dG9Db3JyZWN0fVxuICAgICAgICBhdXRvRm9jdXM9e3Byb3BzLmF1dG9Gb2N1c31cbiAgICAgICAgY2xhc3NOYW1lPXtwcm9wcy5jbGFzc05hbWV9XG4gICAgICAgIGNoaWxkcmVuPXtwcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgZWRpdG9yPXtlZGl0b3J9XG4gICAgICAgIG9uQmVmb3JlSW5wdXQ9e2VkaXRvci5vbkJlZm9yZUlucHV0fVxuICAgICAgICBvbkJsdXI9e2VkaXRvci5vbkJsdXJ9XG4gICAgICAgIG9uQ29tcG9zaXRpb25FbmQ9e2VkaXRvci5vbkNvbXBvc2l0aW9uRW5kfVxuICAgICAgICBvbkNvbXBvc2l0aW9uU3RhcnQ9e2VkaXRvci5vbkNvbXBvc2l0aW9uU3RhcnR9XG4gICAgICAgIG9uQ29weT17ZWRpdG9yLm9uQ29weX1cbiAgICAgICAgb25DdXQ9e2VkaXRvci5vbkN1dH1cbiAgICAgICAgb25EcmFnRW5kPXtlZGl0b3Iub25EcmFnRW5kfVxuICAgICAgICBvbkRyYWdPdmVyPXtlZGl0b3Iub25EcmFnT3Zlcn1cbiAgICAgICAgb25EcmFnU3RhcnQ9e2VkaXRvci5vbkRyYWdTdGFydH1cbiAgICAgICAgb25Ecm9wPXtlZGl0b3Iub25Ecm9wfVxuICAgICAgICBvbkZvY3VzPXtlZGl0b3Iub25Gb2N1c31cbiAgICAgICAgb25JbnB1dD17ZWRpdG9yLm9uSW5wdXR9XG4gICAgICAgIG9uS2V5RG93bj17ZWRpdG9yLm9uS2V5RG93bn1cbiAgICAgICAgb25LZXlVcD17ZWRpdG9yLm9uS2V5VXB9XG4gICAgICAgIG9uUGFzdGU9e2VkaXRvci5vblBhc3RlfVxuICAgICAgICBvblNlbGVjdD17ZWRpdG9yLm9uU2VsZWN0fVxuICAgICAgICByZWFkT25seT17cHJvcHMucmVhZE9ubHl9XG4gICAgICAgIHJvbGU9e3Byb3BzLnJvbGV9XG4gICAgICAgIHNjaGVtYT17ZWRpdG9yLmdldFNjaGVtYSgpfVxuICAgICAgICBzcGVsbENoZWNrPXtwcm9wcy5zcGVsbENoZWNrfVxuICAgICAgICBzdGF0ZT17c3RhdGV9XG4gICAgICAgIHN0eWxlPXtwcm9wcy5zdHlsZX1cbiAgICAgICAgdGFiSW5kZXg9e3Byb3BzLnRhYkluZGV4fVxuICAgICAgICB0YWdOYW1lPXtwcm9wcy50YWdOYW1lfVxuICAgICAgLz5cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQSBkZWZhdWx0IHNjaGVtYSBydWxlIHRvIHJlbmRlciBibG9jayBub2Rlcy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgY29uc3QgQkxPQ0tfUkVOREVSX1JVTEUgPSB7XG4gICAgbWF0Y2g6IChub2RlKSA9PiB7XG4gICAgICByZXR1cm4gbm9kZS5raW5kID09ICdibG9jaydcbiAgICB9LFxuICAgIHJlbmRlcjogKHByb3BzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IHsuLi5wcm9wcy5hdHRyaWJ1dGVzfSBzdHlsZT17eyBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9fT5cbiAgICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAge3BsYWNlaG9sZGVyXG4gICAgICAgICAgICA/IDxQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cGxhY2Vob2xkZXJDbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgbm9kZT17cHJvcHMubm9kZX1cbiAgICAgICAgICAgICAgICBwYXJlbnQ9e3Byb3BzLnN0YXRlLmRvY3VtZW50fVxuICAgICAgICAgICAgICAgIHN0YXRlPXtwcm9wcy5zdGF0ZX1cbiAgICAgICAgICAgICAgICBzdHlsZT17cGxhY2Vob2xkZXJTdHlsZX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgPC9QbGFjZWhvbGRlcj5cbiAgICAgICAgICAgIDogbnVsbH1cbiAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgZGVmYXVsdCBzY2hlbWEgcnVsZSB0byByZW5kZXIgaW5saW5lIG5vZGVzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICBjb25zdCBJTkxJTkVfUkVOREVSX1JVTEUgPSB7XG4gICAgbWF0Y2g6IChub2RlKSA9PiB7XG4gICAgICByZXR1cm4gbm9kZS5raW5kID09ICdpbmxpbmUnXG4gICAgfSxcbiAgICByZW5kZXI6IChwcm9wcykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPHNwYW4gey4uLnByb3BzLmF0dHJpYnV0ZXN9IHN0eWxlPXt7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH19PlxuICAgICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGVmYXVsdCByZW5kZXJpbmcgcnVsZXMgdG8gdGhlIHNjaGVtYS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIHJ1bGVzOiBbXG4gICAgICBCTE9DS19SRU5ERVJfUlVMRSxcbiAgICAgIElOTElORV9SRU5ERVJfUlVMRVxuICAgIF1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvcmUgcGx1Z2luLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICByZXR1cm4ge1xuICAgIG9uQmVmb3JlSW5wdXQsXG4gICAgb25CbHVyLFxuICAgIG9uQ29weSxcbiAgICBvbkN1dCxcbiAgICBvbkRyb3AsXG4gICAgb25JbnB1dCxcbiAgICBvbktleURvd24sXG4gICAgb25QYXN0ZSxcbiAgICBvblNlbGVjdCxcbiAgICByZW5kZXIsXG4gICAgc2NoZW1hLFxuICB9XG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgUGx1Z2luXG4iXX0=