'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class, _class2, _temp;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _proptypes = require('proptypes');

var _proptypes2 = _interopRequireDefault(_proptypes);

var _lodash = require('lodash.identity');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.sortby');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.first');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.isnumber');

var _lodash8 = _interopRequireDefault(_lodash7);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = void 0;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var isBrowser = typeof window !== 'undefined';

var ElementQuery = (_class = (_temp = _class2 = function (_PureComponent) {
  _inherits(ElementQuery, _PureComponent);

  function ElementQuery(props) {
    _classCallCheck(this, ElementQuery);

    var _this = _possibleConstructorReturn(this, (ElementQuery.__proto__ || Object.getPrototypeOf(ElementQuery)).call(this, props));

    _this.state = { size: props.default, sizes: ElementQuery.sortSizes(_this.props.sizes) };
    return _this;
  }

  _createClass(ElementQuery, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      ElementQuery.register({
        component: this,
        sizes: this.state.sizes,
        node: this.node
      });

      ElementQuery.sizeComponent({
        component: this,
        sizes: this.state.sizes,
        node: this.node
      });

      // wait a few frames then check sizes again
      (0, _raf2.default)(function () {
        return (0, _raf2.default)(function () {
          ElementQuery.sizeComponent({
            component: _this2,
            sizes: _this2.state.sizes,
            node: _this2.node
          });
        });
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      this.setState({ sizes: ElementQuery.sortSizes(newProps.sizes) });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      ElementQuery.unregister(this);
    }
  }, {
    key: 'setSize',
    value: function setSize(size) {
      this.setState({ size: size });
    }
  }, {
    key: 'setNode',
    value: function setNode(node) {
      this.node = node;
    }
  }, {
    key: 'makeChild',
    value: function makeChild(child, className) {
      // just add our new class name onto the chilren, this alleviates the need to
      // create a wrapper div
      var classNames = [];
      var existingClassName = child.props.className;
      if (existingClassName) classNames.push(existingClassName);
      if (className) classNames.push(className);

      return (0, _react.cloneElement)(child, {
        className: classNames.join(' '),
        ref: this.setNode
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var size = isBrowser ? this.state.size : this.props.default;
      var className = size ? this.props.makeClassName(size) : '';
      var children = this.props.children;

      var child = Array.isArray(children) && _react.Children.count(children) === 1 ? children[0] : children;

      // because we're going to just apply the className onto the child, we can
      // only accept one. React doesn't let us return an array of children.
      // returning a wrapper div is undesirable because it creates un-expected DOM
      // like real element queries, this enables the user to do things like wrap
      // an `<li>` in an element query and not break HTML semantics, or use
      // element query and not break expectations around things like flexbox.
      return this.makeChild(_react.Children.only(child), className);
    }
  }], [{
    key: 'listen',


    // use only one global listener â€¦ for perf!
    value: function listen() {
      window.addEventListener('resize', ElementQuery.onResize);
      ElementQuery._isListening = true;
    }
  }, {
    key: 'unListen',
    value: function unListen() {
      window.removeEventListener('resize', ElementQuery.onResize);
      ElementQuery._isListening = false;
    }
  }, {
    key: 'register',
    value: function register(_ref) {
      var component = _ref.component,
          sizes = _ref.sizes,
          onResize = _ref.onResize,
          node = _ref.node;

      if (!isBrowser) return;

      ElementQuery._componentMap.set(component, {
        sizes: sizes,
        node: node
        // if a custom onResize callback is passed, e.g. using this lib just for
        // the resize event listener, use that. Else, assume we're sizing the
        // component
        , onResize: onResize || ElementQuery.sizeComponent
      });

      if (!ElementQuery._isListening && isBrowser) ElementQuery.listen();
    }
  }, {
    key: 'unregister',
    value: function unregister(component) {
      if (!isBrowser) return;

      ElementQuery._componentMap.delete(component);
      if (!ElementQuery._componentMap.size && isBrowser) ElementQuery.unListen();
    }
  }, {
    key: 'sizeComponents',
    value: function sizeComponents() {
      ElementQuery._componentMap.forEach(function (componentOptions, component) {
        componentOptions.onResize({ component: component,
          sizes: componentOptions.sizes,
          node: componentOptions.node
        });
      });
    }
  }, {
    key: 'sizeComponent',
    value: function sizeComponent(_ref2) {
      var component = _ref2.component,
          _ref2$sizes = _ref2.sizes,
          sizes = _ref2$sizes === void 0 ? [] : _ref2$sizes,
          node = _ref2.node;

      if (!node) return;

      var width = node.clientWidth;
      var smallestSize = (0, _lodash6.default)(sizes);

      var matchedSize = '';
      var matchedWidth = smallestSize.width;

      // use Array#some() here because #forEach() has no early exit
      sizes.some(function (test) {
        // check for:
        // 1. the el width is greater or equal to the test width
        // 2. the el width is greater or equal to the min test width
        if (width >= test.width && width >= matchedWidth) {
          matchedSize = test.name;
          matchedWidth = test.width;
          return false;
        }
        // once that condition isn't true, we've found the correct match; bail
        return true;
      });
      component.setSize(matchedSize);
    }

    // becuase we're going to itterate through by size, we need to ensure that the
    // sizes are sorted

  }, {
    key: 'sortSizes',
    value: function sortSizes(sizes) {
      return (0, _lodash4.default)(sizes, 'width');
    }
  }, {
    key: 'onResize',
    value: function onResize() {
      if (ElementQuery._frame) _raf2.default.cancel(ElementQuery._frame);
      ElementQuery._frame = (0, _raf2.default)(ElementQuery.sizeComponents);
    }
  }]);

  return ElementQuery;
}(_react.PureComponent), _class2.propTypes = {
  children: _proptypes2.default.node.isRequired,
  default: _proptypes2.default.string,
  sizes: _proptypes2.default.arrayOf(_proptypes2.default.shape({
    name: _proptypes2.default.string.isRequired,
    width: function width(props, propName, componentName) {
      var size = props[propName];
      if (!(0, _lodash8.default)(size)) {
        return new Error(componentName + ' received a width of `' + size + '` for `' + props.name + '`. A number was expected.');
      }

      if (size === 0) {
        return new Error(componentName + ' received a width of `' + size + '` for `' + props.name + '`. Widths are min-widths, and should be treated as "mobile-first". The default state can be set with the `default` prop, or even better with the "default" styles in CSS.');
      }
      return null;
    }
  })).isRequired,
  makeClassName: _proptypes2.default.func
}, _class2.defaultProps = {
  // if no default is defined, assume no className. This is the default browser
  // behavior
  default: '',
  sizes: [],
  makeClassName: _lodash2.default,
  children: _react2.default.createElement('span', null)
}, _class2._isListening = false, _class2._componentMap = new Map(), _temp), (_applyDecoratedDescriptor(_class.prototype, 'setSize', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'setSize'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'setNode', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'setNode'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'makeChild', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'makeChild'), _class.prototype)), _class);
exports.default = ElementQuery;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qc3giXSwibmFtZXMiOlsiaXNCcm93c2VyIiwid2luZG93IiwiRWxlbWVudFF1ZXJ5IiwicHJvcHMiLCJzdGF0ZSIsInNpemUiLCJkZWZhdWx0Iiwic2l6ZXMiLCJzb3J0U2l6ZXMiLCJyZWdpc3RlciIsImNvbXBvbmVudCIsIm5vZGUiLCJzaXplQ29tcG9uZW50IiwibmV3UHJvcHMiLCJzZXRTdGF0ZSIsInVucmVnaXN0ZXIiLCJjaGlsZCIsImNsYXNzTmFtZSIsImNsYXNzTmFtZXMiLCJleGlzdGluZ0NsYXNzTmFtZSIsInB1c2giLCJqb2luIiwicmVmIiwic2V0Tm9kZSIsIm1ha2VDbGFzc05hbWUiLCJjaGlsZHJlbiIsIkFycmF5IiwiaXNBcnJheSIsImNvdW50IiwibWFrZUNoaWxkIiwib25seSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblJlc2l6ZSIsIl9pc0xpc3RlbmluZyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfY29tcG9uZW50TWFwIiwic2V0IiwibGlzdGVuIiwiZGVsZXRlIiwidW5MaXN0ZW4iLCJmb3JFYWNoIiwiY29tcG9uZW50T3B0aW9ucyIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJzbWFsbGVzdFNpemUiLCJtYXRjaGVkU2l6ZSIsIm1hdGNoZWRXaWR0aCIsInNvbWUiLCJ0ZXN0IiwibmFtZSIsInNldFNpemUiLCJfZnJhbWUiLCJjYW5jZWwiLCJzaXplQ29tcG9uZW50cyIsInByb3BUeXBlcyIsImlzUmVxdWlyZWQiLCJzdHJpbmciLCJhcnJheU9mIiwic2hhcGUiLCJwcm9wTmFtZSIsImNvbXBvbmVudE5hbWUiLCJFcnJvciIsImZ1bmMiLCJkZWZhdWx0UHJvcHMiLCJNYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFF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RCxJQUFwRCxlQUFvRUYsTUFBTThDLElBQTFFLCtCQUFQO0FBQ0Q7O0FBRUQsVUFBSTVDLFNBQVMsQ0FBYixFQUFnQjtBQUNkLGVBQU8sSUFBSXdELEtBQUosQ0FBYUQsYUFBYiw4QkFBb0R2RCxJQUFwRCxlQUFvRUYsTUFBTThDLElBQTFFLCtLQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDtBQVp3QyxHQUFoQixDQUFsQixFQWFMTSxVQWhCYTtBQWlCZi9CLGlCQUFlLG9CQUFVc0M7QUFqQlYsQyxVQW9CWkMsWSxHQUFlO0FBQ3BCO0FBQ0E7QUFDQXpELFdBQVMsRUFIVztBQUlsQkMsU0FBTyxFQUpXO0FBS2xCaUIsaUNBTGtCO0FBTWxCQyxZQUFVO0FBTlEsQyxVQTZDZlEsWSxHQUFlLEssVUFFZkUsYSxHQUFnQixJQUFJNkIsR0FBSixFO2tCQXBFSjlELFkiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHtQdXJlQ29tcG9uZW50LCBDaGlsZHJlbiwgY2xvbmVFbGVtZW50fSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcHR5cGVzJ1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJ2xvZGFzaC5pZGVudGl0eSdcbmltcG9ydCBzb3J0QnkgZnJvbSAnbG9kYXNoLnNvcnRieSdcbmltcG9ydCBmaXJzdCBmcm9tICdsb2Rhc2guZmlyc3QnXG5pbXBvcnQgaXNOdW1iZXIgZnJvbSAnbG9kYXNoLmlzbnVtYmVyJ1xuaW1wb3J0IHJhZiBmcm9tICdyYWYnXG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnYXV0b2JpbmQtZGVjb3JhdG9yJ1xuXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50UXVlcnkgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZFxuICAgICwgZGVmYXVsdDogUHJvcFR5cGVzLnN0cmluZ1xuICAgICwgc2l6ZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICAgICwgd2lkdGg6IChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHByb3BzW3Byb3BOYW1lXVxuICAgICAgICBpZiAoIWlzTnVtYmVyKHNpemUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgJHtjb21wb25lbnROYW1lfSByZWNlaXZlZCBhIHdpZHRoIG9mIFxcYCR7c2l6ZX1cXGAgZm9yIFxcYCR7cHJvcHMubmFtZX1cXGAuIEEgbnVtYmVyIHdhcyBleHBlY3RlZC5gKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGAke2NvbXBvbmVudE5hbWV9IHJlY2VpdmVkIGEgd2lkdGggb2YgXFxgJHtzaXplfVxcYCBmb3IgXFxgJHtwcm9wcy5uYW1lfVxcYC4gV2lkdGhzIGFyZSBtaW4td2lkdGhzLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgXCJtb2JpbGUtZmlyc3RcIi4gVGhlIGRlZmF1bHQgc3RhdGUgY2FuIGJlIHNldCB3aXRoIHRoZSBcXGBkZWZhdWx0XFxgIHByb3AsIG9yIGV2ZW4gYmV0dGVyIHdpdGggdGhlIFwiZGVmYXVsdFwiIHN0eWxlcyBpbiBDU1MuYClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0pKS5pc1JlcXVpcmVkXG4gICAgLCBtYWtlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuZnVuY1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAvLyBpZiBubyBkZWZhdWx0IGlzIGRlZmluZWQsIGFzc3VtZSBubyBjbGFzc05hbWUuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYnJvd3NlclxuICAgIC8vIGJlaGF2aW9yXG4gICAgZGVmYXVsdDogJydcbiAgICAsIHNpemVzOiBbXVxuICAgICwgbWFrZUNsYXNzTmFtZTogaWRlbnRpdHlcbiAgICAsIGNoaWxkcmVuOiA8c3BhbiAvPlxuICB9XG5cbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5zdGF0ZSA9IHtzaXplOiBwcm9wcy5kZWZhdWx0LCBzaXplczogRWxlbWVudFF1ZXJ5LnNvcnRTaXplcyh0aGlzLnByb3BzLnNpemVzKX1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBFbGVtZW50UXVlcnkucmVnaXN0ZXIoe1xuICAgICAgY29tcG9uZW50OiB0aGlzXG4gICAgICAsIHNpemVzOiB0aGlzLnN0YXRlLnNpemVzXG4gICAgICAsIG5vZGU6IHRoaXMubm9kZVxuICAgIH0pXG5cbiAgICBFbGVtZW50UXVlcnkuc2l6ZUNvbXBvbmVudCh7XG4gICAgICBjb21wb25lbnQ6IHRoaXNcbiAgICAgICwgc2l6ZXM6IHRoaXMuc3RhdGUuc2l6ZXNcbiAgICAgICwgbm9kZTogdGhpcy5ub2RlXG4gICAgfSlcblxuICAgIC8vIHdhaXQgYSBmZXcgZnJhbWVzIHRoZW4gY2hlY2sgc2l6ZXMgYWdhaW5cbiAgICByYWYoKCkgPT4gcmFmKCgpID0+IHtcbiAgICAgIEVsZW1lbnRRdWVyeS5zaXplQ29tcG9uZW50KHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzXG4gICAgICAgICwgc2l6ZXM6IHRoaXMuc3RhdGUuc2l6ZXNcbiAgICAgICAgLCBub2RlOiB0aGlzLm5vZGVcbiAgICAgIH0pXG4gICAgfSkpXG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXdQcm9wcykge1xuICAgIHRoaXMuc2V0U3RhdGUoe3NpemVzOiBFbGVtZW50UXVlcnkuc29ydFNpemVzKG5ld1Byb3BzLnNpemVzKX0pXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgRWxlbWVudFF1ZXJ5LnVucmVnaXN0ZXIodGhpcylcbiAgfVxuXG4gIHN0YXRpYyBfaXNMaXN0ZW5pbmcgPSBmYWxzZVxuXG4gIHN0YXRpYyBfY29tcG9uZW50TWFwID0gbmV3IE1hcCgpXG5cbiAgLy8gdXNlIG9ubHkgb25lIGdsb2JhbCBsaXN0ZW5lciDigKYgZm9yIHBlcmYhXG4gIHN0YXRpYyBsaXN0ZW4gKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBFbGVtZW50UXVlcnkub25SZXNpemUpXG4gICAgRWxlbWVudFF1ZXJ5Ll9pc0xpc3RlbmluZyA9IHRydWVcbiAgfVxuXG4gIHN0YXRpYyB1bkxpc3RlbiAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIEVsZW1lbnRRdWVyeS5vblJlc2l6ZSlcbiAgICBFbGVtZW50UXVlcnkuX2lzTGlzdGVuaW5nID0gZmFsc2VcbiAgfVxuXG4gIHN0YXRpYyByZWdpc3RlciAoe2NvbXBvbmVudCwgc2l6ZXMsIG9uUmVzaXplLCBub2RlfSkge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm5cblxuICAgIEVsZW1lbnRRdWVyeS5fY29tcG9uZW50TWFwLnNldChjb21wb25lbnQsIHtcbiAgICAgIHNpemVzXG4gICAgICAsIG5vZGVcbiAgICAgIC8vIGlmIGEgY3VzdG9tIG9uUmVzaXplIGNhbGxiYWNrIGlzIHBhc3NlZCwgZS5nLiB1c2luZyB0aGlzIGxpYiBqdXN0IGZvclxuICAgICAgLy8gdGhlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciwgdXNlIHRoYXQuIEVsc2UsIGFzc3VtZSB3ZSdyZSBzaXppbmcgdGhlXG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgICwgb25SZXNpemU6IG9uUmVzaXplIHx8IEVsZW1lbnRRdWVyeS5zaXplQ29tcG9uZW50XG4gICAgfSlcblxuICAgIGlmICghRWxlbWVudFF1ZXJ5Ll9pc0xpc3RlbmluZyAmJiBpc0Jyb3dzZXIpIEVsZW1lbnRRdWVyeS5saXN0ZW4oKVxuICB9XG5cbiAgc3RhdGljIHVucmVnaXN0ZXIgKGNvbXBvbmVudCkge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm5cblxuICAgIEVsZW1lbnRRdWVyeS5fY29tcG9uZW50TWFwLmRlbGV0ZShjb21wb25lbnQpXG4gICAgaWYgKCFFbGVtZW50UXVlcnkuX2NvbXBvbmVudE1hcC5zaXplICYmIGlzQnJvd3NlcikgRWxlbWVudFF1ZXJ5LnVuTGlzdGVuKClcbiAgfVxuXG4gIHN0YXRpYyBzaXplQ29tcG9uZW50cyAoKSB7XG4gICAgRWxlbWVudFF1ZXJ5Ll9jb21wb25lbnRNYXAuZm9yRWFjaCgoY29tcG9uZW50T3B0aW9ucywgY29tcG9uZW50KSA9PiB7XG4gICAgICBjb21wb25lbnRPcHRpb25zLm9uUmVzaXplKHtjb21wb25lbnRcbiAgICAgICAgLCBzaXplczogY29tcG9uZW50T3B0aW9ucy5zaXplc1xuICAgICAgICAsIG5vZGU6IGNvbXBvbmVudE9wdGlvbnMubm9kZVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIHNpemVDb21wb25lbnQgKHtjb21wb25lbnQsIHNpemVzID0gW10sIG5vZGV9KSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm5cblxuICAgIGNvbnN0IHdpZHRoID0gbm9kZS5jbGllbnRXaWR0aFxuICAgIGNvbnN0IHNtYWxsZXN0U2l6ZSA9IGZpcnN0KHNpemVzKVxuXG4gICAgbGV0IG1hdGNoZWRTaXplID0gJydcbiAgICBsZXQgbWF0Y2hlZFdpZHRoID0gc21hbGxlc3RTaXplLndpZHRoXG5cbiAgICAvLyB1c2UgQXJyYXkjc29tZSgpIGhlcmUgYmVjYXVzZSAjZm9yRWFjaCgpIGhhcyBubyBlYXJseSBleGl0XG4gICAgc2l6ZXMuc29tZSgodGVzdCkgPT4ge1xuICAgICAgLy8gY2hlY2sgZm9yOlxuICAgICAgLy8gMS4gdGhlIGVsIHdpZHRoIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gdGhlIHRlc3Qgd2lkdGhcbiAgICAgIC8vIDIuIHRoZSBlbCB3aWR0aCBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZSBtaW4gdGVzdCB3aWR0aFxuICAgICAgaWYgKHdpZHRoID49IHRlc3Qud2lkdGggJiYgd2lkdGggPj0gbWF0Y2hlZFdpZHRoKSB7XG4gICAgICAgIG1hdGNoZWRTaXplID0gdGVzdC5uYW1lXG4gICAgICAgIG1hdGNoZWRXaWR0aCA9IHRlc3Qud2lkdGhcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvLyBvbmNlIHRoYXQgY29uZGl0aW9uIGlzbid0IHRydWUsIHdlJ3ZlIGZvdW5kIHRoZSBjb3JyZWN0IG1hdGNoOyBiYWlsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgY29tcG9uZW50LnNldFNpemUobWF0Y2hlZFNpemUpXG4gIH1cblxuICAvLyBiZWN1YXNlIHdlJ3JlIGdvaW5nIHRvIGl0dGVyYXRlIHRocm91Z2ggYnkgc2l6ZSwgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGVcbiAgLy8gc2l6ZXMgYXJlIHNvcnRlZFxuICBzdGF0aWMgc29ydFNpemVzIChzaXplcykge1xuICAgIHJldHVybiBzb3J0Qnkoc2l6ZXMsICd3aWR0aCcpXG4gIH1cblxuICBAYXV0b2JpbmRcbiAgc2V0U2l6ZSAoc2l6ZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe3NpemV9KVxuICB9XG5cbiAgQGF1dG9iaW5kXG4gIHNldE5vZGUgKG5vZGUpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlXG4gIH1cblxuICBAYXV0b2JpbmRcbiAgbWFrZUNoaWxkIChjaGlsZCwgY2xhc3NOYW1lKSB7XG4gICAgLy8ganVzdCBhZGQgb3VyIG5ldyBjbGFzcyBuYW1lIG9udG8gdGhlIGNoaWxyZW4sIHRoaXMgYWxsZXZpYXRlcyB0aGUgbmVlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHdyYXBwZXIgZGl2XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IFtdXG4gICAgY29uc3QgZXhpc3RpbmdDbGFzc05hbWUgPSBjaGlsZC5wcm9wcy5jbGFzc05hbWVcbiAgICBpZiAoZXhpc3RpbmdDbGFzc05hbWUpIGNsYXNzTmFtZXMucHVzaChleGlzdGluZ0NsYXNzTmFtZSlcbiAgICBpZiAoY2xhc3NOYW1lKSBjbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKVxuXG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKVxuICAgICAgLCByZWY6IHRoaXMuc2V0Tm9kZVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgb25SZXNpemUgKCkge1xuICAgIGlmIChFbGVtZW50UXVlcnkuX2ZyYW1lKSByYWYuY2FuY2VsKEVsZW1lbnRRdWVyeS5fZnJhbWUpXG4gICAgRWxlbWVudFF1ZXJ5Ll9mcmFtZSA9IHJhZihFbGVtZW50UXVlcnkuc2l6ZUNvbXBvbmVudHMpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHNpemUgPSBpc0Jyb3dzZXJcbiAgICAgID8gdGhpcy5zdGF0ZS5zaXplXG4gICAgICA6IHRoaXMucHJvcHMuZGVmYXVsdFxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHNpemUgPyB0aGlzLnByb3BzLm1ha2VDbGFzc05hbWUoc2l6ZSkgOiAnJ1xuICAgIGNvbnN0IHtjaGlsZHJlbn0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBDaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDFcbiAgICAgID8gY2hpbGRyZW5bMF1cbiAgICAgIDogY2hpbGRyZW5cblxuICAgIC8vIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8ganVzdCBhcHBseSB0aGUgY2xhc3NOYW1lIG9udG8gdGhlIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBvbmx5IGFjY2VwdCBvbmUuIFJlYWN0IGRvZXNuJ3QgbGV0IHVzIHJldHVybiBhbiBhcnJheSBvZiBjaGlsZHJlbi5cbiAgICAvLyByZXR1cm5pbmcgYSB3cmFwcGVyIGRpdiBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIGl0IGNyZWF0ZXMgdW4tZXhwZWN0ZWQgRE9NXG4gICAgLy8gbGlrZSByZWFsIGVsZW1lbnQgcXVlcmllcywgdGhpcyBlbmFibGVzIHRoZSB1c2VyIHRvIGRvIHRoaW5ncyBsaWtlIHdyYXBcbiAgICAvLyBhbiBgPGxpPmAgaW4gYW4gZWxlbWVudCBxdWVyeSBhbmQgbm90IGJyZWFrIEhUTUwgc2VtYW50aWNzLCBvciB1c2VcbiAgICAvLyBlbGVtZW50IHF1ZXJ5IGFuZCBub3QgYnJlYWsgZXhwZWN0YXRpb25zIGFyb3VuZCB0aGluZ3MgbGlrZSBmbGV4Ym94LlxuICAgIHJldHVybiB0aGlzLm1ha2VDaGlsZChDaGlsZHJlbi5vbmx5KGNoaWxkKSwgY2xhc3NOYW1lKVxuICB9XG59XG4iXX0=