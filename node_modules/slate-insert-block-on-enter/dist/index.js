'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slate = require('slate');

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:insert-block-on-enter');

/**
 * A Slate plugin to insert a spesific node when enter is hit on a void node.
 *
 * @param {Mixed} ...args
 * @return {Object}
 */

function InsertBlockOnEnterPlugin() {
  var createBlockProps = void 0;
  var blockInputProps = arguments.length <= 0 ? undefined : arguments[0];

  createBlockProps = typeof blockInputProps == 'string' ? { type: createBlockProps } : _extends({}, createBlockProps);

  /**
    *
    * @param {Event} e
    * @param {Object} data
    * @param {State} state
    * @return {State}
    */

  function onKeyDown(e, data, change) {
    if (data.key === 'enter') {
      var state = change.state;
      var document = state.document,
          startKey = state.startKey,
          startBlock = state.startBlock;


      if (startBlock && startBlock.isVoid) {
        var nextBlock = document.getNextBlock(startKey);
        var prevBlock = document.getPreviousBlock(startKey);
        var isFocusedStart = state.selection.hasEdgeAtStartOf(startBlock);
        var isFocusedEnd = state.selection.hasEdgeAtEndOf(startBlock);

        // Void block at the end of the document
        if (!nextBlock) {
          if (isFocusedEnd) {
            debug('no nextBlock, PrevBlock, isFocusedEnd');
            return change.collapseToEndOf(startBlock).insertBlock(blockInputProps, { replaceEmpty: false }).collapseToEnd();
          }
          if (prevBlock) {
            debug('no nextBlock, PrevBlock, isFocusedStart');
            return change.collapseToEndOf(prevBlock).insertBlock(blockInputProps, { replaceEmpty: false }).collapseToStartOf(startBlock);
          }
          debug('no nextBlock, no PrevBlock');
          return change.collapseToStartOf(startBlock).insertBlock(blockInputProps, { replaceEmpty: false }).moveNodeByKey(startBlock.key, document.key, 1).collapseToStartOfNextBlock();
        }
        // Void block between two blocks
        if (nextBlock && prevBlock) {
          if (isFocusedStart) {
            debug('nextBlock, prevBlock, isFocusedStart');
            var index = document.nodes.indexOf(prevBlock);
            return change.collapseToEndOf(prevBlock).insertBlock(blockInputProps, { replaceEmpty: false }).collapseToStartOf(startBlock);
          }
          debug('nextBlock, prevBlock, isFocusedEnd');
          return change.collapseToEndOf(startBlock).insertBlock(blockInputProps, { replaceEmpty: false }).collapseToEnd();
        }
        // Void block in the beginning of the document
        if (nextBlock && !prevBlock) {
          if (isFocusedStart) {
            debug('nextBlock, no prevBlock, isFocusedStart');
            return change.collapseToStartOf(startBlock).insertBlock(blockInputProps, { replaceEmpty: false }).moveNodeByKey(startBlock.key, document.key, 1).collapseToStartOfNextBlock();
          }
          debug('nextBlock, no prevBlock, isFocusedEnd');
          return change.collapseToEndOf(startBlock).insertBlock(blockInputProps, { replaceEmpty: false });
        }
      }
    }
  }

  /**
   * Return the plugin.
   */

  return {
    onKeyDown: onKeyDown
  };
}

/**
 * Export.
 */

exports.default = InsertBlockOnEnterPlugin;