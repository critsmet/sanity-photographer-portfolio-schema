'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _transforms = require('../transforms');

var _transforms2 = _interopRequireDefault(_transforms);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:transform');

/**
 * Transform.
 *
 * @type {Transform}
 */

var Transform = function () {

  /**
   * Constructor.
   *
   * @param {Object} properties
   *   @property {State} state
   */

  function Transform(properties) {
    _classCallCheck(this, Transform);

    var state = properties.state;

    this.state = state;
    this.operations = [];
  }

  /**
   * Get the kind.
   *
   * @return {String}
   */

  _createClass(Transform, [{
    key: 'apply',


    /**
     * Apply the transform and return the new state.
     *
     * @param {Object} options
     *   @property {Boolean} merge
     *   @property {Boolean} save
     * @return {State}
     */

    value: function apply() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var transform = this;
      var merge = options.merge,
          save = options.save;

      // Ensure that the selection is normalized.

      transform.normalizeSelection();

      var state = transform.state,
          operations = transform.operations;
      var history = state.history;
      var undos = history.undos;

      var previous = undos.peek();

      // If there are no operations, abort early.
      if (!operations.length) return state;

      // If there's a previous save point, determine if the new operations should
      // be merged into the previous ones.
      if (previous && merge == null) {
        merge = isOnlySelections(operations) || isContiguousInserts(operations, previous) || isContiguousRemoves(operations, previous);
      }

      // If the save flag isn't set, determine whether we should save.
      if (save == null) {
        save = !isOnlySelections(operations);
      }

      // Save the new operations.
      if (save) this.save({ merge: merge });

      // Return the new state.
      return this.state;
    }
  }, {
    key: 'kind',
    get: function get() {
      return 'transform';
    }
  }]);

  return Transform;
}();

/**
 * Add a transform method for each of the transforms.
 */

Object.keys(_transforms2.default).forEach(function (type) {
  Transform.prototype[type] = function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    debug(type, { args: args });
    _transforms2.default[type].apply(_transforms2.default, [this].concat(args));
    return this;
  };
});

/**
 * Check whether a list of `operations` only contains selection operations.
 *
 * @param {Array} operations
 * @return {Boolean}
 */

function isOnlySelections(operations) {
  return operations.every(function (op) {
    return op.type == 'set_selection';
  });
}

/**
 * Check whether a list of `operations` and a list of `previous` operations are
 * contiguous text insertions.
 *
 * @param {Array} operations
 * @param {Array} previous
 */

function isContiguousInserts(operations, previous) {
  var edits = operations.filter(function (op) {
    return op.type != 'set_selection';
  });
  var prevEdits = previous.filter(function (op) {
    return op.type != 'set_selection';
  });
  if (!edits.length || !prevEdits.length) return false;

  var onlyInserts = edits.every(function (op) {
    return op.type == 'insert_text';
  });
  var prevOnlyInserts = prevEdits.every(function (op) {
    return op.type == 'insert_text';
  });
  if (!onlyInserts || !prevOnlyInserts) return false;

  var first = edits[0];
  var last = prevEdits[prevEdits.length - 1];
  if (first.key != last.key) return false;
  if (first.offset != last.offset + last.text.length) return false;

  return true;
}

/**
 * Check whether a list of `operations` and a list of `previous` operations are
 * contiguous text removals.
 *
 * @param {Array} operations
 * @param {Array} previous
 */

function isContiguousRemoves(operations, previous) {
  var edits = operations.filter(function (op) {
    return op.type != 'set_selection';
  });
  var prevEdits = previous.filter(function (op) {
    return op.type != 'set_selection';
  });
  if (!edits.length || !prevEdits.length) return false;

  var onlyRemoves = edits.every(function (op) {
    return op.type == 'remove_text';
  });
  var prevOnlyRemoves = prevEdits.every(function (op) {
    return op.type == 'remove_text';
  });
  if (!onlyRemoves || !prevOnlyRemoves) return false;

  var first = edits[0];
  var last = prevEdits[prevEdits.length - 1];
  if (first.key != last.key) return false;
  if (first.offset + first.length != last.offset) return false;

  return true;
}

/**
 * Export.
 *
 * @type {Transform}
 */

exports.default = Transform;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvdHJhbnNmb3JtLmpzIl0sIm5hbWVzIjpbImRlYnVnIiwiVHJhbnNmb3JtIiwicHJvcGVydGllcyIsInN0YXRlIiwib3BlcmF0aW9ucyIsIm9wdGlvbnMiLCJ0cmFuc2Zvcm0iLCJtZXJnZSIsInNhdmUiLCJub3JtYWxpemVTZWxlY3Rpb24iLCJoaXN0b3J5IiwidW5kb3MiLCJwcmV2aW91cyIsInBlZWsiLCJsZW5ndGgiLCJpc09ubHlTZWxlY3Rpb25zIiwiaXNDb250aWd1b3VzSW5zZXJ0cyIsImlzQ29udGlndW91c1JlbW92ZXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInR5cGUiLCJwcm90b3R5cGUiLCJhcmdzIiwiZXZlcnkiLCJvcCIsImVkaXRzIiwiZmlsdGVyIiwicHJldkVkaXRzIiwib25seUluc2VydHMiLCJwcmV2T25seUluc2VydHMiLCJmaXJzdCIsImxhc3QiLCJrZXkiLCJvZmZzZXQiLCJ0ZXh0Iiwib25seVJlbW92ZXMiLCJwcmV2T25seVJlbW92ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTs7Ozs7O0FBTUEsSUFBTUEsUUFBUSxxQkFBTSxpQkFBTixDQUFkOztBQUVBOzs7Ozs7SUFNTUMsUzs7QUFFSjs7Ozs7OztBQU9BLHFCQUFZQyxVQUFaLEVBQXdCO0FBQUE7O0FBQUEsUUFDZEMsS0FEYyxHQUNKRCxVQURJLENBQ2RDLEtBRGM7O0FBRXRCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsRUFBbEI7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7NEJBU29CO0FBQUEsVUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUNsQixVQUFNQyxZQUFZLElBQWxCO0FBRGtCLFVBRVpDLEtBRlksR0FFSUYsT0FGSixDQUVaRSxLQUZZO0FBQUEsVUFFTEMsSUFGSyxHQUVJSCxPQUZKLENBRUxHLElBRks7O0FBSWxCOztBQUNB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U0csbUJBQVQsQ0FBNkJiLFVBQTdCLEVBQXlDUSxRQUF6QyxFQUFtRDtBQUNqRCxNQUFNYyxRQUFRdEIsV0FBV3VCLE1BQVgsQ0FBa0I7QUFBQSxXQUFNRixHQUFHSixJQUFILElBQVcsZUFBakI7QUFBQSxHQUFsQixDQUFkO0FBQ0EsTUFBTU8sWUFBWWhCLFNBQVNlLE1BQVQsQ0FBZ0I7QUFBQSxXQUFNRixHQUFHSixJQUFILElBQVcsZUFBakI7QUFBQSxHQUFoQixDQUFsQjtBQUNBLE1BQUksQ0FBQ0ssTUFBTVosTUFBUCxJQUFpQixDQUFDYyxVQUFVZCxNQUFoQyxFQUF3QyxPQUFPLEtBQVA7O0FBRXhDLE1BQU1zQixjQUFjVixNQUFNRixLQUFOLENBQVk7QUFBQSxXQUFNQyxHQUFHSixJQUFILElBQVcsYUFBakI7QUFBQSxHQUFaLENBQXBCO0FBQ0EsTUFBTWdCLGtCQUFrQlQsVUFBVUosS0FBVixDQUFnQjtBQUFBLFdBQU1DLEdBQUdKLElBQUgsSUFBVyxhQUFqQjtBQUFBLEdBQWhCLENBQXhCO0FBQ0EsTUFBSSxDQUFDZSxXQUFELElBQWdCLENBQUNDLGVBQXJCLEVBQXNDLE9BQU8sS0FBUDs7QUFFdEMsTUFBTU4sUUFBUUwsTUFBTSxDQUFOLENBQWQ7QUFDQSxNQUFNTSxPQUFPSixVQUFVQSxVQUFVZCxNQUFWLEdBQW1CLENBQTdCLENBQWI7QUFDQSxNQUFJaUIsTUFBTUUsR0FBTixJQUFhRCxLQUFLQyxHQUF0QixFQUEyQixPQUFPLEtBQVA7QUFDM0IsTUFBSUYsTUFBTUcsTUFBTixHQUFlSCxNQUFNakIsTUFBckIsSUFBK0JrQixLQUFLRSxNQUF4QyxFQUFnRCxPQUFPLEtBQVA7O0FBRWhELFNBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7a0JBTWVqQyxTIiwiZmlsZSI6InRyYW5zZm9ybS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IFRyYW5zZm9ybXMgZnJvbSAnLi4vdHJhbnNmb3JtcydcblxuLyoqXG4gKiBEZWJ1Zy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxuY29uc3QgZGVidWcgPSBEZWJ1Zygnc2xhdGU6dHJhbnNmb3JtJylcblxuLyoqXG4gKiBUcmFuc2Zvcm0uXG4gKlxuICogQHR5cGUge1RyYW5zZm9ybX1cbiAqL1xuXG5jbGFzcyBUcmFuc2Zvcm0ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICogICBAcHJvcGVydHkge1N0YXRlfSBzdGF0ZVxuICAgKi9cblxuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gcHJvcGVydGllc1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZVxuICAgIHRoaXMub3BlcmF0aW9ucyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBraW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIGdldCBraW5kKCkge1xuICAgIHJldHVybiAndHJhbnNmb3JtJ1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoZSB0cmFuc2Zvcm0gYW5kIHJldHVybiB0aGUgbmV3IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbWVyZ2VcbiAgICogICBAcHJvcGVydHkge0Jvb2xlYW59IHNhdmVcbiAgICogQHJldHVybiB7U3RhdGV9XG4gICAqL1xuXG4gIGFwcGx5KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXNcbiAgICBsZXQgeyBtZXJnZSwgc2F2ZSB9ID0gb3B0aW9uc1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbGVjdGlvbiBpcyBub3JtYWxpemVkLlxuICAgIHRyYW5zZm9ybS5ub3JtYWxpemVTZWxlY3Rpb24oKVxuXG4gICAgY29uc3QgeyBzdGF0ZSwgb3BlcmF0aW9ucyB9ID0gdHJhbnNmb3JtXG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgdW5kb3MgfSA9IGhpc3RvcnlcbiAgICBjb25zdCBwcmV2aW91cyA9IHVuZG9zLnBlZWsoKVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIG9wZXJhdGlvbnMsIGFib3J0IGVhcmx5LlxuICAgIGlmICghb3BlcmF0aW9ucy5sZW5ndGgpIHJldHVybiBzdGF0ZVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHByZXZpb3VzIHNhdmUgcG9pbnQsIGRldGVybWluZSBpZiB0aGUgbmV3IG9wZXJhdGlvbnMgc2hvdWxkXG4gICAgLy8gYmUgbWVyZ2VkIGludG8gdGhlIHByZXZpb3VzIG9uZXMuXG4gICAgaWYgKHByZXZpb3VzICYmIG1lcmdlID09IG51bGwpIHtcbiAgICAgIG1lcmdlID0gKFxuICAgICAgICBpc09ubHlTZWxlY3Rpb25zKG9wZXJhdGlvbnMpIHx8XG4gICAgICAgIGlzQ29udGlndW91c0luc2VydHMob3BlcmF0aW9ucywgcHJldmlvdXMpIHx8XG4gICAgICAgIGlzQ29udGlndW91c1JlbW92ZXMob3BlcmF0aW9ucywgcHJldmlvdXMpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNhdmUgZmxhZyBpc24ndCBzZXQsIGRldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBzYXZlLlxuICAgIGlmIChzYXZlID09IG51bGwpIHtcbiAgICAgIHNhdmUgPSAhaXNPbmx5U2VsZWN0aW9ucyhvcGVyYXRpb25zKVxuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlIG5ldyBvcGVyYXRpb25zLlxuICAgIGlmIChzYXZlKSB0aGlzLnNhdmUoeyBtZXJnZSB9KVxuXG4gICAgLy8gUmV0dXJuIHRoZSBuZXcgc3RhdGUuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGVcbiAgfVxuXG59XG5cbi8qKlxuICogQWRkIGEgdHJhbnNmb3JtIG1ldGhvZCBmb3IgZWFjaCBvZiB0aGUgdHJhbnNmb3Jtcy5cbiAqL1xuXG5PYmplY3Qua2V5cyhUcmFuc2Zvcm1zKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGVbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGRlYnVnKHR5cGUsIHsgYXJncyB9KVxuICAgIFRyYW5zZm9ybXNbdHlwZV0odGhpcywgLi4uYXJncylcbiAgICByZXR1cm4gdGhpc1xuICB9XG59KVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBsaXN0IG9mIGBvcGVyYXRpb25zYCBvbmx5IGNvbnRhaW5zIHNlbGVjdGlvbiBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG9wZXJhdGlvbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNPbmx5U2VsZWN0aW9ucyhvcGVyYXRpb25zKSB7XG4gIHJldHVybiBvcGVyYXRpb25zLmV2ZXJ5KG9wID0+IG9wLnR5cGUgPT0gJ3NldF9zZWxlY3Rpb24nKVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBsaXN0IG9mIGBvcGVyYXRpb25zYCBhbmQgYSBsaXN0IG9mIGBwcmV2aW91c2Agb3BlcmF0aW9ucyBhcmVcbiAqIGNvbnRpZ3VvdXMgdGV4dCBpbnNlcnRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG9wZXJhdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IHByZXZpb3VzXG4gKi9cblxuZnVuY3Rpb24gaXNDb250aWd1b3VzSW5zZXJ0cyhvcGVyYXRpb25zLCBwcmV2aW91cykge1xuICBjb25zdCBlZGl0cyA9IG9wZXJhdGlvbnMuZmlsdGVyKG9wID0+IG9wLnR5cGUgIT0gJ3NldF9zZWxlY3Rpb24nKVxuICBjb25zdCBwcmV2RWRpdHMgPSBwcmV2aW91cy5maWx0ZXIob3AgPT4gb3AudHlwZSAhPSAnc2V0X3NlbGVjdGlvbicpXG4gIGlmICghZWRpdHMubGVuZ3RoIHx8ICFwcmV2RWRpdHMubGVuZ3RoKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBvbmx5SW5zZXJ0cyA9IGVkaXRzLmV2ZXJ5KG9wID0+IG9wLnR5cGUgPT0gJ2luc2VydF90ZXh0JylcbiAgY29uc3QgcHJldk9ubHlJbnNlcnRzID0gcHJldkVkaXRzLmV2ZXJ5KG9wID0+IG9wLnR5cGUgPT0gJ2luc2VydF90ZXh0JylcbiAgaWYgKCFvbmx5SW5zZXJ0cyB8fCAhcHJldk9ubHlJbnNlcnRzKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBmaXJzdCA9IGVkaXRzWzBdXG4gIGNvbnN0IGxhc3QgPSBwcmV2RWRpdHNbcHJldkVkaXRzLmxlbmd0aCAtIDFdXG4gIGlmIChmaXJzdC5rZXkgIT0gbGFzdC5rZXkpIHJldHVybiBmYWxzZVxuICBpZiAoZmlyc3Qub2Zmc2V0ICE9IGxhc3Qub2Zmc2V0ICsgbGFzdC50ZXh0Lmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgbGlzdCBvZiBgb3BlcmF0aW9uc2AgYW5kIGEgbGlzdCBvZiBgcHJldmlvdXNgIG9wZXJhdGlvbnMgYXJlXG4gKiBjb250aWd1b3VzIHRleHQgcmVtb3ZhbHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3BlcmF0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gcHJldmlvdXNcbiAqL1xuXG5mdW5jdGlvbiBpc0NvbnRpZ3VvdXNSZW1vdmVzKG9wZXJhdGlvbnMsIHByZXZpb3VzKSB7XG4gIGNvbnN0IGVkaXRzID0gb3BlcmF0aW9ucy5maWx0ZXIob3AgPT4gb3AudHlwZSAhPSAnc2V0X3NlbGVjdGlvbicpXG4gIGNvbnN0IHByZXZFZGl0cyA9IHByZXZpb3VzLmZpbHRlcihvcCA9PiBvcC50eXBlICE9ICdzZXRfc2VsZWN0aW9uJylcbiAgaWYgKCFlZGl0cy5sZW5ndGggfHwgIXByZXZFZGl0cy5sZW5ndGgpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IG9ubHlSZW1vdmVzID0gZWRpdHMuZXZlcnkob3AgPT4gb3AudHlwZSA9PSAncmVtb3ZlX3RleHQnKVxuICBjb25zdCBwcmV2T25seVJlbW92ZXMgPSBwcmV2RWRpdHMuZXZlcnkob3AgPT4gb3AudHlwZSA9PSAncmVtb3ZlX3RleHQnKVxuICBpZiAoIW9ubHlSZW1vdmVzIHx8ICFwcmV2T25seVJlbW92ZXMpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGZpcnN0ID0gZWRpdHNbMF1cbiAgY29uc3QgbGFzdCA9IHByZXZFZGl0c1twcmV2RWRpdHMubGVuZ3RoIC0gMV1cbiAgaWYgKGZpcnN0LmtleSAhPSBsYXN0LmtleSkgcmV0dXJuIGZhbHNlXG4gIGlmIChmaXJzdC5vZmZzZXQgKyBmaXJzdC5sZW5ndGggIT0gbGFzdC5vZmZzZXQpIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtUcmFuc2Zvcm19XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3JtXG4iXX0=