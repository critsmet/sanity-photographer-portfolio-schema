'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _normalize = require('../utils/normalize');

var _normalize2 = _interopRequireDefault(_normalize);

var _core = require('../schemas/core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transforms.
 *
 * @type {Object}
 */

var Transforms = {};

/**
 * Add mark to text at `offset` and `length` in node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Number} offset
 * @param {Number} length
 * @param {Mixed} mark
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.addMarkByKey = function (transform, key, offset, length, mark) {
  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

  mark = _normalize2.default.mark(mark);
  var _options$normalize = options.normalize,
      normalize = _options$normalize === undefined ? true : _options$normalize;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.addMarkOperation(path, offset, length, mark);

  if (normalize) {
    var parent = document.getParent(key);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Insert a `node` at `index` in a node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Number} index
 * @param {Node} node
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.insertNodeByKey = function (transform, key, index, node) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var _options$normalize2 = options.normalize,
      normalize = _options$normalize2 === undefined ? true : _options$normalize2;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.insertNodeOperation(path, index, node);

  if (normalize) {
    transform.normalizeNodeByKey(key, _core2.default);
  }
};

/**
 * Insert `text` at `offset` in node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Number} offset
 * @param {String} text
 * @param {Set<Mark>} marks (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.insertTextByKey = function (transform, key, offset, text, marks) {
  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  var _options$normalize3 = options.normalize,
      normalize = _options$normalize3 === undefined ? true : _options$normalize3;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.insertTextOperation(path, offset, text, marks);

  if (normalize) {
    var parent = document.getParent(key);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Join a node by `key` with a node `withKey`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {String} withKey
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.joinNodeByKey = function (transform, key, withKey) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize4 = options.normalize,
      normalize = _options$normalize4 === undefined ? true : _options$normalize4;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);
  var withPath = document.getPath(withKey);

  transform.joinNodeOperation(path, withPath);

  if (normalize) {
    var parent = document.getCommonAncestor(key, withKey);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Move a node by `key` to a new parent by `newKey` and `index`.
 * `newKey` is the key of the container (it can be the document itself)
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {String} newKey
 * @param {Number} index
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.moveNodeByKey = function (transform, key, newKey, newIndex) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var _options$normalize5 = options.normalize,
      normalize = _options$normalize5 === undefined ? true : _options$normalize5;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);
  var newPath = document.getPath(newKey);

  transform.moveNodeOperation(path, newPath, newIndex);

  if (normalize) {
    var parent = document.getCommonAncestor(key, newKey);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Remove mark from text at `offset` and `length` in node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Number} offset
 * @param {Number} length
 * @param {Mark} mark
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.removeMarkByKey = function (transform, key, offset, length, mark) {
  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

  mark = _normalize2.default.mark(mark);
  var _options$normalize6 = options.normalize,
      normalize = _options$normalize6 === undefined ? true : _options$normalize6;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.removeMarkOperation(path, offset, length, mark);

  if (normalize) {
    var parent = document.getParent(key);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Remove a node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.removeNodeByKey = function (transform, key) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$normalize7 = options.normalize,
      normalize = _options$normalize7 === undefined ? true : _options$normalize7;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.removeNodeOperation(path);

  if (normalize) {
    var parent = document.getParent(key);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Remove text at `offset` and `length` in node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Number} offset
 * @param {Number} length
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.removeTextByKey = function (transform, key, offset, length) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var _options$normalize8 = options.normalize,
      normalize = _options$normalize8 === undefined ? true : _options$normalize8;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.removeTextOperation(path, offset, length);

  if (normalize) {
    var block = document.getClosestBlock(key);
    transform.normalizeNodeByKey(block.key, _core2.default);
  }
};

/**
 * Set `properties` on mark on text at `offset` and `length` in node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Number} offset
 * @param {Number} length
 * @param {Mark} mark
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.setMarkByKey = function (transform, key, offset, length, mark, properties) {
  var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};

  mark = _normalize2.default.mark(mark);
  properties = _normalize2.default.markProperties(properties);
  var _options$normalize9 = options.normalize,
      normalize = _options$normalize9 === undefined ? true : _options$normalize9;

  var newMark = mark.merge(properties);
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.setMarkOperation(path, offset, length, mark, newMark);

  if (normalize) {
    var parent = document.getParent(key);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Set `properties` on a node by `key`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Object|String} properties
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.setNodeByKey = function (transform, key, properties) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  properties = _normalize2.default.nodeProperties(properties);
  var _options$normalize10 = options.normalize,
      normalize = _options$normalize10 === undefined ? true : _options$normalize10;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.setNodeOperation(path, properties);

  if (normalize) {
    var node = key === document.key ? document : document.getParent(key);
    transform.normalizeNodeByKey(node.key, _core2.default);
  }
};

/**
 * Split a node by `key` at `offset`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Number} offset
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.splitNodeByKey = function (transform, key, offset) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize11 = options.normalize,
      normalize = _options$normalize11 === undefined ? true : _options$normalize11;
  var state = transform.state;
  var document = state.document;

  var path = document.getPath(key);

  transform.splitNodeAtOffsetOperation(path, offset);

  if (normalize) {
    var parent = document.getParent(key);
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Unwrap content from an inline parent with `properties`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Object|String} properties
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.unwrapInlineByKey = function (transform, key, properties, options) {
  var state = transform.state;
  var document = state.document,
      selection = state.selection;

  var node = document.assertDescendant(key);
  var first = node.getFirstText();
  var last = node.getLastText();
  var range = selection.moveToRangeOf(first, last);
  transform.unwrapInlineAtRange(range, properties, options);
};

/**
 * Unwrap content from a block parent with `properties`.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Object|String} properties
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.unwrapBlockByKey = function (transform, key, properties, options) {
  var state = transform.state;
  var document = state.document,
      selection = state.selection;

  var node = document.assertDescendant(key);
  var first = node.getFirstText();
  var last = node.getLastText();
  var range = selection.moveToRangeOf(first, last);
  transform.unwrapBlockAtRange(range, properties, options);
};

/**
 * Unwrap a single node from its parent.
 *
 * If the node is surrounded with siblings, its parent will be
 * split. If the node is the only child, the parent is removed, and
 * simply replaced by the node itself.  Cannot unwrap a root node.
 *
 * @param {Transform} transform
 * @param {String} key
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.unwrapNodeByKey = function (transform, key) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$normalize12 = options.normalize,
      normalize = _options$normalize12 === undefined ? true : _options$normalize12;
  var state = transform.state;
  var document = state.document;

  var parent = document.getParent(key);
  var node = parent.getChild(key);

  var index = parent.nodes.indexOf(node);
  var isFirst = index === 0;
  var isLast = index === parent.nodes.size - 1;

  var parentParent = document.getParent(parent.key);
  var parentIndex = parentParent.nodes.indexOf(parent);

  if (parent.nodes.size === 1) {
    transform.moveNodeByKey(key, parentParent.key, parentIndex, { normalize: false });
    transform.removeNodeByKey(parent.key, options);
  } else if (isFirst) {
    // Just move the node before its parent.
    transform.moveNodeByKey(key, parentParent.key, parentIndex, options);
  } else if (isLast) {
    // Just move the node after its parent.
    transform.moveNodeByKey(key, parentParent.key, parentIndex + 1, options);
  } else {
    var parentPath = document.getPath(parent.key);
    // Split the parent.
    transform.splitNodeOperation(parentPath, index);
    // Extract the node in between the splitted parent.
    transform.moveNodeByKey(key, parentParent.key, parentIndex + 1, { normalize: false });

    if (normalize) {
      transform.normalizeNodeByKey(parentParent.key, _core2.default);
    }
  }
};

/**
 * Wrap a node in an inline with `properties`.
 *
 * @param {Transform} transform
 * @param {String} key The node to wrap
 * @param {Block|Object|String} inline The wrapping inline (its children are discarded)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.wrapInlineByKey = function (transform, key, inline, options) {
  inline = _normalize2.default.inline(inline);
  inline = inline.set('nodes', inline.nodes.clear());

  var document = transform.state.document;

  var node = document.assertDescendant(key);
  var parent = document.getParent(node.key);
  var index = parent.nodes.indexOf(node);

  transform.insertNodeByKey(parent.key, index, inline, { normalize: false });
  transform.moveNodeByKey(node.key, inline.key, 0, options);
};

/**
 * Wrap a node in a block with `properties`.
 *
 * @param {Transform} transform
 * @param {String} key The node to wrap
 * @param {Block|Object|String} block The wrapping block (its children are discarded)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.wrapBlockByKey = function (transform, key, block, options) {
  block = _normalize2.default.block(block);
  block = block.set('nodes', block.nodes.clear());

  var document = transform.state.document;

  var node = document.assertDescendant(key);
  var parent = document.getParent(node.key);
  var index = parent.nodes.indexOf(node);

  transform.insertNodeByKey(parent.key, index, block, { normalize: false });
  transform.moveNodeByKey(node.key, block.key, 0, options);
};

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Transforms;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zL2J5LWtleS5qcyJdLCJuYW1lcyI6WyJUcmFuc2Zvcm1zIiwiYWRkTWFya0J5S2V5IiwidHJhbnNmb3JtIiwia2V5Iiwib2Zmc2V0IiwibGVuZ3RoIiwibWFyayIsIm9wdGlvbnMiLCJub3JtYWxpemUiLCJzdGF0ZSIsImRvY3VtZW50IiwicGF0aCIsImdldFBhdGgiLCJhZGRNYXJrT3BlcmF0aW9uIiwicGFyZW50IiwiZ2V0UGFyZW50Iiwibm9ybWFsaXplTm9kZUJ5S2V5IiwiaW5zZXJ0Tm9kZUJ5S2V5IiwiaW5kZXgiLCJub2RlIiwiaW5zZXJ0Tm9kZU9wZXJhdGlvbiIsImluc2VydFRleHRCeUtleSIsInRleHQiLCJtYXJrcyIsImluc2VydFRleHRPcGVyYXRpb24iLCJqb2luTm9kZUJ5S2V5Iiwid2l0aEtleSIsIndpdGhQYXRoIiwiam9pbk5vZGVPcGVyYXRpb24iLCJnZXRDb21tb25BbmNlc3RvciIsIm1vdmVOb2RlQnlLZXkiLCJuZXdLZXkiLCJuZXdJbmRleCIsIm5ld1BhdGgiLCJtb3ZlTm9kZU9wZXJhdGlvbiIsInJlbW92ZU1hcmtCeUtleSIsInJlbW92ZU1hcmtPcGVyYXRpb24iLCJyZW1vdmVOb2RlQnlLZXkiLCJyZW1vdmVOb2RlT3BlcmF0aW9uIiwicmVtb3ZlVGV4dEJ5S2V5IiwicmVtb3ZlVGV4dE9wZXJhdGlvbiIsImJsb2NrIiwiZ2V0Q2xvc2VzdEJsb2NrIiwic2V0TWFya0J5S2V5IiwicHJvcGVydGllcyIsIm1hcmtQcm9wZXJ0aWVzIiwibmV3TWFyayIsIm1lcmdlIiwic2V0TWFya09wZXJhdGlvbiIsInNldE5vZGVCeUtleSIsIm5vZGVQcm9wZXJ0aWVzIiwic2V0Tm9kZU9wZXJhdGlvbiIsInNwbGl0Tm9kZUJ5S2V5Iiwic3BsaXROb2RlQXRPZmZzZXRPcGVyYXRpb24iLCJ1bndyYXBJbmxpbmVCeUtleSIsInNlbGVjdGlvbiIsImFzc2VydERlc2NlbmRhbnQiLCJmaXJzdCIsImdldEZpcnN0VGV4dCIsImxhc3QiLCJnZXRMYXN0VGV4dCIsInJhbmdlIiwibW92ZVRvUmFuZ2VPZiIsInVud3JhcElubGluZUF0UmFuZ2UiLCJ1bndyYXBCbG9ja0J5S2V5IiwidW53cmFwQmxvY2tBdFJhbmdlIiwidW53cmFwTm9kZUJ5S2V5IiwiZ2V0Q2hpbGQiLCJub2RlcyIsImluZGV4T2YiLCJpc0ZpcnN0IiwiaXNMYXN0Iiwic2l6ZSIsInBhcmVudFBhcmVudCIsInBhcmVudEluZGV4IiwicGFyZW50UGF0aCIsInNwbGl0Tm9kZU9wZXJhdGlvbiIsIndyYXBJbmxpbmVCeUtleSIsImlubGluZSIsInNldCIsImNsZWFyIiwid3JhcEJsb2NrQnlLZXkiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNQSxhQUFhLEVBQW5COztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQUEsV0FBV0MsWUFBWCxHQUEwQixVQUFDQyxTQUFELEVBQVlDLEdBQVosRUFBaUJDLE1BQWpCLEVBQXlCQyxNQUF6QixFQUFpQ0MsSUFBakMsRUFBd0Q7QUFBQSxNQUFqQkMsT0FBaUIsdUVBQVAsRUFBTzs7QUFDaEZELFNBQU8sb0JBQVVBLElBQVYsQ0FBZUEsSUFBZixDQUFQO0FBRGdGLDJCQUVuREMsT0FGbUQsQ0FFeEVDLFNBRndFO0FBQUEsTUFFeEVBLFNBRndFLHNDQUU1RCxJQUY0RDtBQUFBLE1BR3hFQyxLQUh3RSxHQUc5RFAsU0FIOEQsQ0FHeEVPLEtBSHdFO0FBQUEsTUFJeEVDLFFBSndFLEdBSTNERCxLQUoyRCxDQUl4RUMsUUFKd0U7O0FBS2hGLE1BQU1DLE9BQU9ELFNBQVNFLE9BQVQsQ0FBaUJULEdBQWpCLENBQWI7O0FBRUFELFlBQVVXLGdCQUFWLENBQTJCRixJQUEzQixFQUFpQ1AsTUFBakMsRUFBeUNDLE1BQXpDLEVBQWlEQyxJQUFqRDs7QUFFQSxNQUFJRSxTQUFKLEVBQWU7QUFDYixRQUFNTSxTQUFTSixTQUFTSyxTQUFULENBQW1CWixHQUFuQixDQUFmO0FBQ0FE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RDs7QUFhQTs7Ozs7O2tCQU1lUCxVIiwiZmlsZSI6ImJ5LWtleS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IE5vcm1hbGl6ZSBmcm9tICcuLi91dGlscy9ub3JtYWxpemUnXG5pbXBvcnQgU0NIRU1BIGZyb20gJy4uL3NjaGVtYXMvY29yZSdcblxuLyoqXG4gKiBUcmFuc2Zvcm1zLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgVHJhbnNmb3JtcyA9IHt9XG5cbi8qKlxuICogQWRkIG1hcmsgdG8gdGV4dCBhdCBgb2Zmc2V0YCBhbmQgYGxlbmd0aGAgaW4gbm9kZSBieSBga2V5YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge01peGVkfSBtYXJrXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuYWRkTWFya0J5S2V5ID0gKHRyYW5zZm9ybSwga2V5LCBvZmZzZXQsIGxlbmd0aCwgbWFyaywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIG1hcmsgPSBOb3JtYWxpemUubWFyayhtYXJrKVxuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHBhdGggPSBkb2N1bWVudC5nZXRQYXRoKGtleSlcblxuICB0cmFuc2Zvcm0uYWRkTWFya09wZXJhdGlvbihwYXRoLCBvZmZzZXQsIGxlbmd0aCwgbWFyaylcblxuICBpZiAobm9ybWFsaXplKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50KGtleSlcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KHBhcmVudC5rZXksIFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIEluc2VydCBhIGBub2RlYCBhdCBgaW5kZXhgIGluIGEgbm9kZSBieSBga2V5YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmluc2VydE5vZGVCeUtleSA9ICh0cmFuc2Zvcm0sIGtleSwgaW5kZXgsIG5vZGUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHBhdGggPSBkb2N1bWVudC5nZXRQYXRoKGtleSlcblxuICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZU9wZXJhdGlvbihwYXRoLCBpbmRleCwgbm9kZSlcblxuICBpZiAobm9ybWFsaXplKSB7XG4gICAgdHJhbnNmb3JtLm5vcm1hbGl6ZU5vZGVCeUtleShrZXksIFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIEluc2VydCBgdGV4dGAgYXQgYG9mZnNldGAgaW4gbm9kZSBieSBga2V5YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtTZXQ8TWFyaz59IG1hcmtzIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy5pbnNlcnRUZXh0QnlLZXkgPSAodHJhbnNmb3JtLCBrZXksIG9mZnNldCwgdGV4dCwgbWFya3MsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHBhdGggPSBkb2N1bWVudC5nZXRQYXRoKGtleSlcblxuICB0cmFuc2Zvcm0uaW5zZXJ0VGV4dE9wZXJhdGlvbihwYXRoLCBvZmZzZXQsIHRleHQsIG1hcmtzKVxuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQoa2V5KVxuICAgIHRyYW5zZm9ybS5ub3JtYWxpemVOb2RlQnlLZXkocGFyZW50LmtleSwgU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogSm9pbiBhIG5vZGUgYnkgYGtleWAgd2l0aCBhIG5vZGUgYHdpdGhLZXlgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB3aXRoS2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuam9pbk5vZGVCeUtleSA9ICh0cmFuc2Zvcm0sIGtleSwgd2l0aEtleSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgcGF0aCA9IGRvY3VtZW50LmdldFBhdGgoa2V5KVxuICBjb25zdCB3aXRoUGF0aCA9IGRvY3VtZW50LmdldFBhdGgod2l0aEtleSlcblxuICB0cmFuc2Zvcm0uam9pbk5vZGVPcGVyYXRpb24ocGF0aCwgd2l0aFBhdGgpXG5cbiAgaWYgKG5vcm1hbGl6ZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmdldENvbW1vbkFuY2VzdG9yKGtleSwgd2l0aEtleSlcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KHBhcmVudC5rZXksIFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIE1vdmUgYSBub2RlIGJ5IGBrZXlgIHRvIGEgbmV3IHBhcmVudCBieSBgbmV3S2V5YCBhbmQgYGluZGV4YC5cbiAqIGBuZXdLZXlgIGlzIHRoZSBrZXkgb2YgdGhlIGNvbnRhaW5lciAoaXQgY2FuIGJlIHRoZSBkb2N1bWVudCBpdHNlbGYpXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IG5ld0tleVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMubW92ZU5vZGVCeUtleSA9ICh0cmFuc2Zvcm0sIGtleSwgbmV3S2V5LCBuZXdJbmRleCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgcGF0aCA9IGRvY3VtZW50LmdldFBhdGgoa2V5KVxuICBjb25zdCBuZXdQYXRoID0gZG9jdW1lbnQuZ2V0UGF0aChuZXdLZXkpXG5cbiAgdHJhbnNmb3JtLm1vdmVOb2RlT3BlcmF0aW9uKHBhdGgsIG5ld1BhdGgsIG5ld0luZGV4KVxuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRDb21tb25BbmNlc3RvcihrZXksIG5ld0tleSlcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KHBhcmVudC5rZXksIFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBtYXJrIGZyb20gdGV4dCBhdCBgb2Zmc2V0YCBhbmQgYGxlbmd0aGAgaW4gbm9kZSBieSBga2V5YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge01hcmt9IG1hcmtcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy5yZW1vdmVNYXJrQnlLZXkgPSAodHJhbnNmb3JtLCBrZXksIG9mZnNldCwgbGVuZ3RoLCBtYXJrLCBvcHRpb25zID0ge30pID0+IHtcbiAgbWFyayA9IE5vcm1hbGl6ZS5tYXJrKG1hcmspXG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgcGF0aCA9IGRvY3VtZW50LmdldFBhdGgoa2V5KVxuXG4gIHRyYW5zZm9ybS5yZW1vdmVNYXJrT3BlcmF0aW9uKHBhdGgsIG9mZnNldCwgbGVuZ3RoLCBtYXJrKVxuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQoa2V5KVxuICAgIHRyYW5zZm9ybS5ub3JtYWxpemVOb2RlQnlLZXkocGFyZW50LmtleSwgU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgbm9kZSBieSBga2V5YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMucmVtb3ZlTm9kZUJ5S2V5ID0gKHRyYW5zZm9ybSwga2V5LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCBwYXRoID0gZG9jdW1lbnQuZ2V0UGF0aChrZXkpXG5cbiAgdHJhbnNmb3JtLnJlbW92ZU5vZGVPcGVyYXRpb24ocGF0aClcblxuICBpZiAobm9ybWFsaXplKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50KGtleSlcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KHBhcmVudC5rZXksIFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSB0ZXh0IGF0IGBvZmZzZXRgIGFuZCBgbGVuZ3RoYCBpbiBub2RlIGJ5IGBrZXlgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy5yZW1vdmVUZXh0QnlLZXkgPSAodHJhbnNmb3JtLCBrZXksIG9mZnNldCwgbGVuZ3RoLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCBwYXRoID0gZG9jdW1lbnQuZ2V0UGF0aChrZXkpXG5cbiAgdHJhbnNmb3JtLnJlbW92ZVRleHRPcGVyYXRpb24ocGF0aCwgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgaWYgKG5vcm1hbGl6ZSkge1xuICAgIGNvbnN0IGJsb2NrID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdEJsb2NrKGtleSlcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KGJsb2NrLmtleSwgU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogU2V0IGBwcm9wZXJ0aWVzYCBvbiBtYXJrIG9uIHRleHQgYXQgYG9mZnNldGAgYW5kIGBsZW5ndGhgIGluIG5vZGUgYnkgYGtleWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtNYXJrfSBtYXJrXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuc2V0TWFya0J5S2V5ID0gKHRyYW5zZm9ybSwga2V5LCBvZmZzZXQsIGxlbmd0aCwgbWFyaywgcHJvcGVydGllcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIG1hcmsgPSBOb3JtYWxpemUubWFyayhtYXJrKVxuICBwcm9wZXJ0aWVzID0gTm9ybWFsaXplLm1hcmtQcm9wZXJ0aWVzKHByb3BlcnRpZXMpXG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCBuZXdNYXJrID0gbWFyay5tZXJnZShwcm9wZXJ0aWVzKVxuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgcGF0aCA9IGRvY3VtZW50LmdldFBhdGgoa2V5KVxuXG4gIHRyYW5zZm9ybS5zZXRNYXJrT3BlcmF0aW9uKHBhdGgsIG9mZnNldCwgbGVuZ3RoLCBtYXJrLCBuZXdNYXJrKVxuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQoa2V5KVxuICAgIHRyYW5zZm9ybS5ub3JtYWxpemVOb2RlQnlLZXkocGFyZW50LmtleSwgU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogU2V0IGBwcm9wZXJ0aWVzYCBvbiBhIG5vZGUgYnkgYGtleWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuc2V0Tm9kZUJ5S2V5ID0gKHRyYW5zZm9ybSwga2V5LCBwcm9wZXJ0aWVzLCBvcHRpb25zID0ge30pID0+IHtcbiAgcHJvcGVydGllcyA9IE5vcm1hbGl6ZS5ub2RlUHJvcGVydGllcyhwcm9wZXJ0aWVzKVxuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHBhdGggPSBkb2N1bWVudC5nZXRQYXRoKGtleSlcblxuICB0cmFuc2Zvcm0uc2V0Tm9kZU9wZXJhdGlvbihwYXRoLCBwcm9wZXJ0aWVzKVxuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICBjb25zdCBub2RlID0ga2V5ID09PSBkb2N1bWVudC5rZXkgPyBkb2N1bWVudCA6IGRvY3VtZW50LmdldFBhcmVudChrZXkpXG4gICAgdHJhbnNmb3JtLm5vcm1hbGl6ZU5vZGVCeUtleShub2RlLmtleSwgU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogU3BsaXQgYSBub2RlIGJ5IGBrZXlgIGF0IGBvZmZzZXRgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy5zcGxpdE5vZGVCeUtleSA9ICh0cmFuc2Zvcm0sIGtleSwgb2Zmc2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCBwYXRoID0gZG9jdW1lbnQuZ2V0UGF0aChrZXkpXG5cbiAgdHJhbnNmb3JtLnNwbGl0Tm9kZUF0T2Zmc2V0T3BlcmF0aW9uKHBhdGgsIG9mZnNldClcblxuICBpZiAobm9ybWFsaXplKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50KGtleSlcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KHBhcmVudC5rZXksIFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIFVud3JhcCBjb250ZW50IGZyb20gYW4gaW5saW5lIHBhcmVudCB3aXRoIGBwcm9wZXJ0aWVzYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy51bndyYXBJbmxpbmVCeUtleSA9ICh0cmFuc2Zvcm0sIGtleSwgcHJvcGVydGllcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0RGVzY2VuZGFudChrZXkpXG4gIGNvbnN0IGZpcnN0ID0gbm9kZS5nZXRGaXJzdFRleHQoKVxuICBjb25zdCBsYXN0ID0gbm9kZS5nZXRMYXN0VGV4dCgpXG4gIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLm1vdmVUb1JhbmdlT2YoZmlyc3QsIGxhc3QpXG4gIHRyYW5zZm9ybS51bndyYXBJbmxpbmVBdFJhbmdlKHJhbmdlLCBwcm9wZXJ0aWVzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIFVud3JhcCBjb250ZW50IGZyb20gYSBibG9jayBwYXJlbnQgd2l0aCBgcHJvcGVydGllc2AuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMudW53cmFwQmxvY2tCeUtleSA9ICh0cmFuc2Zvcm0sIGtleSwgcHJvcGVydGllcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0RGVzY2VuZGFudChrZXkpXG4gIGNvbnN0IGZpcnN0ID0gbm9kZS5nZXRGaXJzdFRleHQoKVxuICBjb25zdCBsYXN0ID0gbm9kZS5nZXRMYXN0VGV4dCgpXG4gIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLm1vdmVUb1JhbmdlT2YoZmlyc3QsIGxhc3QpXG4gIHRyYW5zZm9ybS51bndyYXBCbG9ja0F0UmFuZ2UocmFuZ2UsIHByb3BlcnRpZXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogVW53cmFwIGEgc2luZ2xlIG5vZGUgZnJvbSBpdHMgcGFyZW50LlxuICpcbiAqIElmIHRoZSBub2RlIGlzIHN1cnJvdW5kZWQgd2l0aCBzaWJsaW5ncywgaXRzIHBhcmVudCB3aWxsIGJlXG4gKiBzcGxpdC4gSWYgdGhlIG5vZGUgaXMgdGhlIG9ubHkgY2hpbGQsIHRoZSBwYXJlbnQgaXMgcmVtb3ZlZCwgYW5kXG4gKiBzaW1wbHkgcmVwbGFjZWQgYnkgdGhlIG5vZGUgaXRzZWxmLiAgQ2Fubm90IHVud3JhcCBhIHJvb3Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMudW53cmFwTm9kZUJ5S2V5ID0gKHRyYW5zZm9ybSwga2V5LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQoa2V5KVxuICBjb25zdCBub2RlID0gcGFyZW50LmdldENoaWxkKGtleSlcblxuICBjb25zdCBpbmRleCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKG5vZGUpXG4gIGNvbnN0IGlzRmlyc3QgPSBpbmRleCA9PT0gMFxuICBjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gcGFyZW50Lm5vZGVzLnNpemUgLSAxXG5cbiAgY29uc3QgcGFyZW50UGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50KHBhcmVudC5rZXkpXG4gIGNvbnN0IHBhcmVudEluZGV4ID0gcGFyZW50UGFyZW50Lm5vZGVzLmluZGV4T2YocGFyZW50KVxuXG5cbiAgaWYgKHBhcmVudC5ub2Rlcy5zaXplID09PSAxKSB7XG4gICAgdHJhbnNmb3JtLm1vdmVOb2RlQnlLZXkoa2V5LCBwYXJlbnRQYXJlbnQua2V5LCBwYXJlbnRJbmRleCwgeyBub3JtYWxpemU6IGZhbHNlIH0pXG4gICAgdHJhbnNmb3JtLnJlbW92ZU5vZGVCeUtleShwYXJlbnQua2V5LCBvcHRpb25zKVxuICB9XG5cbiAgZWxzZSBpZiAoaXNGaXJzdCkge1xuICAgIC8vIEp1c3QgbW92ZSB0aGUgbm9kZSBiZWZvcmUgaXRzIHBhcmVudC5cbiAgICB0cmFuc2Zvcm0ubW92ZU5vZGVCeUtleShrZXksIHBhcmVudFBhcmVudC5rZXksIHBhcmVudEluZGV4LCBvcHRpb25zKVxuICB9XG5cbiAgZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgLy8gSnVzdCBtb3ZlIHRoZSBub2RlIGFmdGVyIGl0cyBwYXJlbnQuXG4gICAgdHJhbnNmb3JtLm1vdmVOb2RlQnlLZXkoa2V5LCBwYXJlbnRQYXJlbnQua2V5LCBwYXJlbnRJbmRleCArIDEsIG9wdGlvbnMpXG4gIH1cblxuICBlbHNlIHtcbiAgICBjb25zdCBwYXJlbnRQYXRoID0gZG9jdW1lbnQuZ2V0UGF0aChwYXJlbnQua2V5KVxuICAgIC8vIFNwbGl0IHRoZSBwYXJlbnQuXG4gICAgdHJhbnNmb3JtLnNwbGl0Tm9kZU9wZXJhdGlvbihwYXJlbnRQYXRoLCBpbmRleClcbiAgICAvLyBFeHRyYWN0IHRoZSBub2RlIGluIGJldHdlZW4gdGhlIHNwbGl0dGVkIHBhcmVudC5cbiAgICB0cmFuc2Zvcm0ubW92ZU5vZGVCeUtleShrZXksIHBhcmVudFBhcmVudC5rZXksIHBhcmVudEluZGV4ICsgMSwgeyBub3JtYWxpemU6IGZhbHNlIH0pXG5cbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KHBhcmVudFBhcmVudC5rZXksIFNDSEVNQSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwIGEgbm9kZSBpbiBhbiBpbmxpbmUgd2l0aCBgcHJvcGVydGllc2AuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbm9kZSB0byB3cmFwXG4gKiBAcGFyYW0ge0Jsb2NrfE9iamVjdHxTdHJpbmd9IGlubGluZSBUaGUgd3JhcHBpbmcgaW5saW5lIChpdHMgY2hpbGRyZW4gYXJlIGRpc2NhcmRlZClcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy53cmFwSW5saW5lQnlLZXkgPSAodHJhbnNmb3JtLCBrZXksIGlubGluZSwgb3B0aW9ucykgPT4ge1xuICBpbmxpbmUgPSBOb3JtYWxpemUuaW5saW5lKGlubGluZSlcbiAgaW5saW5lID0gaW5saW5lLnNldCgnbm9kZXMnLCBpbmxpbmUubm9kZXMuY2xlYXIoKSlcblxuICBjb25zdCB7IGRvY3VtZW50IH0gPSB0cmFuc2Zvcm0uc3RhdGVcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmFzc2VydERlc2NlbmRhbnQoa2V5KVxuICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQobm9kZS5rZXkpXG4gIGNvbnN0IGluZGV4ID0gcGFyZW50Lm5vZGVzLmluZGV4T2Yobm9kZSlcblxuICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KHBhcmVudC5rZXksIGluZGV4LCBpbmxpbmUsIHsgbm9ybWFsaXplOiBmYWxzZSB9KVxuICB0cmFuc2Zvcm0ubW92ZU5vZGVCeUtleShub2RlLmtleSwgaW5saW5lLmtleSwgMCwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBXcmFwIGEgbm9kZSBpbiBhIGJsb2NrIHdpdGggYHByb3BlcnRpZXNgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5vZGUgdG8gd3JhcFxuICogQHBhcmFtIHtCbG9ja3xPYmplY3R8U3RyaW5nfSBibG9jayBUaGUgd3JhcHBpbmcgYmxvY2sgKGl0cyBjaGlsZHJlbiBhcmUgZGlzY2FyZGVkKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLndyYXBCbG9ja0J5S2V5ID0gKHRyYW5zZm9ybSwga2V5LCBibG9jaywgb3B0aW9ucykgPT4ge1xuICBibG9jayA9IE5vcm1hbGl6ZS5ibG9jayhibG9jaylcbiAgYmxvY2sgPSBibG9jay5zZXQoJ25vZGVzJywgYmxvY2subm9kZXMuY2xlYXIoKSlcblxuICBjb25zdCB7IGRvY3VtZW50IH0gPSB0cmFuc2Zvcm0uc3RhdGVcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmFzc2VydERlc2NlbmRhbnQoa2V5KVxuICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQobm9kZS5rZXkpXG4gIGNvbnN0IGluZGV4ID0gcGFyZW50Lm5vZGVzLmluZGV4T2Yobm9kZSlcblxuICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KHBhcmVudC5rZXksIGluZGV4LCBibG9jaywgeyBub3JtYWxpemU6IGZhbHNlIH0pXG4gIHRyYW5zZm9ybS5tb3ZlTm9kZUJ5S2V5KG5vZGUua2V5LCBibG9jay5rZXksIDAsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3Jtc1xuIl19