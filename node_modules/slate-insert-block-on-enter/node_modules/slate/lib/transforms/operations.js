'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _normalize = require('../utils/normalize');

var _normalize2 = _interopRequireDefault(_normalize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transforms.
 *
 * @type {Object}
 */

var Transforms = {};

/**
 * Add mark to text at `offset` and `length` in node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} offset
 * @param {Number} length
 * @param {Mixed} mark
 */

Transforms.addMarkOperation = function (transform, path, offset, length, mark) {
  var inverse = [{
    type: 'remove_mark',
    path: path,
    offset: offset,
    length: length,
    mark: mark
  }];

  var operation = {
    type: 'add_mark',
    path: path,
    offset: offset,
    length: length,
    mark: mark,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Insert a `node` at `index` in a node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} index
 * @param {Node} node
 */

Transforms.insertNodeOperation = function (transform, path, index, node) {
  var inversePath = path.slice().concat([index]);
  var inverse = [{
    type: 'remove_node',
    path: inversePath
  }];

  var operation = {
    type: 'insert_node',
    path: path,
    index: index,
    node: node,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Insert `text` at `offset` in node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} offset
 * @param {String} text
 * @param {Set<Mark>} marks (optional)
 */

Transforms.insertTextOperation = function (transform, path, offset, text, marks) {
  var inverseLength = text.length;
  var inverse = [{
    type: 'remove_text',
    path: path,
    offset: offset,
    length: inverseLength
  }];

  var operation = {
    type: 'insert_text',
    path: path,
    offset: offset,
    text: text,
    marks: marks,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Join a node by `path` with a node `withPath`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Array} withPath
 */

Transforms.joinNodeOperation = function (transform, path, withPath) {
  var state = transform.state;
  var document = state.document;

  var node = document.assertPath(withPath);

  var inverse = void 0;
  if (node.kind === 'text') {
    var offset = node.length;

    inverse = [{
      type: 'split_node',
      path: withPath,
      offset: offset
    }];
  } else {
    // The number of children after which we split
    var count = node.nodes.count();

    inverse = [{
      type: 'split_node',
      path: withPath,
      count: count
    }];
  }

  var operation = {
    type: 'join_node',
    path: path,
    withPath: withPath,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Move a node by `path` to a `newPath` and `newIndex`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Array} newPath
 * @param {Number} newIndex
 */

Transforms.moveNodeOperation = function (transform, path, newPath, newIndex) {
  var parentPath = path.slice(0, -1);
  var parentIndex = path[path.length - 1];
  var inversePath = newPath.slice().concat([newIndex]);

  var inverse = [{
    type: 'move_node',
    path: inversePath,
    newPath: parentPath,
    newIndex: parentIndex
  }];

  var operation = {
    type: 'move_node',
    path: path,
    newPath: newPath,
    newIndex: newIndex,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Remove mark from text at `offset` and `length` in node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} offset
 * @param {Number} length
 * @param {Mark} mark
 */

Transforms.removeMarkOperation = function (transform, path, offset, length, mark) {
  var inverse = [{
    type: 'add_mark',
    path: path,
    offset: offset,
    length: length,
    mark: mark
  }];

  var operation = {
    type: 'remove_mark',
    path: path,
    offset: offset,
    length: length,
    mark: mark,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Remove a node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 */

Transforms.removeNodeOperation = function (transform, path) {
  var state = transform.state;
  var document = state.document;

  var node = document.assertPath(path);
  var inversePath = path.slice(0, -1);
  var inverseIndex = path[path.length - 1];

  var inverse = [{
    type: 'insert_node',
    path: inversePath,
    index: inverseIndex,
    node: node
  }];

  var operation = {
    type: 'remove_node',
    path: path,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Remove text at `offset` and `length` in node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} offset
 * @param {Number} length
 */

Transforms.removeTextOperation = function (transform, path, offset, length) {
  var state = transform.state;
  var document = state.document;

  var node = document.assertPath(path);
  var ranges = node.getRanges();
  var inverse = [];

  // Loop the ranges of text in the node, creating inverse insert operations for
  // each of the ranges that overlap with the remove operation. This is
  // necessary because insert's can only have a single set of marks associated
  // with them, but removes can remove many.
  ranges.reduce(function (start, range) {
    var text = range.text,
        marks = range.marks;

    var end = start + text.length;
    if (start > offset + length) return end;
    if (end <= offset) return end;

    var endOffset = Math.min(end, offset + length);
    var string = text.slice(offset - start, endOffset - start);

    inverse.push({
      type: 'insert_text',
      path: path,
      offset: offset,
      text: string,
      marks: marks
    });

    return end;
  }, 0);

  var operation = {
    type: 'remove_text',
    path: path,
    offset: offset,
    length: length,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Merge `properties` into state `data`.
 *
 * @param {Transform} transform
 * @param {Object} properties
 */

Transforms.setDataOperation = function (transform, properties) {
  var state = transform.state;
  var data = state.data;

  var inverseProps = {};

  for (var k in properties) {
    inverseProps[k] = data[k];
  }

  var inverse = [{
    type: 'set_data',
    properties: inverseProps
  }];

  var operation = {
    type: 'set_data',
    properties: properties,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Set `properties` on mark on text at `offset` and `length` in node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} offset
 * @param {Number} length
 * @param {Mark} mark
 * @param {Mark} newMark
 */

Transforms.setMarkOperation = function (transform, path, offset, length, mark, newMark) {
  var inverse = [{
    type: 'set_mark',
    path: path,
    offset: offset,
    length: length,
    mark: newMark,
    newMark: mark
  }];

  var operation = {
    type: 'set_mark',
    path: path,
    offset: offset,
    length: length,
    mark: mark,
    newMark: newMark,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Set `properties` on a node by `path`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Object} properties
 */

Transforms.setNodeOperation = function (transform, path, properties) {
  var state = transform.state;
  var document = state.document;

  var node = document.assertPath(path);
  var inverseProps = {};

  for (var k in properties) {
    inverseProps[k] = node[k];
  }

  var inverse = [{
    type: 'set_node',
    path: path,
    properties: inverseProps
  }];

  var operation = {
    type: 'set_node',
    path: path,
    properties: properties,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Set the selection to a new `selection`.
 *
 * @param {Transform} transform
 * @param {Mixed} selection
 */

Transforms.setSelectionOperation = function (transform, properties) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  properties = _normalize2.default.selectionProperties(properties);

  var state = transform.state;
  var document = state.document,
      selection = state.selection;

  var prevProps = {};
  var props = {};

  // Remove any properties that are already equal to the current selection. And
  // create a dictionary of the previous values for all of the properties that
  // are being changed, for the inverse operation.
  for (var k in properties) {
    if (!options.snapshot && properties[k] == selection[k]) continue;
    props[k] = properties[k];
    prevProps[k] = selection[k];
  }

  // If the selection moves, clear any marks, unless the new selection
  // does change the marks in some way
  var moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(function (p) {
    return props.hasOwnProperty(p);
  });

  if (selection.marks && properties.marks == selection.marks && moved) {
    props.marks = null;
  }

  // Resolve the selection keys into paths.
  if (props.anchorKey) {
    props.anchorPath = document.getPath(props.anchorKey);
    delete props.anchorKey;
  }

  if (prevProps.anchorKey) {
    prevProps.anchorPath = document.getPath(prevProps.anchorKey);
    delete prevProps.anchorKey;
  }

  if (props.focusKey) {
    props.focusPath = document.getPath(props.focusKey);
    delete props.focusKey;
  }

  if (prevProps.focusKey) {
    prevProps.focusPath = document.getPath(prevProps.focusKey);
    delete prevProps.focusKey;
  }

  // Define an inverse of the operation for undoing.
  var inverse = [{
    type: 'set_selection',
    properties: prevProps
  }];

  // Define the operation.
  var operation = {
    type: 'set_selection',
    properties: props,
    inverse: inverse
  };

  // Apply the operation.
  transform.applyOperation(operation);
};

/**
 * Split a node by `path` at `offset`.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} offset
 */

Transforms.splitNodeAtOffsetOperation = function (transform, path, offset) {
  var inversePath = path.slice();
  inversePath[path.length - 1] += 1;

  var inverse = [{
    type: 'join_node',
    path: inversePath,
    withPath: path,
    // We will split down to the text nodes, so we must join nodes recursively.
    deep: true
  }];

  var operation = {
    type: 'split_node',
    path: path,
    offset: offset,
    count: null,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Split a node by `path` after its 'count' child.
 *
 * @param {Transform} transform
 * @param {Array} path
 * @param {Number} count
 */

Transforms.splitNodeOperation = function (transform, path, count) {
  var inversePath = path.slice();
  inversePath[path.length - 1] += 1;

  var inverse = [{
    type: 'join_node',
    path: inversePath,
    withPath: path,
    deep: false
  }];

  var operation = {
    type: 'split_node',
    path: path,
    offset: null,
    count: count,
    inverse: inverse
  };

  transform.applyOperation(operation);
};

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Transforms;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zL29wZXJhdGlvbnMuanMiXSwibmFtZXMiOlsiVHJhbnNmb3JtcyIsImFkZE1hcmtPcGVyYXRpb24iLCJ0cmFuc2Zvcm0iLCJwYXRoIiwib2Zmc2V0IiwibGVuZ3RoIiwibWFyayIsImludmVyc2UiLCJ0eXBlIiwib3BlcmF0aW9uIiwiYXBwbHlPcGVyYXRpb24iLCJpbnNlcnROb2RlT3BlcmF0aW9uIiwiaW5kZXgiLCJub2RlIiwiaW52ZXJzZVBhdGgiLCJzbGljZSIsImNvbmNhdCIsImluc2VydFRleHRPcGVyYXRpb24iLCJ0ZXh0IiwibWFya3MiLCJpbnZlcnNlTGVuZ3RoIiwiam9pbk5vZGVPcGVyYXRpb24iLCJ3aXRoUGF0aCIsInN0YXRlIiwiZG9jdW1lbnQiLCJhc3NlcnRQYXRoIiwia2luZCIsImNvdW50Iiwibm9kZXMiLCJtb3ZlTm9kZU9wZXJhdGlvbiIsIm5ld1BhdGgiLCJuZXdJbmRleCIsInBhcmVudFBhdGgiLCJwYXJlbnRJbmRleCIsInJlbW92ZU1hcmtPcGVyYXRpb24iLCJyZW1vdmVOb2RlT3BlcmF0aW9uIiwiaW52ZXJzZUluZGV4IiwicmVtb3ZlVGV4dE9wZXJhdGlvbiIsInJhbmdlcyIsImdldFJhbmdlcyIsInJlZHVjZSIsInN0YXJ0IiwicmFuZ2UiLCJlbmQiLCJlbmRPZmZzZXQiLCJNYXRoIiwibWluIiwic3RyaW5nIiwicHVzaCIsInNldERhdGFPcGVyYXRpb24iLCJwcm9wZXJ0aWVzIiwiZGF0YSIsImludmVyc2VQcm9wcyIsImsiLCJzZXRNYXJrT3BlcmF0aW9uIiwibmV3TWFyayIsInNldE5vZGVPcGVyYXRpb24iLCJzZXRTZWxlY3Rpb25PcGVyYXRpb24iLCJvcHRpb25zIiwic2VsZWN0aW9uUHJvcGVydGllcyIsInNlbGVjdGlvbiIsInByZXZQcm9wcyIsInByb3BzIiwic25hcHNob3QiLCJtb3ZlZCIsInNvbWUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJhbmNob3JLZXkiLCJhbmNob3JQYXRoIiwiZ2V0UGF0aCIsImZvY3VzS2V5IiwiZm9jdXNQYXRoIiwic3BsaXROb2RlQXRPZmZzZXRPcGVyYXRpb24iLCJkZWVwIiwic3BsaXROb2RlT3BlcmF0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLGFBQWEsRUFBbkI7O0FBRUE7Ozs7Ozs7Ozs7QUFVQUEsV0FBV0MsZ0JBQVgsR0FBOEIsVUFBQ0MsU0FBRCxFQUFZQyxJQUFaLEVBQWtCQyxNQUFsQixFQUEwQkMsTUFBMUIsRUFBa0NDLElBQWxDLEVBQTJDO0FBQ3ZFLE1BQU1DLFVBQVUsQ0FBQztBQUNmQyxVQUFNLGFBRFM7QUFFZkwsY0FGZTtBQUdmQyxrQkFIZTtBQUlmQyxrQkFKZTtBQUtmQztBQUxlLEdBQUQsQ0FBaEI7O0FBUUEsTUFBTUcsWUFBWTtBQUNoQkQsVUFBTSxVQURVO0FBRWhCTCxjQUZnQjtBQUdoQkMsa0JBSGdCO0FBSWhCQyxrQkFKZ0I7QUFLaEJDLGNBTGdCO0FBTWhCQztBQU5nQixHQUFsQjs7QUFTQUwsWUFBVVEsY0FBVixDQUF5QkQsU0FBekI7QUFDRCxDQW5CRDs7QUFxQkE7Ozs7Ozs7OztBQVNBVCxXQUFXVyxtQkFBWCxHQUFpQyxVQUFDVCxTQUFELEVBQVlDLElBQVosRUFBa0JTLEtBQWxCLEVBQXlCQyxJQUF6QixFQUFrQztBQUNqRSxNQUFNQyxjQUFjWCxLQUFLWSxLQUFMLEdBQWFDLE1BQWIsQ0FBb0IsQ0FBQ0osS0FBRCxDQUFwQixDQUFwQjtBQUNBLE1BQU1MLFVBQVUsQ0FBQztBQUNmQyxVQUFNLGFBRFM7QUFFZkwsVUFBTVc7QUFGUyxHQUFELENBQWhCOztBQUtBLE1BQU1MLFlBQVk7QUFDaEJELFVBQU0sYUFEVTtBQUVoQkwsY0FGZ0I7QUFHaEJTLGdCQUhnQjtBQUloQkMsY0FKZ0I7QUFLaEJOO0FBTGdCLEdBQWxCOztBQVFBTCxZQUFVUSxjQUFWLENBQXlCRCxTQUF6QjtBQUNELENBaEJEOztBQWtCQTs7Ozs7Ozs7OztBQVVBVCxXQUFXaUIs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UUFULFdBQVd5RSwwQkFBWCxHQUF3QyxVQUFDdkUsU0FBRCxFQUFZQyxJQUFaLEVBQWtCQyxNQUFsQixFQUE2QjtBQUNuRSxNQUFNVSxjQUFjWCxLQUFLWSxLQUFMLEVBQXBCO0FBQ0FELGNBQVlYLEtBQUtFLE1BQUwsR0FBYyxDQUExQixLQUFnQyxDQUFoQzs7QUFFQSxNQUFNRSxVQUFVLENBQUM7QUFDZkMsVUFBTSxXQURTO0FBRWZMLFVBQU1XLFdBRlM7QUFHZlEsY0FBVW5CLElBSEs7QUFJZjtBQUNBdUUsVUFBTTtBQUxTLEdBQUQsQ0FBaEI7O0FBUUEsTUFBTWpFLFlBQVk7QUFDaEJELFVBQU0sWUFEVTtBQUVoQkwsY0FGZ0I7QUFHaEJDLGtCQUhnQjtBQUloQnVCLFdBQU8sSUFKUztBQUtoQnBCO0FBTGdCLEdBQWxCOztBQVFBTCxZQUFVUSxjQUFWLENBQXlCRCxTQUF6QjtBQUNELENBckJEOztBQXVCQTs7Ozs7Ozs7QUFRQVQsV0FBVzJFLGtCQUFYLEdBQWdDLFVBQUN6RSxTQUFELEVBQVlDLElBQVosRUFBa0J3QixLQUFsQixFQUE0QjtBQUMxRCxNQUFNYixjQUFjWCxLQUFLWSxLQUFMLEVBQXBCO0FBQ0FELGNBQVlYLEtBQUtFLE1BQUwsR0FBYyxDQUExQixLQUFnQyxDQUFoQzs7QUFFQSxNQUFNRSxVQUFVLENBQUM7QUFDZkMsVUFBTSxXQURTO0FBRWZMLFVBQU1XLFdBRlM7QUFHZlEsY0FBVW5CLElBSEs7QUFJZnVFLFVBQU07QUFKUyxHQUFELENBQWhCOztBQU9BLE1BQU1qRSxZQUFZO0FBQ2hCRCxVQUFNLFlBRFU7QUFFaEJMLGNBRmdCO0FBR2hCQyxZQUFRLElBSFE7QUFJaEJ1QixnQkFKZ0I7QUFLaEJwQjtBQUxnQixHQUFsQjs7QUFRQUwsWUFBVVEsY0FBVixDQUF5QkQsU0FBekI7QUFDRCxDQXBCRDs7QUFzQkE7Ozs7OztrQkFNZVQsVSIsImZpbGUiOiJvcGVyYXRpb25zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgTm9ybWFsaXplIGZyb20gJy4uL3V0aWxzL25vcm1hbGl6ZSdcblxuLyoqXG4gKiBUcmFuc2Zvcm1zLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgVHJhbnNmb3JtcyA9IHt9XG5cbi8qKlxuICogQWRkIG1hcmsgdG8gdGV4dCBhdCBgb2Zmc2V0YCBhbmQgYGxlbmd0aGAgaW4gbm9kZSBieSBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtNaXhlZH0gbWFya1xuICovXG5cblRyYW5zZm9ybXMuYWRkTWFya09wZXJhdGlvbiA9ICh0cmFuc2Zvcm0sIHBhdGgsIG9mZnNldCwgbGVuZ3RoLCBtYXJrKSA9PiB7XG4gIGNvbnN0IGludmVyc2UgPSBbe1xuICAgIHR5cGU6ICdyZW1vdmVfbWFyaycsXG4gICAgcGF0aCxcbiAgICBvZmZzZXQsXG4gICAgbGVuZ3RoLFxuICAgIG1hcmssXG4gIH1dXG5cbiAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgIHR5cGU6ICdhZGRfbWFyaycsXG4gICAgcGF0aCxcbiAgICBvZmZzZXQsXG4gICAgbGVuZ3RoLFxuICAgIG1hcmssXG4gICAgaW52ZXJzZSxcbiAgfVxuXG4gIHRyYW5zZm9ybS5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pXG59XG5cbi8qKlxuICogSW5zZXJ0IGEgYG5vZGVgIGF0IGBpbmRleGAgaW4gYSBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cblRyYW5zZm9ybXMuaW5zZXJ0Tm9kZU9wZXJhdGlvbiA9ICh0cmFuc2Zvcm0sIHBhdGgsIGluZGV4LCBub2RlKSA9PiB7XG4gIGNvbnN0IGludmVyc2VQYXRoID0gcGF0aC5zbGljZSgpLmNvbmNhdChbaW5kZXhdKVxuICBjb25zdCBpbnZlcnNlID0gW3tcbiAgICB0eXBlOiAncmVtb3ZlX25vZGUnLFxuICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICB9XVxuXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICB0eXBlOiAnaW5zZXJ0X25vZGUnLFxuICAgIHBhdGgsXG4gICAgaW5kZXgsXG4gICAgbm9kZSxcbiAgICBpbnZlcnNlLFxuICB9XG5cbiAgdHJhbnNmb3JtLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbilcbn1cblxuLyoqXG4gKiBJbnNlcnQgYHRleHRgIGF0IGBvZmZzZXRgIGluIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge1NldDxNYXJrPn0gbWFya3MgKG9wdGlvbmFsKVxuICovXG5cblRyYW5zZm9ybXMuaW5zZXJ0VGV4dE9wZXJhdGlvbiA9ICh0cmFuc2Zvcm0sIHBhdGgsIG9mZnNldCwgdGV4dCwgbWFya3MpID0+IHtcbiAgY29uc3QgaW52ZXJzZUxlbmd0aCA9IHRleHQubGVuZ3RoXG4gIGNvbnN0IGludmVyc2UgPSBbe1xuICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgcGF0aCxcbiAgICBvZmZzZXQsXG4gICAgbGVuZ3RoOiBpbnZlcnNlTGVuZ3RoLFxuICB9XVxuXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICB0eXBlOiAnaW5zZXJ0X3RleHQnLFxuICAgIHBhdGgsXG4gICAgb2Zmc2V0LFxuICAgIHRleHQsXG4gICAgbWFya3MsXG4gICAgaW52ZXJzZSxcbiAgfVxuXG4gIHRyYW5zZm9ybS5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pXG59XG5cbi8qKlxuICogSm9pbiBhIG5vZGUgYnkgYHBhdGhgIHdpdGggYSBub2RlIGB3aXRoUGF0aGAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICogQHBhcmFtIHtBcnJheX0gd2l0aFBhdGhcbiAqL1xuXG5UcmFuc2Zvcm1zLmpvaW5Ob2RlT3BlcmF0aW9uID0gKHRyYW5zZm9ybSwgcGF0aCwgd2l0aFBhdGgpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHdpdGhQYXRoKVxuXG4gIGxldCBpbnZlcnNlXG4gIGlmIChub2RlLmtpbmQgPT09ICd0ZXh0Jykge1xuICAgIGNvbnN0IG9mZnNldCA9IG5vZGUubGVuZ3RoXG5cbiAgICBpbnZlcnNlID0gW3tcbiAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgIHBhdGg6IHdpdGhQYXRoLFxuICAgICAgb2Zmc2V0LFxuICAgIH1dXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBhZnRlciB3aGljaCB3ZSBzcGxpdFxuICAgIGNvbnN0IGNvdW50ID0gbm9kZS5ub2Rlcy5jb3VudCgpXG5cbiAgICBpbnZlcnNlID0gW3tcbiAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgIHBhdGg6IHdpdGhQYXRoLFxuICAgICAgY291bnQsXG4gICAgfV1cbiAgfVxuXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICB0eXBlOiAnam9pbl9ub2RlJyxcbiAgICBwYXRoLFxuICAgIHdpdGhQYXRoLFxuICAgIGludmVyc2UsXG4gIH1cblxuICB0cmFuc2Zvcm0uYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKVxufVxuXG4vKipcbiAqIE1vdmUgYSBub2RlIGJ5IGBwYXRoYCB0byBhIGBuZXdQYXRoYCBhbmQgYG5ld0luZGV4YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBuZXdQYXRoXG4gKiBAcGFyYW0ge051bWJlcn0gbmV3SW5kZXhcbiAqL1xuXG5UcmFuc2Zvcm1zLm1vdmVOb2RlT3BlcmF0aW9uID0gKHRyYW5zZm9ybSwgcGF0aCwgbmV3UGF0aCwgbmV3SW5kZXgpID0+IHtcbiAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpXG4gIGNvbnN0IHBhcmVudEluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdXG4gIGNvbnN0IGludmVyc2VQYXRoID0gbmV3UGF0aC5zbGljZSgpLmNvbmNhdChbbmV3SW5kZXhdKVxuXG4gIGNvbnN0IGludmVyc2UgPSBbe1xuICAgIHR5cGU6ICdtb3ZlX25vZGUnLFxuICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgIG5ld1BhdGg6IHBhcmVudFBhdGgsXG4gICAgbmV3SW5kZXg6IHBhcmVudEluZGV4LFxuICB9XVxuXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICBwYXRoLFxuICAgIG5ld1BhdGgsXG4gICAgbmV3SW5kZXgsXG4gICAgaW52ZXJzZSxcbiAgfVxuXG4gIHRyYW5zZm9ybS5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pXG59XG5cbi8qKlxuICogUmVtb3ZlIG1hcmsgZnJvbSB0ZXh0IGF0IGBvZmZzZXRgIGFuZCBgbGVuZ3RoYCBpbiBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge01hcmt9IG1hcmtcbiAqL1xuXG5UcmFuc2Zvcm1zLnJlbW92ZU1hcmtPcGVyYXRpb24gPSAodHJhbnNmb3JtLCBwYXRoLCBvZmZzZXQsIGxlbmd0aCwgbWFyaykgPT4ge1xuICBjb25zdCBpbnZlcnNlID0gW3tcbiAgICB0eXBlOiAnYWRkX21hcmsnLFxuICAgIHBhdGgsXG4gICAgb2Zmc2V0LFxuICAgIGxlbmd0aCxcbiAgICBtYXJrLFxuICB9XVxuXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICB0eXBlOiAncmVtb3ZlX21hcmsnLFxuICAgIHBhdGgsXG4gICAgb2Zmc2V0LFxuICAgIGxlbmd0aCxcbiAgICBtYXJrLFxuICAgIGludmVyc2UsXG4gIH1cblxuICB0cmFuc2Zvcm0uYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqL1xuXG5UcmFuc2Zvcm1zLnJlbW92ZU5vZGVPcGVyYXRpb24gPSAodHJhbnNmb3JtLCBwYXRoKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChwYXRoKVxuICBjb25zdCBpbnZlcnNlUGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpXG4gIGNvbnN0IGludmVyc2VJbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuXG4gIGNvbnN0IGludmVyc2UgPSBbe1xuICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgcGF0aDogaW52ZXJzZVBhdGgsXG4gICAgaW5kZXg6IGludmVyc2VJbmRleCxcbiAgICBub2RlLFxuICB9XVxuXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICB0eXBlOiAncmVtb3ZlX25vZGUnLFxuICAgIHBhdGgsXG4gICAgaW52ZXJzZSxcbiAgfVxuXG4gIHRyYW5zZm9ybS5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pXG59XG5cbi8qKlxuICogUmVtb3ZlIHRleHQgYXQgYG9mZnNldGAgYW5kIGBsZW5ndGhgIGluIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqL1xuXG5UcmFuc2Zvcm1zLnJlbW92ZVRleHRPcGVyYXRpb24gPSAodHJhbnNmb3JtLCBwYXRoLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmFzc2VydFBhdGgocGF0aClcbiAgY29uc3QgcmFuZ2VzID0gbm9kZS5nZXRSYW5nZXMoKVxuICBjb25zdCBpbnZlcnNlID0gW11cblxuICAvLyBMb29wIHRoZSByYW5nZXMgb2YgdGV4dCBpbiB0aGUgbm9kZSwgY3JlYXRpbmcgaW52ZXJzZSBpbnNlcnQgb3BlcmF0aW9ucyBmb3JcbiAgLy8gZWFjaCBvZiB0aGUgcmFuZ2VzIHRoYXQgb3ZlcmxhcCB3aXRoIHRoZSByZW1vdmUgb3BlcmF0aW9uLiBUaGlzIGlzXG4gIC8vIG5lY2Vzc2FyeSBiZWNhdXNlIGluc2VydCdzIGNhbiBvbmx5IGhhdmUgYSBzaW5nbGUgc2V0IG9mIG1hcmtzIGFzc29jaWF0ZWRcbiAgLy8gd2l0aCB0aGVtLCBidXQgcmVtb3ZlcyBjYW4gcmVtb3ZlIG1hbnkuXG4gIHJhbmdlcy5yZWR1Y2UoKHN0YXJ0LCByYW5nZSkgPT4ge1xuICAgIGNvbnN0IHsgdGV4dCwgbWFya3MgfSA9IHJhbmdlXG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aFxuICAgIGlmIChzdGFydCA+IG9mZnNldCArIGxlbmd0aCkgcmV0dXJuIGVuZFxuICAgIGlmIChlbmQgPD0gb2Zmc2V0KSByZXR1cm4gZW5kXG5cbiAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihlbmQsIG9mZnNldCArIGxlbmd0aClcbiAgICBjb25zdCBzdHJpbmcgPSB0ZXh0LnNsaWNlKG9mZnNldCAtIHN0YXJ0LCBlbmRPZmZzZXQgLSBzdGFydClcblxuICAgIGludmVyc2UucHVzaCh7XG4gICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnLFxuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRleHQ6IHN0cmluZyxcbiAgICAgIG1hcmtzLFxuICAgIH0pXG5cbiAgICByZXR1cm4gZW5kXG4gIH0sIDApXG5cbiAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgcGF0aCxcbiAgICBvZmZzZXQsXG4gICAgbGVuZ3RoLFxuICAgIGludmVyc2UsXG4gIH1cblxuICB0cmFuc2Zvcm0uYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKVxufVxuXG4vKipcbiAqIE1lcmdlIGBwcm9wZXJ0aWVzYCBpbnRvIHN0YXRlIGBkYXRhYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICovXG5cblRyYW5zZm9ybXMuc2V0RGF0YU9wZXJhdGlvbiA9ICh0cmFuc2Zvcm0sIHByb3BlcnRpZXMpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZGF0YSB9ID0gc3RhdGVcbiAgY29uc3QgaW52ZXJzZVByb3BzID0ge31cblxuICBmb3IgKGNvbnN0IGsgaW4gcHJvcGVydGllcykge1xuICAgIGludmVyc2VQcm9wc1trXSA9IGRhdGFba11cbiAgfVxuXG4gIGNvbnN0IGludmVyc2UgPSBbe1xuICAgIHR5cGU6ICdzZXRfZGF0YScsXG4gICAgcHJvcGVydGllczogaW52ZXJzZVByb3BzXG4gIH1dXG5cbiAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgIHR5cGU6ICdzZXRfZGF0YScsXG4gICAgcHJvcGVydGllcyxcbiAgICBpbnZlcnNlLFxuICB9XG5cbiAgdHJhbnNmb3JtLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbilcbn1cblxuLyoqXG4gKiBTZXQgYHByb3BlcnRpZXNgIG9uIG1hcmsgb24gdGV4dCBhdCBgb2Zmc2V0YCBhbmQgYGxlbmd0aGAgaW4gbm9kZSBieSBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtNYXJrfSBtYXJrXG4gKiBAcGFyYW0ge01hcmt9IG5ld01hcmtcbiAqL1xuXG5UcmFuc2Zvcm1zLnNldE1hcmtPcGVyYXRpb24gPSAodHJhbnNmb3JtLCBwYXRoLCBvZmZzZXQsIGxlbmd0aCwgbWFyaywgbmV3TWFyaykgPT4ge1xuICBjb25zdCBpbnZlcnNlID0gW3tcbiAgICB0eXBlOiAnc2V0X21hcmsnLFxuICAgIHBhdGgsXG4gICAgb2Zmc2V0LFxuICAgIGxlbmd0aCxcbiAgICBtYXJrOiBuZXdNYXJrLFxuICAgIG5ld01hcms6IG1hcmtcbiAgfV1cblxuICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgdHlwZTogJ3NldF9tYXJrJyxcbiAgICBwYXRoLFxuICAgIG9mZnNldCxcbiAgICBsZW5ndGgsXG4gICAgbWFyayxcbiAgICBuZXdNYXJrLFxuICAgIGludmVyc2UsXG4gIH1cblxuICB0cmFuc2Zvcm0uYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKVxufVxuXG4vKipcbiAqIFNldCBgcHJvcGVydGllc2Agb24gYSBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICovXG5cblRyYW5zZm9ybXMuc2V0Tm9kZU9wZXJhdGlvbiA9ICh0cmFuc2Zvcm0sIHBhdGgsIHByb3BlcnRpZXMpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG4gIGNvbnN0IGludmVyc2VQcm9wcyA9IHt9XG5cbiAgZm9yIChjb25zdCBrIGluIHByb3BlcnRpZXMpIHtcbiAgICBpbnZlcnNlUHJvcHNba10gPSBub2RlW2tdXG4gIH1cblxuICBjb25zdCBpbnZlcnNlID0gW3tcbiAgICB0eXBlOiAnc2V0X25vZGUnLFxuICAgIHBhdGgsXG4gICAgcHJvcGVydGllczogaW52ZXJzZVByb3BzXG4gIH1dXG5cbiAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgcGF0aCxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIGludmVyc2UsXG4gIH1cblxuICB0cmFuc2Zvcm0uYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKVxufVxuXG4vKipcbiAqIFNldCB0aGUgc2VsZWN0aW9uIHRvIGEgbmV3IGBzZWxlY3Rpb25gLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7TWl4ZWR9IHNlbGVjdGlvblxuICovXG5cblRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uT3BlcmF0aW9uID0gKHRyYW5zZm9ybSwgcHJvcGVydGllcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHByb3BlcnRpZXMgPSBOb3JtYWxpemUuc2VsZWN0aW9uUHJvcGVydGllcyhwcm9wZXJ0aWVzKVxuXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50LCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIGNvbnN0IHByZXZQcm9wcyA9IHt9XG4gIGNvbnN0IHByb3BzID0ge31cblxuICAvLyBSZW1vdmUgYW55IHByb3BlcnRpZXMgdGhhdCBhcmUgYWxyZWFkeSBlcXVhbCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uIEFuZFxuICAvLyBjcmVhdGUgYSBkaWN0aW9uYXJ5IG9mIHRoZSBwcmV2aW91cyB2YWx1ZXMgZm9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyB0aGF0XG4gIC8vIGFyZSBiZWluZyBjaGFuZ2VkLCBmb3IgdGhlIGludmVyc2Ugb3BlcmF0aW9uLlxuICBmb3IgKGNvbnN0IGsgaW4gcHJvcGVydGllcykge1xuICAgIGlmICghb3B0aW9ucy5zbmFwc2hvdCAmJiBwcm9wZXJ0aWVzW2tdID09IHNlbGVjdGlvbltrXSkgY29udGludWVcbiAgICBwcm9wc1trXSA9IHByb3BlcnRpZXNba11cbiAgICBwcmV2UHJvcHNba10gPSBzZWxlY3Rpb25ba11cbiAgfVxuXG4gIC8vIElmIHRoZSBzZWxlY3Rpb24gbW92ZXMsIGNsZWFyIGFueSBtYXJrcywgdW5sZXNzIHRoZSBuZXcgc2VsZWN0aW9uXG4gIC8vIGRvZXMgY2hhbmdlIHRoZSBtYXJrcyBpbiBzb21lIHdheVxuICBjb25zdCBtb3ZlZCA9IFtcbiAgICAnYW5jaG9yS2V5JyxcbiAgICAnYW5jaG9yT2Zmc2V0JyxcbiAgICAnZm9jdXNLZXknLFxuICAgICdmb2N1c09mZnNldCcsXG4gIF0uc29tZShwID0+IHByb3BzLmhhc093blByb3BlcnR5KHApKVxuXG4gIGlmIChcbiAgICBzZWxlY3Rpb24ubWFya3MgJiZcbiAgICBwcm9wZXJ0aWVzLm1hcmtzID09IHNlbGVjdGlvbi5tYXJrcyAmJlxuICAgIG1vdmVkXG4gICkge1xuICAgIHByb3BzLm1hcmtzID0gbnVsbFxuICB9XG5cbiAgLy8gUmVzb2x2ZSB0aGUgc2VsZWN0aW9uIGtleXMgaW50byBwYXRocy5cbiAgaWYgKHByb3BzLmFuY2hvcktleSkge1xuICAgIHByb3BzLmFuY2hvclBhdGggPSBkb2N1bWVudC5nZXRQYXRoKHByb3BzLmFuY2hvcktleSlcbiAgICBkZWxldGUgcHJvcHMuYW5jaG9yS2V5XG4gIH1cblxuICBpZiAocHJldlByb3BzLmFuY2hvcktleSkge1xuICAgIHByZXZQcm9wcy5hbmNob3JQYXRoID0gZG9jdW1lbnQuZ2V0UGF0aChwcmV2UHJvcHMuYW5jaG9yS2V5KVxuICAgIGRlbGV0ZSBwcmV2UHJvcHMuYW5jaG9yS2V5XG4gIH1cblxuICBpZiAocHJvcHMuZm9jdXNLZXkpIHtcbiAgICBwcm9wcy5mb2N1c1BhdGggPSBkb2N1bWVudC5nZXRQYXRoKHByb3BzLmZvY3VzS2V5KVxuICAgIGRlbGV0ZSBwcm9wcy5mb2N1c0tleVxuICB9XG5cbiAgaWYgKHByZXZQcm9wcy5mb2N1c0tleSkge1xuICAgIHByZXZQcm9wcy5mb2N1c1BhdGggPSBkb2N1bWVudC5nZXRQYXRoKHByZXZQcm9wcy5mb2N1c0tleSlcbiAgICBkZWxldGUgcHJldlByb3BzLmZvY3VzS2V5XG4gIH1cblxuICAvLyBEZWZpbmUgYW4gaW52ZXJzZSBvZiB0aGUgb3BlcmF0aW9uIGZvciB1bmRvaW5nLlxuICBjb25zdCBpbnZlcnNlID0gW3tcbiAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgcHJvcGVydGllczogcHJldlByb3BzXG4gIH1dXG5cbiAgLy8gRGVmaW5lIHRoZSBvcGVyYXRpb24uXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgcHJvcGVydGllczogcHJvcHMsXG4gICAgaW52ZXJzZSxcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSBvcGVyYXRpb24uXG4gIHRyYW5zZm9ybS5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pXG59XG5cbi8qKlxuICogU3BsaXQgYSBub2RlIGJ5IGBwYXRoYCBhdCBgb2Zmc2V0YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKi9cblxuVHJhbnNmb3Jtcy5zcGxpdE5vZGVBdE9mZnNldE9wZXJhdGlvbiA9ICh0cmFuc2Zvcm0sIHBhdGgsIG9mZnNldCkgPT4ge1xuICBjb25zdCBpbnZlcnNlUGF0aCA9IHBhdGguc2xpY2UoKVxuICBpbnZlcnNlUGF0aFtwYXRoLmxlbmd0aCAtIDFdICs9IDFcblxuICBjb25zdCBpbnZlcnNlID0gW3tcbiAgICB0eXBlOiAnam9pbl9ub2RlJyxcbiAgICBwYXRoOiBpbnZlcnNlUGF0aCxcbiAgICB3aXRoUGF0aDogcGF0aCxcbiAgICAvLyBXZSB3aWxsIHNwbGl0IGRvd24gdG8gdGhlIHRleHQgbm9kZXMsIHNvIHdlIG11c3Qgam9pbiBub2RlcyByZWN1cnNpdmVseS5cbiAgICBkZWVwOiB0cnVlXG4gIH1dXG5cbiAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICBwYXRoLFxuICAgIG9mZnNldCxcbiAgICBjb3VudDogbnVsbCxcbiAgICBpbnZlcnNlLFxuICB9XG5cbiAgdHJhbnNmb3JtLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbilcbn1cblxuLyoqXG4gKiBTcGxpdCBhIG5vZGUgYnkgYHBhdGhgIGFmdGVyIGl0cyAnY291bnQnIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICovXG5cblRyYW5zZm9ybXMuc3BsaXROb2RlT3BlcmF0aW9uID0gKHRyYW5zZm9ybSwgcGF0aCwgY291bnQpID0+IHtcbiAgY29uc3QgaW52ZXJzZVBhdGggPSBwYXRoLnNsaWNlKClcbiAgaW52ZXJzZVBhdGhbcGF0aC5sZW5ndGggLSAxXSArPSAxXG5cbiAgY29uc3QgaW52ZXJzZSA9IFt7XG4gICAgdHlwZTogJ2pvaW5fbm9kZScsXG4gICAgcGF0aDogaW52ZXJzZVBhdGgsXG4gICAgd2l0aFBhdGg6IHBhdGgsXG4gICAgZGVlcDogZmFsc2VcbiAgfV1cblxuICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgIHBhdGgsXG4gICAgb2Zmc2V0OiBudWxsLFxuICAgIGNvdW50LFxuICAgIGludmVyc2UsXG4gIH1cblxuICB0cmFuc2Zvcm0uYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKVxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybXNcbiJdfQ==