'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _normalize = require('../utils/normalize');

var _normalize2 = _interopRequireDefault(_normalize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transforms.
 *
 * @type {Object}
 */

var Transforms = {};

/**
 * Add a `mark` to the characters in the current selection.
 *
 * @param {Transform} transform
 * @param {Mark} mark
 */

Transforms.addMark = function (transform, mark) {
  mark = _normalize2.default.mark(mark);
  var state = transform.state;
  var document = state.document,
      selection = state.selection;


  if (selection.isExpanded) {
    transform.addMarkAtRange(selection, mark);
    return;
  }

  if (selection.marks) {
    var _marks = selection.marks.add(mark);
    var _sel = selection.set('marks', _marks);
    transform.select(_sel);
    return;
  }

  var marks = document.getMarksAtRange(selection).add(mark);
  var sel = selection.set('marks', marks);
  transform.select(sel);
};

/**
 * Delete at the current selection.
 *
 * @param {Transform} transform
 */

Transforms.delete = function (transform) {
  var state = transform.state;
  var selection = state.selection;

  if (selection.isCollapsed) return;

  transform.snapshotSelection().deleteAtRange(selection)
  // Ensure that the selection is collapsed to the start, because in certain
  // cases when deleting across inline nodes this isn't guaranteed.
  .collapseToStart().snapshotSelection();
};

/**
 * Delete backward `n` characters at the current selection.
 *
 * @param {Transform} transform
 * @param {Number} n (optional)
 */

Transforms.deleteBackward = function (transform) {
  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var state = transform.state;
  var selection = state.selection;

  transform.deleteBackwardAtRange(selection, n);
};

/**
 * Delete backward until the character boundary at the current selection.
 *
 * @param {Transform} transform
 */

Transforms.deleteCharBackward = function (transform) {
  var state = transform.state;
  var selection = state.selection;

  transform.deleteCharBackwardAtRange(selection);
};

/**
 * Delete backward until the line boundary at the current selection.
 *
 * @param {Transform} transform
 */

Transforms.deleteLineBackward = function (transform) {
  var state = transform.state;
  var selection = state.selection;

  transform.deleteLineBackwardAtRange(selection);
};

/**
 * Delete backward until the word boundary at the current selection.
 *
 * @param {Transform} transform
 */

Transforms.deleteWordBackward = function (transform) {
  var state = transform.state;
  var selection = state.selection;

  transform.deleteWordBackwardAtRange(selection);
};

/**
 * Delete forward `n` characters at the current selection.
 *
 * @param {Transform} transform
 * @param {Number} n (optional)
 */

Transforms.deleteForward = function (transform) {
  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var state = transform.state;
  var selection = state.selection;

  transform.deleteForwardAtRange(selection, n);
};

/**
 * Delete forward until the character boundary at the current selection.
 *
 * @param {Transform} transform
 */

Transforms.deleteCharForward = function (transform) {
  var state = transform.state;
  var selection = state.selection;

  transform.deleteCharForwardAtRange(selection);
};

/**
 * Delete forward until the line boundary at the current selection.
 *
 * @param {Transform} transform
 */

Transforms.deleteLineForward = function (transform) {
  var state = transform.state;
  var selection = state.selection;

  transform.deleteLineForwardAtRange(selection);
};

/**
 * Delete forward until the word boundary at the current selection.
 *
 * @param {Transform} transform
 */

Transforms.deleteWordForward = function (transform) {
  var state = transform.state;
  var selection = state.selection;

  transform.deleteWordForwardAtRange(selection);
};

/**
 * Insert a `block` at the current selection.
 *
 * @param {Transform} transform
 * @param {String|Object|Block} block
 */

Transforms.insertBlock = function (transform, block) {
  block = _normalize2.default.block(block);
  var state = transform.state;
  var selection = state.selection;

  transform.insertBlockAtRange(selection, block);

  // If the node was successfully inserted, update the selection.
  var node = transform.state.document.getNode(block.key);
  if (node) transform.collapseToEndOf(node);
};

/**
 * Insert a `fragment` at the current selection.
 *
 * @param {Transform} transform
 * @param {Document} fragment
 */

Transforms.insertFragment = function (transform, fragment) {
  var state = transform.state;
  var _state = state,
      document = _state.document,
      selection = _state.selection;


  if (!fragment.nodes.size) return;

  var _state2 = state,
      startText = _state2.startText,
      endText = _state2.endText;

  var lastText = fragment.getLastText();
  var lastInline = fragment.getClosestInline(lastText.key);
  var keys = document.getTexts().map(function (text) {
    return text.key;
  });
  var isAppending = selection.hasEdgeAtEndOf(endText) || selection.hasEdgeAtStartOf(startText);

  transform.deselect();
  transform.insertFragmentAtRange(selection, fragment);
  state = transform.state;
  document = state.document;

  var newTexts = document.getTexts().filter(function (n) {
    return !keys.includes(n.key);
  });
  var newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first();
  var after = void 0;

  if (newText && lastInline) {
    after = selection.collapseToEndOf(newText);
  } else if (newText) {
    after = selection.collapseToStartOf(newText).move(lastText.length);
  } else {
    after = selection.collapseToStart().move(lastText.length);
  }

  transform.select(after);
};

/**
 * Insert a `inline` at the current selection.
 *
 * @param {Transform} transform
 * @param {String|Object|Block} inline
 */

Transforms.insertInline = function (transform, inline) {
  inline = _normalize2.default.inline(inline);
  var state = transform.state;
  var selection = state.selection;

  transform.insertInlineAtRange(selection, inline);

  // If the node was successfully inserted, update the selection.
  var node = transform.state.document.getNode(inline.key);
  if (node) transform.collapseToEndOf(node);
};

/**
 * Insert a `text` string at the current selection.
 *
 * @param {Transform} transform
 * @param {String} text
 * @param {Set<Mark>} marks (optional)
 */

Transforms.insertText = function (transform, text, marks) {
  var state = transform.state;
  var document = state.document,
      selection = state.selection;

  marks = marks || selection.marks;
  transform.insertTextAtRange(selection, text, marks);

  // If the text was successfully inserted, and the selection had marks on it,
  // unset the selection's marks.
  if (selection.marks && document != transform.state.document) {
    transform.select({ marks: null });
  }
};

/**
 * Set `properties` of the block nodes in the current selection.
 *
 * @param {Transform} transform
 * @param {Object} properties
 */

Transforms.setBlock = function (transform, properties) {
  var state = transform.state;
  var selection = state.selection;

  transform.setBlockAtRange(selection, properties);
};

/**
 * Set `properties` of the inline nodes in the current selection.
 *
 * @param {Transform} transform
 * @param {Object} properties
 */

Transforms.setInline = function (transform, properties) {
  var state = transform.state;
  var selection = state.selection;

  transform.setInlineAtRange(selection, properties);
};

/**
 * Split the block node at the current selection, to optional `depth`.
 *
 * @param {Transform} transform
 * @param {Number} depth (optional)
 */

Transforms.splitBlock = function (transform) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var state = transform.state;
  var selection = state.selection;

  transform.snapshotSelection().splitBlockAtRange(selection, depth).collapseToEnd().snapshotSelection();
};

/**
 * Split the inline nodes at the current selection, to optional `depth`.
 *
 * @param {Transform} transform
 * @param {Number} depth (optional)
 */

Transforms.splitInline = function (transform) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  var state = transform.state;
  var selection = state.selection;

  transform.snapshotSelection().splitInlineAtRange(selection, depth).snapshotSelection();
};

/**
 * Remove a `mark` from the characters in the current selection.
 *
 * @param {Transform} transform
 * @param {Mark} mark
 */

Transforms.removeMark = function (transform, mark) {
  mark = _normalize2.default.mark(mark);
  var state = transform.state;
  var document = state.document,
      selection = state.selection;


  if (selection.isExpanded) {
    transform.removeMarkAtRange(selection, mark);
    return;
  }

  if (selection.marks) {
    var _marks2 = selection.marks.remove(mark);
    var _sel2 = selection.set('marks', _marks2);
    transform.select(_sel2);
    return;
  }

  var marks = document.getMarksAtRange(selection).remove(mark);
  var sel = selection.set('marks', marks);
  transform.select(sel);
};

/**
 * Add or remove a `mark` from the characters in the current selection,
 * depending on whether it's already there.
 *
 * @param {Transform} transform
 * @param {Mark} mark
 */

Transforms.toggleMark = function (transform, mark) {
  mark = _normalize2.default.mark(mark);
  var state = transform.state;

  var exists = state.marks.some(function (m) {
    return m.equals(mark);
  });

  if (exists) {
    transform.removeMark(mark);
  } else {
    transform.addMark(mark);
  }
};

/**
 * Unwrap the current selection from a block parent with `properties`.
 *
 * @param {Transform} transform
 * @param {Object|String} properties
 */

Transforms.unwrapBlock = function (transform, properties) {
  var state = transform.state;
  var selection = state.selection;

  transform.unwrapBlockAtRange(selection, properties);
};

/**
 * Unwrap the current selection from an inline parent with `properties`.
 *
 * @param {Transform} transform
 * @param {Object|String} properties
 */

Transforms.unwrapInline = function (transform, properties) {
  var state = transform.state;
  var selection = state.selection;

  transform.unwrapInlineAtRange(selection, properties);
};

/**
 * Wrap the block nodes in the current selection with a new block node with
 * `properties`.
 *
 * @param {Transform} transform
 * @param {Object|String} properties
 */

Transforms.wrapBlock = function (transform, properties) {
  var state = transform.state;
  var selection = state.selection;

  transform.wrapBlockAtRange(selection, properties);
};

/**
 * Wrap the current selection in new inline nodes with `properties`.
 *
 * @param {Transform} transform
 * @param {Object|String} properties
 */

Transforms.wrapInline = function (transform, properties) {
  var state = transform.state;
  var _state3 = state,
      document = _state3.document,
      selection = _state3.selection;

  var after = void 0;

  var startKey = selection.startKey;


  transform.deselect();
  transform.wrapInlineAtRange(selection, properties);
  state = transform.state;
  document = state.document;

  // Determine what the selection should be after wrapping.
  if (selection.isCollapsed) {
    after = selection;
  } else if (selection.startOffset == 0) {
    // Find the inline that has been inserted.
    // We want to handle multiple wrap, so we need to take the highest parent
    var inline = document.getAncestors(startKey).find(function (parent) {
      return parent.kind == 'inline' && parent.getOffset(startKey) == 0;
    });

    var start = inline ? document.getPreviousText(inline.getFirstText().key) : document.getFirstText();
    var end = document.getNextText(inline ? inline.getLastText().key : start.key);

    // Move selection to wrap around the inline
    after = selection.moveAnchorToEndOf(start).moveFocusToStartOf(end);
  } else if (selection.startKey == selection.endKey) {
    var text = document.getNextText(selection.startKey);
    after = selection.moveToRangeOf(text);
  } else {
    var anchor = document.getNextText(selection.anchorKey);
    var focus = document.getDescendant(selection.focusKey);
    after = selection.merge({
      anchorKey: anchor.key,
      anchorOffset: 0,
      focusKey: focus.key,
      focusOffset: selection.focusOffset
    });
  }

  after = after.normalize(document);
  transform.select(after);
};

/**
 * Wrap the current selection with prefix/suffix.
 *
 * @param {Transform} transform
 * @param {String} prefix
 * @param {String} suffix
 */

Transforms.wrapText = function (transform, prefix) {
  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;
  var state = transform.state;
  var selection = state.selection;

  transform.wrapTextAtRange(selection, prefix, suffix);

  // If the selection was collapsed, it will have moved the start offset too.
  if (selection.isCollapsed) {
    transform.moveStart(0 - prefix.length);
  }

  // Adding the suffix will have pushed the end of the selection further on, so
  // we need to move it back to account for this.
  transform.moveEnd(0 - suffix.length);

  // There's a chance that the selection points moved "through" each other,
  // resulting in a now-incorrect selection direction.
  if (selection.isForward != transform.state.selection.isForward) {
    transform.flip();
  }
};

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Transforms;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zL2F0LWN1cnJlbnQtcmFuZ2UuanMiXSwibmFtZXMiOlsiVHJhbnNmb3JtcyIsImFkZE1hcmsiLCJ0cmFuc2Zvcm0iLCJtYXJrIiwic3RhdGUiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImlzRXhwYW5kZWQiLCJhZGRNYXJrQXRSYW5nZSIsIm1hcmtzIiwiYWRkIiwic2VsIiwic2V0Iiwic2VsZWN0IiwiZ2V0TWFya3NBdFJhbmdlIiwiZGVsZXRlIiwiaXNDb2xsYXBzZWQiLCJzbmFwc2hvdFNlbGVjdGlvbiIsImRlbGV0ZUF0UmFuZ2UiLCJjb2xsYXBzZVRvU3RhcnQiLCJkZWxldGVCYWNrd2FyZCIsIm4iLCJkZWxldGVCYWNrd2FyZEF0UmFuZ2UiLCJkZWxldGVDaGFyQmFja3dhcmQiLCJkZWxldGVDaGFyQmFja3dhcmRBdFJhbmdlIiwiZGVsZXRlTGluZUJhY2t3YXJkIiwiZGVsZXRlTGluZUJhY2t3YXJkQXRSYW5nZSIsImRlbGV0ZVdvcmRCYWNrd2FyZCIsImRlbGV0ZVdvcmRCYWNrd2FyZEF0UmFuZ2UiLCJkZWxldGVGb3J3YXJkIiwiZGVsZXRlRm9yd2FyZEF0UmFuZ2UiLCJkZWxldGVDaGFyRm9yd2FyZCIsImRlbGV0ZUNoYXJGb3J3YXJkQXRSYW5nZSIsImRlbGV0ZUxpbmVGb3J3YXJkIiwiZGVsZXRlTGluZUZvcndhcmRBdFJhbmdlIiwiZGVsZXRlV29yZEZvcndhcmQiLCJkZWxldGVXb3JkRm9yd2FyZEF0UmFuZ2UiLCJpbnNlcnRCbG9jayIsImJsb2NrIiwiaW5zZXJ0QmxvY2tBdFJhbmdlIiwibm9kZSIsImdldE5vZGUiLCJrZXkiLCJjb2xsYXBzZVRvRW5kT2YiLCJpbnNlcnRGcmFnbWVudCIsImZyYWdtZW50Iiwibm9kZXMiLCJzaXplIiwic3RhcnRUZXh0IiwiZW5kVGV4dCIsImxhc3RUZXh0IiwiZ2V0TGFzdFRleHQiLCJsYXN0SW5saW5lIiwiZ2V0Q2xvc2VzdElubGluZSIsImtleXMiLCJnZXRUZXh0cyIsIm1hcCIsInRleHQiLCJpc0FwcGVuZGluZyIsImhhc0VkZ2VBdEVuZE9mIiwiaGFzRWRnZUF0U3RhcnRPZiIsImRlc2VsZWN0IiwiaW5zZXJ0RnJhZ21lbnRBdFJhbmdlIiwibmV3VGV4dHMiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsIm5ld1RleHQiLCJsYXN0IiwidGFrZUxhc3QiLCJmaXJzdCIsImFmdGVyIiwiY29sbGFwc2VUb1N0YXJ0T2YiLCJtb3ZlIiwibGVuZ3RoIiwiaW5zZXJ0SW5saW5lIiwiaW5saW5lIiwiaW5zZXJ0SW5saW5lQXRSYW5nZSIsImluc2VydFRleHQiLCJpbnNlcnRUZXh0QXRSYW5nZSIsInNldEJsb2NrIiwicHJvcGVydGllcyIsInNldEJsb2NrQXRSYW5nZSIsInNldElubGluZSIsInNldElubGluZUF0UmFuZ2UiLCJzcGxpdEJsb2NrIiwiZGVwdGgiLCJzcGxpdEJsb2NrQXRSYW5nZSIsImNvbGxhcHNlVG9FbmQiLCJzcGxpdElubGluZSIsIkluZmluaXR5Iiwic3BsaXRJbmxpbmVBdFJhbmdlIiwicmVtb3ZlTWFyayIsInJlbW92ZU1hcmtBdFJhbmdlIiwicmVtb3ZlIiwidG9nZ2xlTWFyayIsImV4aXN0cyIsInNvbWUiLCJtIiwiZXF1YWxzIiwidW53cmFwQmxvY2siLCJ1bndyYXBCbG9ja0F0UmFuZ2UiLCJ1bndyYXBJbmxpbmUiLCJ1bndyYXBJbmxpbmVBdFJhbmdlIiwid3JhcEJsb2NrIiwid3JhcEJsb2NrQXRSYW5nZSIsIndyYXBJbmxpbmUiLCJzdGFydEtleSIsIndyYXBJbmxpbmVBdFJhbmdlIiwic3RhcnRPZmZzZXQiLCJnZXRBbmNlc3RvcnMiLCJmaW5kIiwicGFyZW50Iiwia2luZCIsImdldE9mZnNldCIsInN0YXJ0IiwiZ2V0UHJldmlvdXNUZXh0IiwiZ2V0Rmlyc3RUZXh0IiwiZW5kIiwiZ2V0TmV4dFRleHQiLCJtb3ZlQW5jaG9yVG9FbmRPZiIsIm1vdmVGb2N1c1RvU3RhcnRPZiIsImVuZEtleSIsIm1vdmVUb1JhbmdlT2YiLCJhbmNob3IiLCJhbmNob3JLZXkiLCJmb2N1cyIsImdldERlc2NlbmRhbnQiLCJmb2N1c0tleSIsIm1lcmdlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJub3JtYWxpemUiLCJ3cmFwVGV4dCIsInByZWZpeCIsInN1ZmZpeCIsIndyYXBUZXh0QXRSYW5nZSIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJpc0ZvcndhcmQiLCJmbGlwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLGFBQWEsRUFBbkI7O0FBRUE7Ozs7Ozs7QUFPQUEsV0FBV0MsT0FBWCxHQUFxQixVQUFDQyxTQUFELEVBQVlDLElBQVosRUFBcUI7QUFDeENBLFNBQU8sb0JBQVVBLElBQVYsQ0FBZUEsSUFBZixDQUFQO0FBRHdDLE1BRWhDQyxLQUZnQyxHQUV0QkYsU0FGc0IsQ0FFaENFLEtBRmdDO0FBQUEsTUFHaENDLFFBSGdDLEdBR1JELEtBSFEsQ0FHaENDLFFBSGdDO0FBQUEsTUFHdEJDLFNBSHNCLEdBR1JGLEtBSFEsQ0FHdEJFLFNBSHNCOzs7QUFLeEMsTUFBSUEsVUFBVUMsVUFBZCxFQUEwQjtBQUN4QkwsY0FBVU0sY0FBVixDQUF5QkYsU0FBekIsRUFBb0NILElBQXBDO0FBQ0E7QUFDRDs7QUFFRCxNQUFJRyxVQUFVRyxLQUFkLEVBQXFCO0FBQ25CLFFBQU1BLFNBQVFILFVBQVVHLEtBQVYsQ0FBZ0JDLEdBQWhCLENBQW9CUCxJQUFwQixDQUFkO0FBQ0EsUUFBTVEsT0FBTUwsVUFBVU0sR0FBVixDQUFjLE9BQWQsRUFBdUJILE1BQXZCLENBQVo7QUFDQVAsY0FBVVcsTUFBVixDQUFpQkYsSUFBakI7QUFDQTtBQUNEOztBQUVELE1BQU1GLFFBQVFKLFNBQVNTLGVBQVQsQ0FBeUJSLFNBQXpCLEVBQW9DSSxHQUFwQyxDQUF3Q1AsSUFBeEMsQ0FBZDtBQUNBLE1BQU1RLE1BQU1MLFVBQVVNLEdBQVYsQ0FBYyxPQUFkLEVBQXVCSCxLQUF2QixDQUFaO0FBQ0FQLFlBQVVXLE1BQVYsQ0FBaUJG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IE5vcm1hbGl6ZSBmcm9tICcuLi91dGlscy9ub3JtYWxpemUnXG5cbi8qKlxuICogVHJhbnNmb3Jtcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IFRyYW5zZm9ybXMgPSB7fVxuXG4vKipcbiAqIEFkZCBhIGBtYXJrYCB0byB0aGUgY2hhcmFjdGVycyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtNYXJrfSBtYXJrXG4gKi9cblxuVHJhbnNmb3Jtcy5hZGRNYXJrID0gKHRyYW5zZm9ybSwgbWFyaykgPT4ge1xuICBtYXJrID0gTm9ybWFsaXplLm1hcmsobWFyaylcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcblxuICBpZiAoc2VsZWN0aW9uLmlzRXhwYW5kZWQpIHtcbiAgICB0cmFuc2Zvcm0uYWRkTWFya0F0UmFuZ2Uoc2VsZWN0aW9uLCBtYXJrKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHNlbGVjdGlvbi5tYXJrcykge1xuICAgIGNvbnN0IG1hcmtzID0gc2VsZWN0aW9uLm1hcmtzLmFkZChtYXJrKVxuICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5zZXQoJ21hcmtzJywgbWFya3MpXG4gICAgdHJhbnNmb3JtLnNlbGVjdChzZWwpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBtYXJrcyA9IGRvY3VtZW50LmdldE1hcmtzQXRSYW5nZShzZWxlY3Rpb24pLmFkZChtYXJrKVxuICBjb25zdCBzZWwgPSBzZWxlY3Rpb24uc2V0KCdtYXJrcycsIG1hcmtzKVxuICB0cmFuc2Zvcm0uc2VsZWN0KHNlbClcbn1cblxuLyoqXG4gKiBEZWxldGUgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZSA9ICh0cmFuc2Zvcm0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSByZXR1cm5cblxuICB0cmFuc2Zvcm1cbiAgICAuc25hcHNob3RTZWxlY3Rpb24oKVxuICAgIC5kZWxldGVBdFJhbmdlKHNlbGVjdGlvbilcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCB0byB0aGUgc3RhcnQsIGJlY2F1c2UgaW4gY2VydGFpblxuICAgIC8vIGNhc2VzIHdoZW4gZGVsZXRpbmcgYWNyb3NzIGlubGluZSBub2RlcyB0aGlzIGlzbid0IGd1YXJhbnRlZWQuXG4gICAgLmNvbGxhcHNlVG9TdGFydCgpXG4gICAgLnNuYXBzaG90U2VsZWN0aW9uKClcbn1cblxuLyoqXG4gKiBEZWxldGUgYmFja3dhcmQgYG5gIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIChvcHRpb25hbClcbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZUJhY2t3YXJkID0gKHRyYW5zZm9ybSwgbiA9IDEpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICB0cmFuc2Zvcm0uZGVsZXRlQmFja3dhcmRBdFJhbmdlKHNlbGVjdGlvbiwgbilcbn1cblxuLyoqXG4gKiBEZWxldGUgYmFja3dhcmQgdW50aWwgdGhlIGNoYXJhY3RlciBib3VuZGFyeSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICovXG5cblRyYW5zZm9ybXMuZGVsZXRlQ2hhckJhY2t3YXJkID0gKHRyYW5zZm9ybSkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIHRyYW5zZm9ybS5kZWxldGVDaGFyQmFja3dhcmRBdFJhbmdlKHNlbGVjdGlvbilcbn1cblxuLyoqXG4gKiBEZWxldGUgYmFja3dhcmQgdW50aWwgdGhlIGxpbmUgYm91bmRhcnkgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZUxpbmVCYWNrd2FyZCA9ICh0cmFuc2Zvcm0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICB0cmFuc2Zvcm0uZGVsZXRlTGluZUJhY2t3YXJkQXRSYW5nZShzZWxlY3Rpb24pXG59XG5cbi8qKlxuICogRGVsZXRlIGJhY2t3YXJkIHVudGlsIHRoZSB3b3JkIGJvdW5kYXJ5IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKi9cblxuVHJhbnNmb3Jtcy5kZWxldGVXb3JkQmFja3dhcmQgPSAodHJhbnNmb3JtKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgdHJhbnNmb3JtLmRlbGV0ZVdvcmRCYWNrd2FyZEF0UmFuZ2Uoc2VsZWN0aW9uKVxufVxuXG4vKipcbiAqIERlbGV0ZSBmb3J3YXJkIGBuYCBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge051bWJlcn0gbiAob3B0aW9uYWwpXG4gKi9cblxuVHJhbnNmb3Jtcy5kZWxldGVGb3J3YXJkID0gKHRyYW5zZm9ybSwgbiA9IDEpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICB0cmFuc2Zvcm0uZGVsZXRlRm9yd2FyZEF0UmFuZ2Uoc2VsZWN0aW9uLCBuKVxufVxuXG4vKipcbiAqIERlbGV0ZSBmb3J3YXJkIHVudGlsIHRoZSBjaGFyYWN0ZXIgYm91bmRhcnkgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZUNoYXJGb3J3YXJkID0gKHRyYW5zZm9ybSkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIHRyYW5zZm9ybS5kZWxldGVDaGFyRm9yd2FyZEF0UmFuZ2Uoc2VsZWN0aW9uKVxufVxuXG4vKipcbiAqIERlbGV0ZSBmb3J3YXJkIHVudGlsIHRoZSBsaW5lIGJvdW5kYXJ5IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKi9cblxuVHJhbnNmb3Jtcy5kZWxldGVMaW5lRm9yd2FyZCA9ICh0cmFuc2Zvcm0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICB0cmFuc2Zvcm0uZGVsZXRlTGluZUZvcndhcmRBdFJhbmdlKHNlbGVjdGlvbilcbn1cblxuLyoqXG4gKiBEZWxldGUgZm9yd2FyZCB1bnRpbCB0aGUgd29yZCBib3VuZGFyeSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICovXG5cblRyYW5zZm9ybXMuZGVsZXRlV29yZEZvcndhcmQgPSAodHJhbnNmb3JtKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgdHJhbnNmb3JtLmRlbGV0ZVdvcmRGb3J3YXJkQXRSYW5nZShzZWxlY3Rpb24pXG59XG5cbi8qKlxuICogSW5zZXJ0IGEgYGJsb2NrYCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEJsb2NrfSBibG9ja1xuICovXG5cblRyYW5zZm9ybXMuaW5zZXJ0QmxvY2sgPSAodHJhbnNmb3JtLCBibG9jaykgPT4ge1xuICBibG9jayA9IE5vcm1hbGl6ZS5ibG9jayhibG9jaylcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICB0cmFuc2Zvcm0uaW5zZXJ0QmxvY2tBdFJhbmdlKHNlbGVjdGlvbiwgYmxvY2spXG5cbiAgLy8gSWYgdGhlIG5vZGUgd2FzIHN1Y2Nlc3NmdWxseSBpbnNlcnRlZCwgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gIGNvbnN0IG5vZGUgPSB0cmFuc2Zvcm0uc3RhdGUuZG9jdW1lbnQuZ2V0Tm9kZShibG9jay5rZXkpXG4gIGlmIChub2RlKSB0cmFuc2Zvcm0uY29sbGFwc2VUb0VuZE9mKG5vZGUpXG59XG5cbi8qKlxuICogSW5zZXJ0IGEgYGZyYWdtZW50YCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtEb2N1bWVudH0gZnJhZ21lbnRcbiAqL1xuXG5UcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50ID0gKHRyYW5zZm9ybSwgZnJhZ21lbnQpID0+IHtcbiAgbGV0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuXG4gIGlmICghZnJhZ21lbnQubm9kZXMuc2l6ZSkgcmV0dXJuXG5cbiAgY29uc3QgeyBzdGFydFRleHQsIGVuZFRleHQgfSA9IHN0YXRlXG4gIGNvbnN0IGxhc3RUZXh0ID0gZnJhZ21lbnQuZ2V0TGFzdFRleHQoKVxuICBjb25zdCBsYXN0SW5saW5lID0gZnJhZ21lbnQuZ2V0Q2xvc2VzdElubGluZShsYXN0VGV4dC5rZXkpXG4gIGNvbnN0IGtleXMgPSBkb2N1bWVudC5nZXRUZXh0cygpLm1hcCh0ZXh0ID0+IHRleHQua2V5KVxuICBjb25zdCBpc0FwcGVuZGluZyA9IChcbiAgICBzZWxlY3Rpb24uaGFzRWRnZUF0RW5kT2YoZW5kVGV4dCkgfHxcbiAgICBzZWxlY3Rpb24uaGFzRWRnZUF0U3RhcnRPZihzdGFydFRleHQpXG4gIClcblxuICB0cmFuc2Zvcm0uZGVzZWxlY3QoKVxuICB0cmFuc2Zvcm0uaW5zZXJ0RnJhZ21lbnRBdFJhbmdlKHNlbGVjdGlvbiwgZnJhZ21lbnQpXG4gIHN0YXRlID0gdHJhbnNmb3JtLnN0YXRlXG4gIGRvY3VtZW50ID0gc3RhdGUuZG9jdW1lbnRcblxuICBjb25zdCBuZXdUZXh0cyA9IGRvY3VtZW50LmdldFRleHRzKCkuZmlsdGVyKG4gPT4gIWtleXMuaW5jbHVkZXMobi5rZXkpKVxuICBjb25zdCBuZXdUZXh0ID0gaXNBcHBlbmRpbmcgPyBuZXdUZXh0cy5sYXN0KCkgOiBuZXdUZXh0cy50YWtlTGFzdCgyKS5maXJzdCgpXG4gIGxldCBhZnRlclxuXG4gIGlmIChuZXdUZXh0ICYmIGxhc3RJbmxpbmUpIHtcbiAgICBhZnRlciA9IHNlbGVjdGlvbi5jb2xsYXBzZVRvRW5kT2YobmV3VGV4dClcbiAgfVxuXG4gIGVsc2UgaWYgKG5ld1RleHQpIHtcbiAgICBhZnRlciA9IHNlbGVjdGlvblxuICAgICAgLmNvbGxhcHNlVG9TdGFydE9mKG5ld1RleHQpXG4gICAgICAubW92ZShsYXN0VGV4dC5sZW5ndGgpXG4gIH1cblxuICBlbHNlIHtcbiAgICBhZnRlciA9IHNlbGVjdGlvblxuICAgICAgLmNvbGxhcHNlVG9TdGFydCgpXG4gICAgICAubW92ZShsYXN0VGV4dC5sZW5ndGgpXG4gIH1cblxuICB0cmFuc2Zvcm0uc2VsZWN0KGFmdGVyKVxufVxuXG4vKipcbiAqIEluc2VydCBhIGBpbmxpbmVgIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QmxvY2t9IGlubGluZVxuICovXG5cblRyYW5zZm9ybXMuaW5zZXJ0SW5saW5lID0gKHRyYW5zZm9ybSwgaW5saW5lKSA9PiB7XG4gIGlubGluZSA9IE5vcm1hbGl6ZS5pbmxpbmUoaW5saW5lKVxuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIHRyYW5zZm9ybS5pbnNlcnRJbmxpbmVBdFJhbmdlKHNlbGVjdGlvbiwgaW5saW5lKVxuXG4gIC8vIElmIHRoZSBub2RlIHdhcyBzdWNjZXNzZnVsbHkgaW5zZXJ0ZWQsIHVwZGF0ZSB0aGUgc2VsZWN0aW9uLlxuICBjb25zdCBub2RlID0gdHJhbnNmb3JtLnN0YXRlLmRvY3VtZW50LmdldE5vZGUoaW5saW5lLmtleSlcbiAgaWYgKG5vZGUpIHRyYW5zZm9ybS5jb2xsYXBzZVRvRW5kT2Yobm9kZSlcbn1cblxuLyoqXG4gKiBJbnNlcnQgYSBgdGV4dGAgc3RyaW5nIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtTZXQ8TWFyaz59IG1hcmtzIChvcHRpb25hbClcbiAqL1xuXG5UcmFuc2Zvcm1zLmluc2VydFRleHQgPSAodHJhbnNmb3JtLCB0ZXh0LCBtYXJrcykgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBtYXJrcyA9IG1hcmtzIHx8IHNlbGVjdGlvbi5tYXJrc1xuICB0cmFuc2Zvcm0uaW5zZXJ0VGV4dEF0UmFuZ2Uoc2VsZWN0aW9uLCB0ZXh0LCBtYXJrcylcblxuICAvLyBJZiB0aGUgdGV4dCB3YXMgc3VjY2Vzc2Z1bGx5IGluc2VydGVkLCBhbmQgdGhlIHNlbGVjdGlvbiBoYWQgbWFya3Mgb24gaXQsXG4gIC8vIHVuc2V0IHRoZSBzZWxlY3Rpb24ncyBtYXJrcy5cbiAgaWYgKHNlbGVjdGlvbi5tYXJrcyAmJiBkb2N1bWVudCAhPSB0cmFuc2Zvcm0uc3RhdGUuZG9jdW1lbnQpIHtcbiAgICB0cmFuc2Zvcm0uc2VsZWN0KHsgbWFya3M6IG51bGwgfSlcbiAgfVxufVxuXG4vKipcbiAqIFNldCBgcHJvcGVydGllc2Agb2YgdGhlIGJsb2NrIG5vZGVzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICovXG5cblRyYW5zZm9ybXMuc2V0QmxvY2sgPSAodHJhbnNmb3JtLCBwcm9wZXJ0aWVzKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgdHJhbnNmb3JtLnNldEJsb2NrQXRSYW5nZShzZWxlY3Rpb24sIHByb3BlcnRpZXMpXG59XG5cbi8qKlxuICogU2V0IGBwcm9wZXJ0aWVzYCBvZiB0aGUgaW5saW5lIG5vZGVzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICovXG5cblRyYW5zZm9ybXMuc2V0SW5saW5lID0gKHRyYW5zZm9ybSwgcHJvcGVydGllcykgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIHRyYW5zZm9ybS5zZXRJbmxpbmVBdFJhbmdlKHNlbGVjdGlvbiwgcHJvcGVydGllcylcbn1cblxuLyoqXG4gKiBTcGxpdCB0aGUgYmxvY2sgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHRvIG9wdGlvbmFsIGBkZXB0aGAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIChvcHRpb25hbClcbiAqL1xuXG5UcmFuc2Zvcm1zLnNwbGl0QmxvY2sgPSAodHJhbnNmb3JtLCBkZXB0aCA9IDEpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICB0cmFuc2Zvcm1cbiAgICAuc25hcHNob3RTZWxlY3Rpb24oKVxuICAgIC5zcGxpdEJsb2NrQXRSYW5nZShzZWxlY3Rpb24sIGRlcHRoKVxuICAgIC5jb2xsYXBzZVRvRW5kKClcbiAgICAuc25hcHNob3RTZWxlY3Rpb24oKVxufVxuXG4vKipcbiAqIFNwbGl0IHRoZSBpbmxpbmUgbm9kZXMgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCB0byBvcHRpb25hbCBgZGVwdGhgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCAob3B0aW9uYWwpXG4gKi9cblxuVHJhbnNmb3Jtcy5zcGxpdElubGluZSA9ICh0cmFuc2Zvcm0sIGRlcHRoID0gSW5maW5pdHkpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICB0cmFuc2Zvcm1cbiAgICAuc25hcHNob3RTZWxlY3Rpb24oKVxuICAgIC5zcGxpdElubGluZUF0UmFuZ2Uoc2VsZWN0aW9uLCBkZXB0aClcbiAgICAuc25hcHNob3RTZWxlY3Rpb24oKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIGBtYXJrYCBmcm9tIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge01hcmt9IG1hcmtcbiAqL1xuXG5UcmFuc2Zvcm1zLnJlbW92ZU1hcmsgPSAodHJhbnNmb3JtLCBtYXJrKSA9PiB7XG4gIG1hcmsgPSBOb3JtYWxpemUubWFyayhtYXJrKVxuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuXG4gIGlmIChzZWxlY3Rpb24uaXNFeHBhbmRlZCkge1xuICAgIHRyYW5zZm9ybS5yZW1vdmVNYXJrQXRSYW5nZShzZWxlY3Rpb24sIG1hcmspXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZWN0aW9uLm1hcmtzKSB7XG4gICAgY29uc3QgbWFya3MgPSBzZWxlY3Rpb24ubWFya3MucmVtb3ZlKG1hcmspXG4gICAgY29uc3Qgc2VsID0gc2VsZWN0aW9uLnNldCgnbWFya3MnLCBtYXJrcylcbiAgICB0cmFuc2Zvcm0uc2VsZWN0KHNlbClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG1hcmtzID0gZG9jdW1lbnQuZ2V0TWFya3NBdFJhbmdlKHNlbGVjdGlvbikucmVtb3ZlKG1hcmspXG4gIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5zZXQoJ21hcmtzJywgbWFya3MpXG4gIHRyYW5zZm9ybS5zZWxlY3Qoc2VsKVxufVxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgYSBgbWFya2AgZnJvbSB0aGUgY2hhcmFjdGVycyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24sXG4gKiBkZXBlbmRpbmcgb24gd2hldGhlciBpdCdzIGFscmVhZHkgdGhlcmUuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtNYXJrfSBtYXJrXG4gKi9cblxuVHJhbnNmb3Jtcy50b2dnbGVNYXJrID0gKHRyYW5zZm9ybSwgbWFyaykgPT4ge1xuICBtYXJrID0gTm9ybWFsaXplLm1hcmsobWFyaylcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IGV4aXN0cyA9IHN0YXRlLm1hcmtzLnNvbWUobSA9PiBtLmVxdWFscyhtYXJrKSlcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgdHJhbnNmb3JtLnJlbW92ZU1hcmsobWFyaylcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2Zvcm0uYWRkTWFyayhtYXJrKVxuICB9XG59XG5cbi8qKlxuICogVW53cmFwIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmcm9tIGEgYmxvY2sgcGFyZW50IHdpdGggYHByb3BlcnRpZXNgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydGllc1xuICovXG5cblRyYW5zZm9ybXMudW53cmFwQmxvY2sgPSAodHJhbnNmb3JtLCBwcm9wZXJ0aWVzKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgdHJhbnNmb3JtLnVud3JhcEJsb2NrQXRSYW5nZShzZWxlY3Rpb24sIHByb3BlcnRpZXMpXG59XG5cbi8qKlxuICogVW53cmFwIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmcm9tIGFuIGlubGluZSBwYXJlbnQgd2l0aCBgcHJvcGVydGllc2AuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wZXJ0aWVzXG4gKi9cblxuVHJhbnNmb3Jtcy51bndyYXBJbmxpbmUgPSAodHJhbnNmb3JtLCBwcm9wZXJ0aWVzKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgdHJhbnNmb3JtLnVud3JhcElubGluZUF0UmFuZ2Uoc2VsZWN0aW9uLCBwcm9wZXJ0aWVzKVxufVxuXG4vKipcbiAqIFdyYXAgdGhlIGJsb2NrIG5vZGVzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIGEgbmV3IGJsb2NrIG5vZGUgd2l0aFxuICogYHByb3BlcnRpZXNgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydGllc1xuICovXG5cblRyYW5zZm9ybXMud3JhcEJsb2NrID0gKHRyYW5zZm9ybSwgcHJvcGVydGllcykgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIHRyYW5zZm9ybS53cmFwQmxvY2tBdFJhbmdlKHNlbGVjdGlvbiwgcHJvcGVydGllcylcbn1cblxuLyoqXG4gKiBXcmFwIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiBuZXcgaW5saW5lIG5vZGVzIHdpdGggYHByb3BlcnRpZXNgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydGllc1xuICovXG5cblRyYW5zZm9ybXMud3JhcElubGluZSA9ICh0cmFuc2Zvcm0sIHByb3BlcnRpZXMpID0+IHtcbiAgbGV0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBsZXQgYWZ0ZXJcblxuICBjb25zdCB7IHN0YXJ0S2V5IH0gPSBzZWxlY3Rpb25cblxuICB0cmFuc2Zvcm0uZGVzZWxlY3QoKVxuICB0cmFuc2Zvcm0ud3JhcElubGluZUF0UmFuZ2Uoc2VsZWN0aW9uLCBwcm9wZXJ0aWVzKVxuICBzdGF0ZSA9IHRyYW5zZm9ybS5zdGF0ZVxuICBkb2N1bWVudCA9IHN0YXRlLmRvY3VtZW50XG5cbiAgLy8gRGV0ZXJtaW5lIHdoYXQgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgYWZ0ZXIgd3JhcHBpbmcuXG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICBhZnRlciA9IHNlbGVjdGlvblxuICB9XG5cbiAgZWxzZSBpZiAoc2VsZWN0aW9uLnN0YXJ0T2Zmc2V0ID09IDApIHtcbiAgICAvLyBGaW5kIHRoZSBpbmxpbmUgdGhhdCBoYXMgYmVlbiBpbnNlcnRlZC5cbiAgICAvLyBXZSB3YW50IHRvIGhhbmRsZSBtdWx0aXBsZSB3cmFwLCBzbyB3ZSBuZWVkIHRvIHRha2UgdGhlIGhpZ2hlc3QgcGFyZW50XG4gICAgY29uc3QgaW5saW5lID0gZG9jdW1lbnQuZ2V0QW5jZXN0b3JzKHN0YXJ0S2V5KVxuICAgICAgLmZpbmQocGFyZW50ID0+IChcbiAgICAgICAgcGFyZW50LmtpbmQgPT0gJ2lubGluZScgJiZcbiAgICAgICAgcGFyZW50LmdldE9mZnNldChzdGFydEtleSkgPT0gMFxuICAgICAgKSlcblxuICAgIGNvbnN0IHN0YXJ0ID0gaW5saW5lID8gZG9jdW1lbnQuZ2V0UHJldmlvdXNUZXh0KGlubGluZS5nZXRGaXJzdFRleHQoKS5rZXkpIDogZG9jdW1lbnQuZ2V0Rmlyc3RUZXh0KClcbiAgICBjb25zdCBlbmQgPSBkb2N1bWVudC5nZXROZXh0VGV4dChpbmxpbmUgPyBpbmxpbmUuZ2V0TGFzdFRleHQoKS5rZXkgOiBzdGFydC5rZXkpXG5cbiAgICAvLyBNb3ZlIHNlbGVjdGlvbiB0byB3cmFwIGFyb3VuZCB0aGUgaW5saW5lXG4gICAgYWZ0ZXIgPSBzZWxlY3Rpb25cbiAgICAgIC5tb3ZlQW5jaG9yVG9FbmRPZihzdGFydClcbiAgICAgIC5tb3ZlRm9jdXNUb1N0YXJ0T2YoZW5kKVxuICB9XG5cbiAgZWxzZSBpZiAoc2VsZWN0aW9uLnN0YXJ0S2V5ID09IHNlbGVjdGlvbi5lbmRLZXkpIHtcbiAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0TmV4dFRleHQoc2VsZWN0aW9uLnN0YXJ0S2V5KVxuICAgIGFmdGVyID0gc2VsZWN0aW9uLm1vdmVUb1JhbmdlT2YodGV4dClcbiAgfVxuXG4gIGVsc2Uge1xuICAgIGNvbnN0IGFuY2hvciA9IGRvY3VtZW50LmdldE5leHRUZXh0KHNlbGVjdGlvbi5hbmNob3JLZXkpXG4gICAgY29uc3QgZm9jdXMgPSBkb2N1bWVudC5nZXREZXNjZW5kYW50KHNlbGVjdGlvbi5mb2N1c0tleSlcbiAgICBhZnRlciA9IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICBhbmNob3JLZXk6IGFuY2hvci5rZXksXG4gICAgICBhbmNob3JPZmZzZXQ6IDAsXG4gICAgICBmb2N1c0tleTogZm9jdXMua2V5LFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH0pXG4gIH1cblxuICBhZnRlciA9IGFmdGVyLm5vcm1hbGl6ZShkb2N1bWVudClcbiAgdHJhbnNmb3JtLnNlbGVjdChhZnRlcilcbn1cblxuLyoqXG4gKiBXcmFwIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHByZWZpeC9zdWZmaXguXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHBhcmFtIHtTdHJpbmd9IHN1ZmZpeFxuICovXG5cblRyYW5zZm9ybXMud3JhcFRleHQgPSAodHJhbnNmb3JtLCBwcmVmaXgsIHN1ZmZpeCA9IHByZWZpeCkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIHRyYW5zZm9ybS53cmFwVGV4dEF0UmFuZ2Uoc2VsZWN0aW9uLCBwcmVmaXgsIHN1ZmZpeClcblxuICAvLyBJZiB0aGUgc2VsZWN0aW9uIHdhcyBjb2xsYXBzZWQsIGl0IHdpbGwgaGF2ZSBtb3ZlZCB0aGUgc3RhcnQgb2Zmc2V0IHRvby5cbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgIHRyYW5zZm9ybS5tb3ZlU3RhcnQoMCAtIHByZWZpeC5sZW5ndGgpXG4gIH1cblxuICAvLyBBZGRpbmcgdGhlIHN1ZmZpeCB3aWxsIGhhdmUgcHVzaGVkIHRoZSBlbmQgb2YgdGhlIHNlbGVjdGlvbiBmdXJ0aGVyIG9uLCBzb1xuICAvLyB3ZSBuZWVkIHRvIG1vdmUgaXQgYmFjayB0byBhY2NvdW50IGZvciB0aGlzLlxuICB0cmFuc2Zvcm0ubW92ZUVuZCgwIC0gc3VmZml4Lmxlbmd0aClcblxuICAvLyBUaGVyZSdzIGEgY2hhbmNlIHRoYXQgdGhlIHNlbGVjdGlvbiBwb2ludHMgbW92ZWQgXCJ0aHJvdWdoXCIgZWFjaCBvdGhlcixcbiAgLy8gcmVzdWx0aW5nIGluIGEgbm93LWluY29ycmVjdCBzZWxlY3Rpb24gZGlyZWN0aW9uLlxuICBpZiAoc2VsZWN0aW9uLmlzRm9yd2FyZCAhPSB0cmFuc2Zvcm0uc3RhdGUuc2VsZWN0aW9uLmlzRm9yd2FyZCkge1xuICAgIHRyYW5zZm9ybS5mbGlwKClcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybXNcbiJdfQ==