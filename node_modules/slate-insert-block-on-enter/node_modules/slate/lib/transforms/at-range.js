'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _normalize = require('../utils/normalize');

var _normalize2 = _interopRequireDefault(_normalize);

var _string = require('../utils/string');

var _string2 = _interopRequireDefault(_string);

var _core = require('../schemas/core');

var _core2 = _interopRequireDefault(_core);

var _immutable = require('immutable');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transforms.
 *
 * @type {Object}
 */

/* eslint no-console: 0 */

var Transforms = {};

/**
 * An options object with normalize set to `false`.
 *
 * @type {Object}
 */

var OPTS = {
  normalize: false
};

/**
 * Add a new `mark` to the characters at `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Mixed} mark
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.addMarkAtRange = function (transform, range, mark) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (range.isCollapsed) return;

  var _options$normalize = options.normalize,
      normalize = _options$normalize === undefined ? true : _options$normalize;
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset,
      endKey = range.endKey,
      endOffset = range.endOffset;

  var texts = document.getTextsAtRange(range);

  texts.forEach(function (text) {
    var key = text.key;

    var index = 0;
    var length = text.length;

    if (key == startKey) index = startOffset;
    if (key == endKey) length = endOffset;
    if (key == startKey && key == endKey) length = endOffset - startOffset;

    transform.addMarkByKey(key, index, length, mark, { normalize: normalize });
  });
};

/**
 * Delete everything in a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteAtRange = function (transform, range) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (range.isCollapsed) return;

  var _options$normalize2 = options.normalize,
      normalize = _options$normalize2 === undefined ? true : _options$normalize2;
  var startKey = range.startKey,
      startOffset = range.startOffset,
      endKey = range.endKey,
      endOffset = range.endOffset;

  // If the start and end key are the same, we can just remove text.

  if (startKey == endKey) {
    var index = startOffset;
    var length = endOffset - startOffset;
    transform.removeTextByKey(startKey, index, length, { normalize: normalize });
    return;
  }

  // Split at the range edges within a common ancestor, without normalizing.
  var state = transform.state;
  var _state = state,
      document = _state.document;

  var ancestor = document.getCommonAncestor(startKey, endKey);
  var startChild = ancestor.getFurthestAncestor(startKey);
  var endChild = ancestor.getFurthestAncestor(endKey);
  var startOff = (startChild.kind == 'text' ? 0 : startChild.getOffset(startKey)) + startOffset;
  var endOff = (endChild.kind == 'text' ? 0 : endChild.getOffset(endKey)) + endOffset;

  transform.splitNodeByKey(startChild.key, startOff, OPTS);
  transform.splitNodeByKey(endChild.key, endOff, OPTS);

  // Refresh variables.
  state = transform.state;
  document = state.document;
  ancestor = document.getCommonAncestor(startKey, endKey);
  startChild = ancestor.getFurthestAncestor(startKey);
  endChild = ancestor.getFurthestAncestor(endKey);
  var startIndex = ancestor.nodes.indexOf(startChild);
  var endIndex = ancestor.nodes.indexOf(endChild);
  var middles = ancestor.nodes.slice(startIndex + 1, endIndex + 1);

  // Remove all of the middle nodes, between the splits.
  if (middles.size) {
    middles.forEach(function (child) {
      transform.removeNodeByKey(child.key, OPTS);
    });
  }

  // If the start and end block are different, move all of the nodes from the
  // end block into the start block.
  var startBlock = document.getClosestBlock(startKey);
  var endBlock = document.getClosestBlock(document.getNextText(endKey).key);

  if (startBlock.key !== endBlock.key) {
    endBlock.nodes.forEach(function (child, i) {
      var newKey = startBlock.key;
      var newIndex = startBlock.nodes.size + i;
      transform.moveNodeByKey(child.key, newKey, newIndex, OPTS);
    });

    // Remove parents of endBlock as long as they have a single child
    var lonely = document.getFurthestOnlyChildAncestor(endBlock.key) || endBlock;
    transform.removeNodeByKey(lonely.key, OPTS);
  }

  if (normalize) {
    transform.normalizeNodeByKey(ancestor.key, _core2.default);
  }
};

/**
 * Delete backward until the character boundary at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteCharBackwardAtRange = function (transform, range, options) {
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset;

  var startBlock = document.getClosestBlock(startKey);
  var offset = startBlock.getOffset(startKey);
  var o = offset + startOffset;
  var text = startBlock.text;

  var n = _string2.default.getCharOffsetBackward(text, o);
  transform.deleteBackwardAtRange(range, n, options);
};

/**
 * Delete backward until the line boundary at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteLineBackwardAtRange = function (transform, range, options) {
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset;

  var startBlock = document.getClosestBlock(startKey);
  var offset = startBlock.getOffset(startKey);
  var o = offset + startOffset;
  transform.deleteBackwardAtRange(range, o, options);
};

/**
 * Delete backward until the word boundary at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteWordBackwardAtRange = function (transform, range, options) {
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset;

  var startBlock = document.getClosestBlock(startKey);
  var offset = startBlock.getOffset(startKey);
  var o = offset + startOffset;
  var text = startBlock.text;

  var n = _string2.default.getWordOffsetBackward(text, o);
  transform.deleteBackwardAtRange(range, n, options);
};

/**
 * Delete backward `n` characters at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Number} n (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteBackwardAtRange = function (transform, range) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize3 = options.normalize,
      normalize = _options$normalize3 === undefined ? true : _options$normalize3;
  var state = transform.state;
  var document = state.document;
  var _range = range,
      startKey = _range.startKey,
      focusOffset = _range.focusOffset;

  // If the range is expanded, perform a regular delete instead.

  if (range.isExpanded) {
    transform.deleteAtRange(range, { normalize: normalize });
    return;
  }

  var block = document.getClosestBlock(startKey);
  // If the closest block is void, delete it.
  if (block && block.isVoid) {
    transform.removeNodeByKey(block.key, { normalize: normalize });
    return;
  }
  // If the closest is not void, but empty, remove it
  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {
    transform.removeNodeByKey(block.key, { normalize: normalize });
    return;
  }

  // If the closest inline is void, delete it.
  var inline = document.getClosestInline(startKey);
  if (inline && inline.isVoid) {
    transform.removeNodeByKey(inline.key, { normalize: normalize });
    return;
  }

  // If the range is at the start of the document, abort.
  if (range.isAtStartOf(document)) {
    return;
  }

  // If the range is at the start of the text node, we need to figure out what
  // is behind it to know how to delete...
  var text = document.getDescendant(startKey);
  if (range.isAtStartOf(text)) {
    var prev = document.getPreviousText(text.key);
    var prevBlock = document.getClosestBlock(prev.key);
    var prevInline = document.getClosestInline(prev.key);

    // If the previous block is void, remove it.
    if (prevBlock && prevBlock.isVoid) {
      transform.removeNodeByKey(prevBlock.key, { normalize: normalize });
      return;
    }

    // If the previous inline is void, remove it.
    if (prevInline && prevInline.isVoid) {
      transform.removeNodeByKey(prevInline.key, { normalize: normalize });
      return;
    }

    // If we're deleting by one character and the previous text node is not
    // inside the current block, we need to join the two blocks together.
    if (n == 1 && prevBlock != block) {
      range = range.merge({
        anchorKey: prev.key,
        anchorOffset: prev.length
      });

      transform.deleteAtRange(range, { normalize: normalize });
      return;
    }
  }

  // If the focus offset is farther than the number of characters to delete,
  // just remove the characters backwards inside the current node.
  if (n < focusOffset) {
    range = range.merge({
      focusOffset: focusOffset - n,
      isBackward: true
    });

    transform.deleteAtRange(range, { normalize: normalize });
    return;
  }

  // Otherwise, we need to see how many nodes backwards to go.
  var node = text;
  var offset = 0;
  var traversed = focusOffset;

  while (n > traversed) {
    node = document.getPreviousText(node.key);
    var next = traversed + node.length;
    if (n <= next) {
      offset = next - n;
      break;
    } else {
      traversed = next;
    }
  }

  // If the focus node is inside a void, go up until right after it.
  if (document.hasVoidParent(node.key)) {
    var parent = document.getClosestVoid(node.key);
    node = document.getNextText(parent.key);
    offset = 0;
  }

  range = range.merge({
    focusKey: node.key,
    focusOffset: offset,
    isBackward: true
  });

  transform.deleteAtRange(range, { normalize: normalize });
};

/**
 * Delete forward until the character boundary at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteCharForwardAtRange = function (transform, range, options) {
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset;

  var startBlock = document.getClosestBlock(startKey);
  var offset = startBlock.getOffset(startKey);
  var o = offset + startOffset;
  var text = startBlock.text;

  var n = _string2.default.getCharOffsetForward(text, o);
  transform.deleteForwardAtRange(range, n, options);
};

/**
 * Delete forward until the line boundary at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteLineForwardAtRange = function (transform, range, options) {
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset;

  var startBlock = document.getClosestBlock(startKey);
  var offset = startBlock.getOffset(startKey);
  var o = offset + startOffset;
  transform.deleteForwardAtRange(range, o, options);
};

/**
 * Delete forward until the word boundary at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteWordForwardAtRange = function (transform, range, options) {
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset;

  var startBlock = document.getClosestBlock(startKey);
  var offset = startBlock.getOffset(startKey);
  var o = offset + startOffset;
  var text = startBlock.text;

  var n = _string2.default.getWordOffsetForward(text, o);
  transform.deleteForwardAtRange(range, n, options);
};

/**
 * Delete forward `n` characters at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Number} n (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.deleteForwardAtRange = function (transform, range) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize4 = options.normalize,
      normalize = _options$normalize4 === undefined ? true : _options$normalize4;
  var state = transform.state;
  var document = state.document;
  var _range2 = range,
      startKey = _range2.startKey,
      focusOffset = _range2.focusOffset;

  // If the range is expanded, perform a regular delete instead.

  if (range.isExpanded) {
    transform.deleteAtRange(range, { normalize: normalize });
    return;
  }

  var block = document.getClosestBlock(startKey);
  // If the closest block is void, delete it.
  if (block && block.isVoid) {
    transform.removeNodeByKey(block.key, { normalize: normalize });
    return;
  }
  // If the closest is not void, but empty, remove it
  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {
    transform.removeNodeByKey(block.key, { normalize: normalize });
    return;
  }

  // If the closest inline is void, delete it.
  var inline = document.getClosestInline(startKey);
  if (inline && inline.isVoid) {
    transform.removeNodeByKey(inline.key, { normalize: normalize });
    return;
  }

  // If the range is at the start of the document, abort.
  if (range.isAtEndOf(document)) {
    return;
  }

  // If the range is at the start of the text node, we need to figure out what
  // is behind it to know how to delete...
  var text = document.getDescendant(startKey);
  if (range.isAtEndOf(text)) {
    var next = document.getNextText(text.key);
    var nextBlock = document.getClosestBlock(next.key);
    var nextInline = document.getClosestInline(next.key);

    // If the previous block is void, remove it.
    if (nextBlock && nextBlock.isVoid) {
      transform.removeNodeByKey(nextBlock.key, { normalize: normalize });
      return;
    }

    // If the previous inline is void, remove it.
    if (nextInline && nextInline.isVoid) {
      transform.removeNodeByKey(nextInline.key, { normalize: normalize });
      return;
    }

    // If we're deleting by one character and the previous text node is not
    // inside the current block, we need to join the two blocks together.
    if (n == 1 && nextBlock != block) {
      range = range.merge({
        focusKey: next.key,
        focusOffset: 0
      });

      transform.deleteAtRange(range, { normalize: normalize });
      return;
    }
  }

  // If the remaining characters to the end of the node is greater than or equal
  // to the number of characters to delete, just remove the characters forwards
  // inside the current node.
  if (n <= text.length - focusOffset) {
    range = range.merge({
      focusOffset: focusOffset + n
    });

    transform.deleteAtRange(range, { normalize: normalize });
    return;
  }

  // Otherwise, we need to see how many nodes forwards to go.
  var node = text;
  var offset = focusOffset;
  var traversed = text.length - focusOffset;

  while (n > traversed) {
    node = document.getNextText(node.key);
    var _next = traversed + node.length;
    if (n <= _next) {
      offset = n - traversed;
      break;
    } else {
      traversed = _next;
    }
  }

  // If the focus node is inside a void, go up until right before it.
  if (document.hasVoidParent(node.key)) {
    var parent = document.getClosestVoid(node.key);
    node = document.getPreviousText(parent.key);
    offset = node.length;
  }

  range = range.merge({
    focusKey: node.key,
    focusOffset: offset
  });

  transform.deleteAtRange(range, { normalize: normalize });
};

/**
 * Insert a `block` node at `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Block|String|Object} block
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.insertBlockAtRange = function (transform, range, block) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  block = _normalize2.default.block(block);
  var _options$normalize5 = options.normalize,
      normalize = _options$normalize5 === undefined ? true : _options$normalize5;


  if (range.isExpanded) {
    transform.deleteAtRange(range);
    range = range.collapseToStart();
  }

  var state = transform.state;
  var document = state.document;
  var _range3 = range,
      startKey = _range3.startKey,
      startOffset = _range3.startOffset;

  var startText = document.assertDescendant(startKey);
  var startBlock = document.getClosestBlock(startKey);
  var parent = document.getParent(startBlock.key);
  var index = parent.nodes.indexOf(startBlock);

  if (startBlock.isVoid) {
    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });
  } else if (startBlock.isEmpty) {
    transform.removeNodeByKey(startBlock.key);
    transform.insertNodeByKey(parent.key, index, block, { normalize: normalize });
  } else if (range.isAtStartOf(startBlock)) {
    transform.insertNodeByKey(parent.key, index, block, { normalize: normalize });
  } else if (range.isAtEndOf(startBlock)) {
    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });
  } else {
    var offset = startBlock.getOffset(startText.key) + startOffset;
    transform.splitNodeByKey(startBlock.key, offset, { normalize: normalize });
    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });
  }

  if (normalize) {
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Insert a `fragment` at a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Document} fragment
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.insertFragmentAtRange = function (transform, range, fragment) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize6 = options.normalize,
      normalize = _options$normalize6 === undefined ? true : _options$normalize6;

  // If the range is expanded, delete it first.

  if (range.isExpanded) {
    transform.deleteAtRange(range, OPTS);
    range = range.collapseToStart();
  }

  // If the fragment is empty, there's nothing to do after deleting.
  if (!fragment.nodes.size) return;

  // Regenerate the keys for all of the fragments nodes, so that they're
  // guaranteed not to collide with the existing keys in the document. Otherwise
  // they will be rengerated automatically and we won't have an easy way to
  // reference them.
  fragment = fragment.mapDescendants(function (child) {
    return child.regenerateKey();
  });

  // Calculate a few things...
  var _range4 = range,
      startKey = _range4.startKey,
      startOffset = _range4.startOffset;
  var state = transform.state;
  var _state2 = state,
      document = _state2.document;

  var startText = document.getDescendant(startKey);
  var startBlock = document.getClosestBlock(startText.key);
  var startChild = startBlock.getFurthestAncestor(startText.key);
  var isAtStart = range.isAtStartOf(startBlock);
  var parent = document.getParent(startBlock.key);
  var index = parent.nodes.indexOf(startBlock);
  var offset = startChild == startText ? startOffset : startChild.getOffset(startText.key) + startOffset;

  var blocks = fragment.getBlocks();
  var firstBlock = blocks.first();
  var lastBlock = blocks.last();

  // If the fragment only contains a void block, use `insertBlock` instead.
  if (firstBlock == lastBlock && firstBlock.isVoid) {
    transform.insertBlockAtRange(range, firstBlock, options);
    return;
  }

  // If the first and last block aren't the same, we need to insert all of the
  // nodes after the fragment's first block at the index.
  if (firstBlock != lastBlock) {
    var lonelyParent = fragment.getFurthest(firstBlock.key, function (p) {
      return p.nodes.size == 1;
    });
    var lonelyChild = lonelyParent || firstBlock;
    var startIndex = parent.nodes.indexOf(startBlock);
    fragment = fragment.removeDescendant(lonelyChild.key);

    fragment.nodes.forEach(function (node, i) {
      var newIndex = startIndex + i + 1;
      transform.insertNodeByKey(parent.key, newIndex, node, OPTS);
    });
  }

  // Check if we need to split the node.
  if (startOffset != 0) {
    transform.splitNodeByKey(startChild.key, offset, OPTS);
  }

  // Update our variables with the new state.
  state = transform.state;
  document = state.document;
  startText = document.getDescendant(startKey);
  startBlock = document.getClosestBlock(startKey);
  startChild = startBlock.getFurthestAncestor(startText.key);

  // If the first and last block aren't the same, we need to move any of the
  // starting block's children after the split into the last block of the
  // fragment, which has already been inserted.
  if (firstBlock != lastBlock) {
    var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);
    var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {
      return n.key == nextChild.key;
    }) : (0, _immutable.List)();
    var lastIndex = lastBlock.nodes.size;

    nextNodes.forEach(function (node, i) {
      var newIndex = lastIndex + i;
      transform.moveNodeByKey(node.key, lastBlock.key, newIndex, OPTS);
    });
  }

  // If the starting block is empty, we replace it entirely with the first block
  // of the fragment, since this leads to a more expected behavior for the user.
  if (startBlock.isEmpty) {
    transform.removeNodeByKey(startBlock.key, OPTS);
    transform.insertNodeByKey(parent.key, index, firstBlock, OPTS);
  }

  // Otherwise, we maintain the starting block, and insert all of the first
  // block's inline nodes into it at the split point.
  else {
      var inlineChild = startBlock.getFurthestAncestor(startText.key);
      var inlineIndex = startBlock.nodes.indexOf(inlineChild);

      firstBlock.nodes.forEach(function (inline, i) {
        var o = startOffset == 0 ? 0 : 1;
        var newIndex = inlineIndex + i + o;
        transform.insertNodeByKey(startBlock.key, newIndex, inline, OPTS);
      });
    }

  // Normalize if requested.
  if (normalize) {
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Insert an `inline` node at `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Inline|String|Object} inline
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.insertInlineAtRange = function (transform, range, inline) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize7 = options.normalize,
      normalize = _options$normalize7 === undefined ? true : _options$normalize7;

  inline = _normalize2.default.inline(inline);

  if (range.isExpanded) {
    transform.deleteAtRange(range, OPTS);
    range = range.collapseToStart();
  }

  var state = transform.state;
  var document = state.document;
  var _range5 = range,
      startKey = _range5.startKey,
      startOffset = _range5.startOffset;

  var parent = document.getParent(startKey);
  var startText = document.assertDescendant(startKey);
  var index = parent.nodes.indexOf(startText);

  if (parent.isVoid) return;

  transform.splitNodeByKey(startKey, startOffset, OPTS);
  transform.insertNodeByKey(parent.key, index + 1, inline, OPTS);

  if (normalize) {
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Insert `text` at a `range`, with optional `marks`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {String} text
 * @param {Set<Mark>} marks (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.insertTextAtRange = function (transform, range, text, marks) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var normalize = options.normalize;
  var state = transform.state;
  var document = state.document;
  var startKey = range.startKey,
      startOffset = range.startOffset;

  var parent = document.getParent(startKey);

  if (parent.isVoid) return;

  if (range.isExpanded) {
    transform.deleteAtRange(range, OPTS);
  }

  // PERF: Unless specified, don't normalize if only inserting text.
  if (normalize !== undefined) {
    normalize = range.isExpanded;
  }

  transform.insertTextByKey(startKey, startOffset, text, marks, { normalize: normalize });
};

/**
 * Remove an existing `mark` to the characters at `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Mark|String} mark (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.removeMarkAtRange = function (transform, range, mark) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (range.isCollapsed) return;

  var _options$normalize8 = options.normalize,
      normalize = _options$normalize8 === undefined ? true : _options$normalize8;
  var state = transform.state;
  var document = state.document;

  var texts = document.getTextsAtRange(range);
  var startKey = range.startKey,
      startOffset = range.startOffset,
      endKey = range.endKey,
      endOffset = range.endOffset;


  texts.forEach(function (text) {
    var key = text.key;

    var index = 0;
    var length = text.length;

    if (key == startKey) index = startOffset;
    if (key == endKey) length = endOffset;
    if (key == startKey && key == endKey) length = endOffset - startOffset;

    transform.removeMarkByKey(key, index, length, mark, { normalize: normalize });
  });
};

/**
 * Set the `properties` of block nodes in a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object|String} properties
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.setBlockAtRange = function (transform, range, properties) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize9 = options.normalize,
      normalize = _options$normalize9 === undefined ? true : _options$normalize9;
  var state = transform.state;
  var document = state.document;

  var blocks = document.getBlocksAtRange(range);

  blocks.forEach(function (block) {
    transform.setNodeByKey(block.key, properties, { normalize: normalize });
  });
};

/**
 * Set the `properties` of inline nodes in a `range`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Object|String} properties
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.setInlineAtRange = function (transform, range, properties) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize10 = options.normalize,
      normalize = _options$normalize10 === undefined ? true : _options$normalize10;
  var state = transform.state;
  var document = state.document;

  var inlines = document.getInlinesAtRange(range);

  inlines.forEach(function (inline) {
    transform.setNodeByKey(inline.key, properties, { normalize: normalize });
  });
};

/**
 * Split the block nodes at a `range`, to optional `height`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Number} height (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.splitBlockAtRange = function (transform, range) {
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize11 = options.normalize,
      normalize = _options$normalize11 === undefined ? true : _options$normalize11;


  if (range.isExpanded) {
    transform.deleteAtRange(range, { normalize: normalize });
    range = range.collapseToStart();
  }

  var _range6 = range,
      startKey = _range6.startKey,
      startOffset = _range6.startOffset;
  var state = transform.state;
  var document = state.document;

  var node = document.assertDescendant(startKey);
  var parent = document.getClosestBlock(node.key);
  var offset = startOffset;
  var h = 0;

  while (parent && parent.kind == 'block' && h < height) {
    offset += parent.getOffset(node.key);
    node = parent;
    parent = document.getClosestBlock(parent.key);
    h++;
  }

  transform.splitNodeByKey(node.key, offset, { normalize: normalize });
};

/**
 * Split the inline nodes at a `range`, to optional `height`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Number} height (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.splitInlineAtRange = function (transform, range) {
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$normalize12 = options.normalize,
      normalize = _options$normalize12 === undefined ? true : _options$normalize12;


  if (range.isExpanded) {
    transform.deleteAtRange(range, { normalize: normalize });
    range = range.collapseToStart();
  }

  var _range7 = range,
      startKey = _range7.startKey,
      startOffset = _range7.startOffset;
  var state = transform.state;
  var document = state.document;

  var node = document.assertDescendant(startKey);
  var parent = document.getClosestInline(node.key);
  var offset = startOffset;
  var h = 0;

  while (parent && parent.kind == 'inline' && h < height) {
    offset += parent.getOffset(node.key);
    node = parent;
    parent = document.getClosestInline(parent.key);
    h++;
  }

  transform.splitNodeByKey(node.key, offset, { normalize: normalize });
};

/**
 * Add or remove a `mark` from the characters at `range`, depending on whether
 * it's already there.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Mixed} mark
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.toggleMarkAtRange = function (transform, range, mark) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (range.isCollapsed) return;

  mark = _normalize2.default.mark(mark);

  var _options$normalize13 = options.normalize,
      normalize = _options$normalize13 === undefined ? true : _options$normalize13;
  var state = transform.state;
  var document = state.document;

  var marks = document.getMarksAtRange(range);
  var exists = marks.some(function (m) {
    return m.equals(mark);
  });

  if (exists) {
    transform.removeMarkAtRange(range, mark, { normalize: normalize });
  } else {
    transform.addMarkAtRange(range, mark, { normalize: normalize });
  }
};

/**
 * Unwrap all of the block nodes in a `range` from a block with `properties`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {String|Object} properties
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.unwrapBlockAtRange = function (transform, range, properties) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  properties = _normalize2.default.nodeProperties(properties);

  var _options$normalize14 = options.normalize,
      normalize = _options$normalize14 === undefined ? true : _options$normalize14;
  var state = transform.state;
  var _state3 = state,
      document = _state3.document;

  var blocks = document.getBlocksAtRange(range);
  var wrappers = blocks.map(function (block) {
    return document.getClosest(block.key, function (parent) {
      if (parent.kind != 'block') return false;
      if (properties.type != null && parent.type != properties.type) return false;
      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;
      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;
      return true;
    });
  }).filter(function (exists) {
    return exists;
  }).toOrderedSet().toList();

  wrappers.forEach(function (block) {
    var first = block.nodes.first();
    var last = block.nodes.last();
    var parent = document.getParent(block.key);
    var index = parent.nodes.indexOf(block);

    var children = block.nodes.filter(function (child) {
      return blocks.some(function (b) {
        return child == b || child.hasDescendant(b.key);
      });
    });

    var firstMatch = children.first();
    var lastMatch = children.last();

    if (first == firstMatch && last == lastMatch) {
      block.nodes.forEach(function (child, i) {
        transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);
      });

      transform.removeNodeByKey(block.key, OPTS);
    } else if (last == lastMatch) {
      block.nodes.skipUntil(function (n) {
        return n == firstMatch;
      }).forEach(function (child, i) {
        transform.moveNodeByKey(child.key, parent.key, index + 1 + i, OPTS);
      });
    } else if (first == firstMatch) {
      block.nodes.takeUntil(function (n) {
        return n == lastMatch;
      }).push(lastMatch).forEach(function (child, i) {
        transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);
      });
    } else {
      var offset = block.getOffset(firstMatch.key);

      transform.splitNodeByKey(block.key, offset, OPTS);
      state = transform.state;
      document = state.document;

      children.forEach(function (child, i) {
        if (i == 0) {
          var extra = child;
          child = document.getNextBlock(child.key);
          transform.removeNodeByKey(extra.key, OPTS);
        }

        transform.moveNodeByKey(child.key, parent.key, index + 1 + i, OPTS);
      });
    }
  });

  // TODO: optmize to only normalize the right block
  if (normalize) {
    transform.normalizeDocument(_core2.default);
  }
};

/**
 * Unwrap the inline nodes in a `range` from an inline with `properties`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {String|Object} properties
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.unwrapInlineAtRange = function (transform, range, properties) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  properties = _normalize2.default.nodeProperties(properties);

  var _options$normalize15 = options.normalize,
      normalize = _options$normalize15 === undefined ? true : _options$normalize15;
  var state = transform.state;
  var document = state.document;

  var texts = document.getTextsAtRange(range);
  var inlines = texts.map(function (text) {
    return document.getClosest(text.key, function (parent) {
      if (parent.kind != 'inline') return false;
      if (properties.type != null && parent.type != properties.type) return false;
      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;
      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;
      return true;
    });
  }).filter(function (exists) {
    return exists;
  }).toOrderedSet().toList();

  inlines.forEach(function (inline) {
    var parent = transform.state.document.getParent(inline.key);
    var index = parent.nodes.indexOf(inline);

    inline.nodes.forEach(function (child, i) {
      transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);
    });
  });

  // TODO: optmize to only normalize the right block
  if (normalize) {
    transform.normalizeDocument(_core2.default);
  }
};

/**
 * Wrap all of the blocks in a `range` in a new `block`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Block|Object|String} block
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.wrapBlockAtRange = function (transform, range, block) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  block = _normalize2.default.block(block);
  block = block.set('nodes', block.nodes.clear());

  var _options$normalize16 = options.normalize,
      normalize = _options$normalize16 === undefined ? true : _options$normalize16;
  var state = transform.state;
  var document = state.document;


  var blocks = document.getBlocksAtRange(range);
  var firstblock = blocks.first();
  var lastblock = blocks.last();
  var parent = void 0,
      siblings = void 0,
      index = void 0;

  // If there is only one block in the selection then we know the parent and
  // siblings.
  if (blocks.length === 1) {
    parent = document.getParent(firstblock.key);
    siblings = blocks;
  }

  // Determine closest shared parent to all blocks in selection.
  else {
      parent = document.getClosest(firstblock.key, function (p1) {
        return !!document.getClosest(lastblock.key, function (p2) {
          return p1 == p2;
        });
      });
    }

  // If no shared parent could be found then the parent is the document.
  if (parent == null) parent = document;

  // Create a list of direct children siblings of parent that fall in the
  // selection.
  if (siblings == null) {
    var indexes = parent.nodes.reduce(function (ind, node, i) {
      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;
      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;
      return ind;
    }, []);

    index = indexes[0];
    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);
  }

  // Get the index to place the new wrapped node at.
  if (index == null) {
    index = parent.nodes.indexOf(siblings.first());
  }

  // Inject the new block node into the parent.
  transform.insertNodeByKey(parent.key, index, block, OPTS);

  // Move the sibling nodes into the new block node.
  siblings.forEach(function (node, i) {
    transform.moveNodeByKey(node.key, block.key, i, OPTS);
  });

  if (normalize) {
    transform.normalizeNodeByKey(parent.key, _core2.default);
  }
};

/**
 * Wrap the text and inlines in a `range` in a new `inline`.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {Inline|Object|String} inline
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.wrapInlineAtRange = function (transform, range, inline) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var state = transform.state;
  var _state4 = state,
      document = _state4.document;
  var _options$normalize17 = options.normalize,
      normalize = _options$normalize17 === undefined ? true : _options$normalize17;
  var startKey = range.startKey,
      startOffset = range.startOffset,
      endKey = range.endKey,
      endOffset = range.endOffset;


  if (range.isCollapsed) {
    // Wrapping an inline void
    var inlineParent = document.getClosestInline(startKey);
    if (!inlineParent.isVoid) {
      return;
    }

    return transform.wrapInlineByKey(inlineParent.key, inline, options);
  }

  inline = _normalize2.default.inline(inline);
  inline = inline.set('nodes', inline.nodes.clear());

  var blocks = document.getBlocksAtRange(range);
  var startBlock = document.getClosestBlock(startKey);
  var endBlock = document.getClosestBlock(endKey);
  var startChild = startBlock.getFurthestAncestor(startKey);
  var endChild = endBlock.getFurthestAncestor(endKey);
  var startIndex = startBlock.nodes.indexOf(startChild);
  var endIndex = endBlock.nodes.indexOf(endChild);

  var startOff = startChild.key == startKey ? startOffset : startChild.getOffset(startKey) + startOffset;

  var endOff = endChild.key == endKey ? endOffset : endChild.getOffset(endKey) + endOffset;

  if (startBlock == endBlock) {
    if (endOff != endChild.length) {
      transform.splitNodeByKey(endChild.key, endOff, OPTS);
    }

    if (startOff != 0) {
      transform.splitNodeByKey(startChild.key, startOff, OPTS);
    }

    state = transform.state;
    document = state.document;
    startBlock = document.getClosestBlock(startKey);
    startChild = startBlock.getFurthestAncestor(startKey);

    var startInner = startOff == 0 ? startChild : document.getNextSibling(startChild.key);

    var startInnerIndex = startBlock.nodes.indexOf(startInner);

    var endInner = startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey);
    var inlines = startBlock.nodes.skipUntil(function (n) {
      return n == startInner;
    }).takeUntil(function (n) {
      return n == endInner;
    }).push(endInner);

    var node = inline.regenerateKey();

    transform.insertNodeByKey(startBlock.key, startInnerIndex, node, OPTS);

    inlines.forEach(function (child, i) {
      transform.moveNodeByKey(child.key, node.key, i, OPTS);
    });

    if (normalize) {
      transform.normalizeNodeByKey(startBlock.key, _core2.default);
    }
  } else {
    transform.splitNodeByKey(startChild.key, startOff, OPTS);
    transform.splitNodeByKey(endChild.key, endOff, OPTS);

    state = transform.state;
    document = state.document;
    startBlock = document.getDescendant(startBlock.key);
    endBlock = document.getDescendant(endBlock.key);

    var startInlines = startBlock.nodes.slice(startIndex + 1);
    var endInlines = endBlock.nodes.slice(0, endIndex + 1);
    var startNode = inline.regenerateKey();
    var endNode = inline.regenerateKey();

    transform.insertNodeByKey(startBlock.key, startIndex - 1, startNode, OPTS);
    transform.insertNodeByKey(endBlock.key, endIndex, endNode, OPTS);

    startInlines.forEach(function (child, i) {
      transform.moveNodeByKey(child.key, startNode.key, i, OPTS);
    });

    endInlines.forEach(function (child, i) {
      transform.moveNodeByKey(child.key, endNode.key, i, OPTS);
    });

    if (normalize) {
      transform.normalizeNodeByKey(startBlock.key, _core2.default).normalizeNodeByKey(endBlock.key, _core2.default);
    }

    blocks.slice(1, -1).forEach(function (block) {
      var node = inline.regenerateKey();
      transform.insertNodeByKey(block.key, 0, node, OPTS);

      block.nodes.forEach(function (child, i) {
        transform.moveNodeByKey(child.key, node.key, i, OPTS);
      });

      if (normalize) {
        transform.normalizeNodeByKey(block.key, _core2.default);
      }
    });
  }
};

/**
 * Wrap the text in a `range` in a prefix/suffix.
 *
 * @param {Transform} transform
 * @param {Selection} range
 * @param {String} prefix
 * @param {String} suffix (optional)
 * @param {Object} options
 *   @property {Boolean} normalize
 */

Transforms.wrapTextAtRange = function (transform, range, prefix) {
  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var _options$normalize18 = options.normalize,
      normalize = _options$normalize18 === undefined ? true : _options$normalize18;
  var startKey = range.startKey,
      endKey = range.endKey;

  var start = range.collapseToStart();
  var end = range.collapseToEnd();

  if (startKey == endKey) {
    end = end.move(prefix.length);
  }

  transform.insertTextAtRange(start, prefix, [], { normalize: normalize });
  transform.insertTextAtRange(end, suffix, [], { normalize: normalize });
};

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Transforms;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zL2F0LXJhbmdlLmpzIl0sIm5hbWVzIjpbIlRyYW5zZm9ybXMiLCJPUFRTIiwibm9ybWFsaXplIiwiYWRkTWFya0F0UmFuZ2UiLCJ0cmFuc2Zvcm0iLCJyYW5nZSIsIm1hcmsiLCJvcHRpb25zIiwiaXNDb2xsYXBzZWQiLCJzdGF0ZSIsImRvY3VtZW50Iiwic3RhcnRLZXkiLCJzdGFydE9mZnNldCIsImVuZEtleSIsImVuZE9mZnNldCIsInRleHRzIiwiZ2V0VGV4dHNBdFJhbmdlIiwiZm9yRWFjaCIsInRleHQiLCJrZXkiLCJpbmRleCIsImxlbmd0aCIsImFkZE1hcmtCeUtleSIsImRlbGV0ZUF0UmFuZ2UiLCJyZW1vdmVUZXh0QnlLZXkiLCJhbmNlc3RvciIsImdldENvbW1vbkFuY2VzdG9yIiwic3RhcnRDaGlsZCIsImdldEZ1cnRoZXN0QW5jZXN0b3IiLCJlbmRDaGlsZCIsInN0YXJ0T2ZmIiwia2luZCIsImdldE9mZnNldCIsImVuZE9mZiIsInNwbGl0Tm9kZUJ5S2V5Iiwic3RhcnRJbmRleCIsIm5vZGVzIiwiaW5kZXhPZiIsImVuZEluZGV4IiwibWlkZGxlcyIsInNsaWNlIiwic2l6ZSIsImNoaWxkIiwicmVtb3ZlTm9kZUJ5S2V5Iiwic3RhcnRCbG9jayIsImdldENsb3Nlc3RCbG9jayIsImVuZEJsb2NrIiwiZ2V0TmV4dFRleHQiLCJpIiwibmV3S2V5IiwibmV3SW5kZXgiLCJtb3ZlTm9kZUJ5S2V5IiwibG9uZWx5IiwiZ2V0RnVydGhlc3RPbmx5Q2hpbGRBbmNlc3RvciIsIm5vcm1hbGl6ZU5vZGVCeUtleSIsImRlbGV0ZUNoYXJCYWNrd2FyZEF0UmFuZ2UiLCJvZmZzZXQiLCJvIiwibiIsImdldENoYXJPZmZzZXRCYWNrd2FyZCIsImRlbGV0ZUJhY2t3YXJkQXRSYW5nZSIsImRlbGV0ZUxpbmVCYWNrd2FyZEF0UmFuZ2UiLCJkZWxldGVXb3JkQmFja3dhcmRBdFJhbmdlIiwiZ2V0V29yZE9mZnNldEJhY2t3YXJkIiwiZm9jdXNPZmZzZXQiLCJpc0V4cGFuZGVkIiwiYmxvY2siLCJpc1ZvaWQiLCJpc0VtcHR5IiwiaW5saW5lIiwiZ2V0Q2xvc2VzdElubGluZSIsImlzQXRTdGFydE9mIiwiZ2V0RGVzY2VuZGFudCIsInByZXYiLCJnZXRQcmV2aW91c1RleHQiLCJwcmV2QmxvY2siLCJwcmV2SW5saW5lIiwibWVyZ2UiLCJhbmNob3JLZXkiLCJhbmNob3JPZmZzZXQiLCJpc0JhY2t3YXJkIiwibm9kZSIsInRyYXZlcnNlZCIsIm5leHQiLCJoYXNWb2lkUGFyZW50IiwicGFyZW50IiwiZ2V0Q2xvc2VzdFZvaWQiLCJmb2N1c0tleSIsImRlbGV0ZUNoYXJGb3J3YXJkQXRSYW5nZSIsImdldENoYXJPZmZzZXRGb3J3YXJkIiwiZGVsZXRlRm9yd2FyZEF0UmFuZ2UiLCJkZWxldGVMaW5lRm9yd2FyZEF0UmFuZ2UiLCJkZWxldGVXb3JkRm9yd2FyZEF0UmFuZ2UiLCJnZXRXb3JkT2Zmc2V0Rm9yd2FyZCIsImlzQXRFbmRPZiIsIm5leHRCbG9jayIsIm5leHRJbmxpbmUiLCJpbnNlcnRCbG9ja0F0UmFuZ2UiLCJjb2xsYXBzZVRvU3RhcnQiLCJzdGFydFRleHQiLCJhc3NlcnREZXNjZW5kYW50IiwiZ2V0UGFyZW50IiwiaW5zZXJ0Tm9kZUJ5S2V5IiwiaW5zZXJ0RnJhZ21lbnRBdFJhbmdlIiwiZnJhZ21lbnQiLCJtYXBEZXNjZW5kYW50cyIsInJlZ2VuZXJhdGVLZXkiLCJpc0F0U3RhcnQiLCJibG9ja3MiLCJnZXRCbG9ja3MiLCJmaXJzdEJsb2NrIiwiZmlyc3QiLCJsYXN0QmxvY2siLCJsYXN0IiwibG9uZWx5UGFyZW50IiwiZ2V0RnVydGhlc3QiLCJwIiwibG9uZWx5Q2hpbGQiLCJyZW1vdmVEZXNjZW5kYW50IiwibmV4dENoaWxkIiwiZ2V0TmV4dFNpYmxpbmciLCJuZXh0Tm9kZXMiLCJza2lwVW50aWwiLCJsYXN0SW5kZXgiLCJpbmxpbmVDaGlsZCIsImlubGluZUluZGV4IiwiaW5zZXJ0SW5saW5lQXRSYW5nZSIsImluc2VydFRleHRBdFJhbmdlIiwibWFya3MiLCJ1bmRlZmluZWQiLCJpbnNlcnRUZXh0QnlLZXkiLCJyZW1vdmVNYXJrQXRSYW5nZSIsInJlbW92ZU1hcmtCeUtleSIsInNldEJsb2NrQXRSYW5nZSIsInByb3BlcnRpZXMiLCJnZXRCbG9ja3NBdFJhbmdlIiwic2V0Tm9kZUJ5S2V5Iiwic2V0SW5saW5lQXRSYW5nZSIsImlubGluZXMiLCJnZXRJbmxpbmVzQXRSYW5nZSIsInNwbGl0QmxvY2tBdFJhbmdlIiwiaGVpZ2h0IiwiaCIsInNwbGl0SW5saW5lQXRSYW5nZSIsIkluZmluaXR5IiwidG9nZ2xlTWFya0F0UmFuZ2UiLCJnZXRNYXJrc0F0UmFuZ2UiLCJleGlzdHMiLCJzb21lIiwibSIsImVxdWFscyIsInVud3JhcEJsb2NrQXRSYW5nZSIsIm5vZGVQcm9wZXJ0aWVzIiwid3JhcHBlcnMiLCJtYXAiLCJnZXRDbG9zZXN0IiwidHlwZSIsImRhdGEiLCJpc1N1cGVyc2V0IiwiZmlsdGVyIiwidG9PcmRlcmVkU2V0IiwidG9MaXN0IiwiY2hpbGRyZW4iLCJiIiwiaGFzRGVzY2VuZGFudCIsImZpcnN0TWF0Y2giLCJsYXN0TWF0Y2giLCJ0YWtlVW50aWwiLCJwdXNoIiwiZXh0cmEiLCJnZXROZXh0QmxvY2siLCJub3JtYWxpemVEb2N1bWVudCIsInVud3JhcElubGluZUF0UmFuZ2UiLCJ3cmFwQmxvY2tBdFJhbmdlIiwic2V0IiwiY2xlYXIiLCJmaXJzdGJsb2NrIiwibGFzdGJsb2NrIiwic2libGluZ3MiLCJwMSIsInAyIiwiaW5kZXhlcyIsInJlZHVjZSIsImluZCIsIndyYXBJbmxpbmVBdFJhbmdlIiwiaW5saW5lUGFyZW50Iiwid3JhcElubGluZUJ5S2V5Iiwic3RhcnRJbm5lciIsInN0YXJ0SW5uZXJJbmRleCIsImVuZElubmVyIiwic3RhcnRJbmxpbmVzIiwiZW5kSW5saW5lcyIsInN0YXJ0Tm9kZSIsImVuZE5vZGUiLCJ3cmFwVGV4dEF0UmFuZ2UiLCJwcmVmaXgiLCJzdWZmaXgiLCJz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QSxNQUNoRkEsU0FEZ0Ysd0NBQ3BFLElBRG9FO0FBQUEsTUFFaEZTLFFBRmdGLEdBRTNETixLQUYyRCxDQUVoRk0sUUFGZ0Y7QUFBQSxNQUV0RUUsTUFGc0UsR0FFM0RSLEtBRjJELENBRXRFUSxNQUZzRTs7QUFHeEYsTUFBTXdMLFFBQVFoTSxNQUFNNkYsZUFBTixFQUFkO0FBQ0EsTUFBSW9HLE1BQU1qTSxNQUFNa00sYUFBTixFQUFWOztBQUVBLE1BQUk1TCxZQUFZRSxNQUFoQixFQUF3QjtBQUN0QnlMLFVBQU1BLElBQUlFLElBQUosQ0FBU0wsT0FBTzlLLE1BQWhCLENBQU47QUFDRDs7QUFFRGpCLFlBQVUySCxpQkFBVixDQUE0QnNFLEtBQTVCLEVBQW1DRixNQUFuQyxFQUEyQyxFQUEzQyxFQUErQyxFQUFFak0sb0JBQUYsRUFBL0M7QUFDQUUsWUFBVTJILGlCQUFWLENBQTRCdUUsR0FBNUIsRUFBaUNGLE1BQWpDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQUVsTSxvQkFBRixFQUE3QztBQUNELENBWkQ7O0FBY0E7Ozs7OztrQkFNZUYsVSIsImZpbGUiOiJhdC1yYW5nZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG5cbmltcG9ydCBOb3JtYWxpemUgZnJvbSAnLi4vdXRpbHMvbm9ybWFsaXplJ1xuaW1wb3J0IFN0cmluZyBmcm9tICcuLi91dGlscy9zdHJpbmcnXG5pbXBvcnQgU0NIRU1BIGZyb20gJy4uL3NjaGVtYXMvY29yZSdcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnXG5cbi8qKlxuICogVHJhbnNmb3Jtcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IFRyYW5zZm9ybXMgPSB7fVxuXG4vKipcbiAqIEFuIG9wdGlvbnMgb2JqZWN0IHdpdGggbm9ybWFsaXplIHNldCB0byBgZmFsc2VgLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgT1BUUyA9IHtcbiAgbm9ybWFsaXplOiBmYWxzZVxufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBgbWFya2AgdG8gdGhlIGNoYXJhY3RlcnMgYXQgYHJhbmdlYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gcmFuZ2VcbiAqIEBwYXJhbSB7TWl4ZWR9IG1hcmtcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy5hZGRNYXJrQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBtYXJrLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHJhbmdlLmlzQ29sbGFwc2VkKSByZXR1cm5cblxuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHsgc3RhcnRLZXksIHN0YXJ0T2Zmc2V0LCBlbmRLZXksIGVuZE9mZnNldCB9ID0gcmFuZ2VcbiAgY29uc3QgdGV4dHMgPSBkb2N1bWVudC5nZXRUZXh0c0F0UmFuZ2UocmFuZ2UpXG5cbiAgdGV4dHMuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgIGNvbnN0IHsga2V5IH0gPSB0ZXh0XG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGxldCBsZW5ndGggPSB0ZXh0Lmxlbmd0aFxuXG4gICAgaWYgKGtleSA9PSBzdGFydEtleSkgaW5kZXggPSBzdGFydE9mZnNldFxuICAgIGlmIChrZXkgPT0gZW5kS2V5KSBsZW5ndGggPSBlbmRPZmZzZXRcbiAgICBpZiAoa2V5ID09IHN0YXJ0S2V5ICYmIGtleSA9PSBlbmRLZXkpIGxlbmd0aCA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0XG5cbiAgICB0cmFuc2Zvcm0uYWRkTWFya0J5S2V5KGtleSwgaW5kZXgsIGxlbmd0aCwgbWFyaywgeyBub3JtYWxpemUgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBEZWxldGUgZXZlcnl0aGluZyBpbiBhIGByYW5nZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTZWxlY3Rpb259IHJhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuZGVsZXRlQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHJhbmdlLmlzQ29sbGFwc2VkKSByZXR1cm5cblxuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQsIGVuZEtleSwgZW5kT2Zmc2V0IH0gPSByYW5nZVxuXG4gIC8vIElmIHRoZSBzdGFydCBhbmQgZW5kIGtleSBhcmUgdGhlIHNhbWUsIHdlIGNhbiBqdXN0IHJlbW92ZSB0ZXh0LlxuICBpZiAoc3RhcnRLZXkgPT0gZW5kS2V5KSB7XG4gICAgY29uc3QgaW5kZXggPSBzdGFydE9mZnNldFxuICAgIGNvbnN0IGxlbmd0aCA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0XG4gICAgdHJhbnNmb3JtLnJlbW92ZVRleHRCeUtleShzdGFydEtleSwgaW5kZXgsIGxlbmd0aCwgeyBub3JtYWxpemUgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFNwbGl0IGF0IHRoZSByYW5nZSBlZGdlcyB3aXRoaW4gYSBjb21tb24gYW5jZXN0b3IsIHdpdGhvdXQgbm9ybWFsaXppbmcuXG4gIGxldCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBhbmNlc3RvciA9IGRvY3VtZW50LmdldENvbW1vbkFuY2VzdG9yKHN0YXJ0S2V5LCBlbmRLZXkpXG4gIGxldCBzdGFydENoaWxkID0gYW5jZXN0b3IuZ2V0RnVydGhlc3RBbmNlc3RvcihzdGFydEtleSlcbiAgbGV0IGVuZENoaWxkID0gYW5jZXN0b3IuZ2V0RnVydGhlc3RBbmNlc3RvcihlbmRLZXkpXG4gIGNvbnN0IHN0YXJ0T2ZmID0gKHN0YXJ0Q2hpbGQua2luZCA9PSAndGV4dCcgPyAwIDogc3RhcnRDaGlsZC5nZXRPZmZzZXQoc3RhcnRLZXkpKSArIHN0YXJ0T2Zmc2V0XG4gIGNvbnN0IGVuZE9mZiA9IChlbmRDaGlsZC5raW5kID09ICd0ZXh0JyA/IDAgOiBlbmRDaGlsZC5nZXRPZmZzZXQoZW5kS2V5KSkgKyBlbmRPZmZzZXRcblxuICB0cmFuc2Zvcm0uc3BsaXROb2RlQnlLZXkoc3RhcnRDaGlsZC5rZXksIHN0YXJ0T2ZmLCBPUFRTKVxuICB0cmFuc2Zvcm0uc3BsaXROb2RlQnlLZXkoZW5kQ2hpbGQua2V5LCBlbmRPZmYsIE9QVFMpXG5cbiAgLy8gUmVmcmVzaCB2YXJpYWJsZXMuXG4gIHN0YXRlID0gdHJhbnNmb3JtLnN0YXRlXG4gIGRvY3VtZW50ID0gc3RhdGUuZG9jdW1lbnRcbiAgYW5jZXN0b3IgPSBkb2N1bWVudC5nZXRDb21tb25BbmNlc3RvcihzdGFydEtleSwgZW5kS2V5KVxuICBzdGFydENoaWxkID0gYW5jZXN0b3IuZ2V0RnVydGhlc3RBbmNlc3RvcihzdGFydEtleSlcbiAgZW5kQ2hpbGQgPSBhbmNlc3Rvci5nZXRGdXJ0aGVzdEFuY2VzdG9yKGVuZEtleSlcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGFuY2VzdG9yLm5vZGVzLmluZGV4T2Yoc3RhcnRDaGlsZClcbiAgY29uc3QgZW5kSW5kZXggPSBhbmNlc3Rvci5ub2Rlcy5pbmRleE9mKGVuZENoaWxkKVxuICBjb25zdCBtaWRkbGVzID0gYW5jZXN0b3Iubm9kZXMuc2xpY2Uoc3RhcnRJbmRleCArIDEsIGVuZEluZGV4ICsgMSlcblxuICAvLyBSZW1vdmUgYWxsIG9mIHRoZSBtaWRkbGUgbm9kZXMsIGJldHdlZW4gdGhlIHNwbGl0cy5cbiAgaWYgKG1pZGRsZXMuc2l6ZSkge1xuICAgIG1pZGRsZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIHRyYW5zZm9ybS5yZW1vdmVOb2RlQnlLZXkoY2hpbGQua2V5LCBPUFRTKVxuICAgIH0pXG4gIH1cblxuICAvLyBJZiB0aGUgc3RhcnQgYW5kIGVuZCBibG9jayBhcmUgZGlmZmVyZW50LCBtb3ZlIGFsbCBvZiB0aGUgbm9kZXMgZnJvbSB0aGVcbiAgLy8gZW5kIGJsb2NrIGludG8gdGhlIHN0YXJ0IGJsb2NrLlxuICBjb25zdCBzdGFydEJsb2NrID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdEJsb2NrKHN0YXJ0S2V5KVxuICBjb25zdCBlbmRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhkb2N1bWVudC5nZXROZXh0VGV4dChlbmRLZXkpLmtleSlcblxuICBpZiAoc3RhcnRCbG9jay5rZXkgIT09IGVuZEJsb2NrLmtleSkge1xuICAgIGVuZEJsb2NrLm5vZGVzLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCBuZXdLZXkgPSBzdGFydEJsb2NrLmtleVxuICAgICAgY29uc3QgbmV3SW5kZXggPSBzdGFydEJsb2NrLm5vZGVzLnNpemUgKyBpXG4gICAgICB0cmFuc2Zvcm0ubW92ZU5vZGVCeUtleShjaGlsZC5rZXksIG5ld0tleSwgbmV3SW5kZXgsIE9QVFMpXG4gICAgfSlcblxuICAgIC8vIFJlbW92ZSBwYXJlbnRzIG9mIGVuZEJsb2NrIGFzIGxvbmcgYXMgdGhleSBoYXZlIGEgc2luZ2xlIGNoaWxkXG4gICAgY29uc3QgbG9uZWx5ID0gZG9jdW1lbnQuZ2V0RnVydGhlc3RPbmx5Q2hpbGRBbmNlc3RvcihlbmRCbG9jay5rZXkpIHx8IGVuZEJsb2NrXG4gICAgdHJhbnNmb3JtLnJlbW92ZU5vZGVCeUtleShsb25lbHkua2V5LCBPUFRTKVxuICB9XG5cbiAgaWYgKG5vcm1hbGl6ZSkge1xuICAgIHRyYW5zZm9ybS5ub3JtYWxpemVOb2RlQnlLZXkoYW5jZXN0b3Iua2V5LCBTQ0hFTUEpXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYmFja3dhcmQgdW50aWwgdGhlIGNoYXJhY3RlciBib3VuZGFyeSBhdCBhIGByYW5nZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTZWxlY3Rpb259IHJhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuZGVsZXRlQ2hhckJhY2t3YXJkQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCB7IHN0YXJ0S2V5LCBzdGFydE9mZnNldCB9ID0gcmFuZ2VcbiAgY29uc3Qgc3RhcnRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhzdGFydEtleSlcbiAgY29uc3Qgb2Zmc2V0ID0gc3RhcnRCbG9jay5nZXRPZmZzZXQoc3RhcnRLZXkpXG4gIGNvbnN0IG8gPSBvZmZzZXQgKyBzdGFydE9mZnNldFxuICBjb25zdCB7IHRleHQgfSA9IHN0YXJ0QmxvY2tcbiAgY29uc3QgbiA9IFN0cmluZy5nZXRDaGFyT2Zmc2V0QmFja3dhcmQodGV4dCwgbylcbiAgdHJhbnNmb3JtLmRlbGV0ZUJhY2t3YXJkQXRSYW5nZShyYW5nZSwgbiwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBEZWxldGUgYmFja3dhcmQgdW50aWwgdGhlIGxpbmUgYm91bmRhcnkgYXQgYSBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZUxpbmVCYWNrd2FyZEF0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQgfSA9IHJhbmdlXG4gIGNvbnN0IHN0YXJ0QmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2soc3RhcnRLZXkpXG4gIGNvbnN0IG9mZnNldCA9IHN0YXJ0QmxvY2suZ2V0T2Zmc2V0KHN0YXJ0S2V5KVxuICBjb25zdCBvID0gb2Zmc2V0ICsgc3RhcnRPZmZzZXRcbiAgdHJhbnNmb3JtLmRlbGV0ZUJhY2t3YXJkQXRSYW5nZShyYW5nZSwgbywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBEZWxldGUgYmFja3dhcmQgdW50aWwgdGhlIHdvcmQgYm91bmRhcnkgYXQgYSBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZVdvcmRCYWNrd2FyZEF0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQgfSA9IHJhbmdlXG4gIGNvbnN0IHN0YXJ0QmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2soc3RhcnRLZXkpXG4gIGNvbnN0IG9mZnNldCA9IHN0YXJ0QmxvY2suZ2V0T2Zmc2V0KHN0YXJ0S2V5KVxuICBjb25zdCBvID0gb2Zmc2V0ICsgc3RhcnRPZmZzZXRcbiAgY29uc3QgeyB0ZXh0IH0gPSBzdGFydEJsb2NrXG4gIGNvbnN0IG4gPSBTdHJpbmcuZ2V0V29yZE9mZnNldEJhY2t3YXJkKHRleHQsIG8pXG4gIHRyYW5zZm9ybS5kZWxldGVCYWNrd2FyZEF0UmFuZ2UocmFuZ2UsIG4sIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRGVsZXRlIGJhY2t3YXJkIGBuYCBjaGFyYWN0ZXJzIGF0IGEgYHJhbmdlYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gcmFuZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy5kZWxldGVCYWNrd2FyZEF0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgbiA9IDEsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHsgc3RhcnRLZXksIGZvY3VzT2Zmc2V0IH0gPSByYW5nZVxuXG4gIC8vIElmIHRoZSByYW5nZSBpcyBleHBhbmRlZCwgcGVyZm9ybSBhIHJlZ3VsYXIgZGVsZXRlIGluc3RlYWQuXG4gIGlmIChyYW5nZS5pc0V4cGFuZGVkKSB7XG4gICAgdHJhbnNmb3JtLmRlbGV0ZUF0UmFuZ2UocmFuZ2UsIHsgbm9ybWFsaXplIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBibG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhzdGFydEtleSlcbiAgLy8gSWYgdGhlIGNsb3Nlc3QgYmxvY2sgaXMgdm9pZCwgZGVsZXRlIGl0LlxuICBpZiAoYmxvY2sgJiYgYmxvY2suaXNWb2lkKSB7XG4gICAgdHJhbnNmb3JtLnJlbW92ZU5vZGVCeUtleShibG9jay5rZXksIHsgbm9ybWFsaXplIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gSWYgdGhlIGNsb3Nlc3QgaXMgbm90IHZvaWQsIGJ1dCBlbXB0eSwgcmVtb3ZlIGl0XG4gIGlmIChibG9jayAmJiAhYmxvY2suaXNWb2lkICYmIGJsb2NrLmlzRW1wdHkgJiYgZG9jdW1lbnQubm9kZXMuc2l6ZSAhPT0gMSkge1xuICAgIHRyYW5zZm9ybS5yZW1vdmVOb2RlQnlLZXkoYmxvY2sua2V5LCB7IG5vcm1hbGl6ZSB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gSWYgdGhlIGNsb3Nlc3QgaW5saW5lIGlzIHZvaWQsIGRlbGV0ZSBpdC5cbiAgY29uc3QgaW5saW5lID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdElubGluZShzdGFydEtleSlcbiAgaWYgKGlubGluZSAmJiBpbmxpbmUuaXNWb2lkKSB7XG4gICAgdHJhbnNmb3JtLnJlbW92ZU5vZGVCeUtleShpbmxpbmUua2V5LCB7IG5vcm1hbGl6ZSB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gSWYgdGhlIHJhbmdlIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQsIGFib3J0LlxuICBpZiAocmFuZ2UuaXNBdFN0YXJ0T2YoZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBJZiB0aGUgcmFuZ2UgaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUsIHdlIG5lZWQgdG8gZmlndXJlIG91dCB3aGF0XG4gIC8vIGlzIGJlaGluZCBpdCB0byBrbm93IGhvdyB0byBkZWxldGUuLi5cbiAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmdldERlc2NlbmRhbnQoc3RhcnRLZXkpXG4gIGlmIChyYW5nZS5pc0F0U3RhcnRPZih0ZXh0KSkge1xuICAgIGNvbnN0IHByZXYgPSBkb2N1bWVudC5nZXRQcmV2aW91c1RleHQodGV4dC5rZXkpXG4gICAgY29uc3QgcHJldkJsb2NrID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdEJsb2NrKHByZXYua2V5KVxuICAgIGNvbnN0IHByZXZJbmxpbmUgPSBkb2N1bWVudC5nZXRDbG9zZXN0SW5saW5lKHByZXYua2V5KVxuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIGJsb2NrIGlzIHZvaWQsIHJlbW92ZSBpdC5cbiAgICBpZiAocHJldkJsb2NrICYmIHByZXZCbG9jay5pc1ZvaWQpIHtcbiAgICAgIHRyYW5zZm9ybS5yZW1vdmVOb2RlQnlLZXkocHJldkJsb2NrLmtleSwgeyBub3JtYWxpemUgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBwcmV2aW91cyBpbmxpbmUgaXMgdm9pZCwgcmVtb3ZlIGl0LlxuICAgIGlmIChwcmV2SW5saW5lICYmIHByZXZJbmxpbmUuaXNWb2lkKSB7XG4gICAgICB0cmFuc2Zvcm0ucmVtb3ZlTm9kZUJ5S2V5KHByZXZJbmxpbmUua2V5LCB7IG5vcm1hbGl6ZSB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgZGVsZXRpbmcgYnkgb25lIGNoYXJhY3RlciBhbmQgdGhlIHByZXZpb3VzIHRleHQgbm9kZSBpcyBub3RcbiAgICAvLyBpbnNpZGUgdGhlIGN1cnJlbnQgYmxvY2ssIHdlIG5lZWQgdG8gam9pbiB0aGUgdHdvIGJsb2NrcyB0b2dldGhlci5cbiAgICBpZiAobiA9PSAxICYmIHByZXZCbG9jayAhPSBibG9jaykge1xuICAgICAgcmFuZ2UgPSByYW5nZS5tZXJnZSh7XG4gICAgICAgIGFuY2hvcktleTogcHJldi5rZXksXG4gICAgICAgIGFuY2hvck9mZnNldDogcHJldi5sZW5ndGgsXG4gICAgICB9KVxuXG4gICAgICB0cmFuc2Zvcm0uZGVsZXRlQXRSYW5nZShyYW5nZSwgeyBub3JtYWxpemUgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBmb2N1cyBvZmZzZXQgaXMgZmFydGhlciB0aGFuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBkZWxldGUsXG4gIC8vIGp1c3QgcmVtb3ZlIHRoZSBjaGFyYWN0ZXJzIGJhY2t3YXJkcyBpbnNpZGUgdGhlIGN1cnJlbnQgbm9kZS5cbiAgaWYgKG4gPCBmb2N1c09mZnNldCkge1xuICAgIHJhbmdlID0gcmFuZ2UubWVyZ2Uoe1xuICAgICAgZm9jdXNPZmZzZXQ6IGZvY3VzT2Zmc2V0IC0gbixcbiAgICAgIGlzQmFja3dhcmQ6IHRydWUsXG4gICAgfSlcblxuICAgIHRyYW5zZm9ybS5kZWxldGVBdFJhbmdlKHJhbmdlLCB7IG5vcm1hbGl6ZSB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHNlZSBob3cgbWFueSBub2RlcyBiYWNrd2FyZHMgdG8gZ28uXG4gIGxldCBub2RlID0gdGV4dFxuICBsZXQgb2Zmc2V0ID0gMFxuICBsZXQgdHJhdmVyc2VkID0gZm9jdXNPZmZzZXRcblxuICB3aGlsZSAobiA+IHRyYXZlcnNlZCkge1xuICAgIG5vZGUgPSBkb2N1bWVudC5nZXRQcmV2aW91c1RleHQobm9kZS5rZXkpXG4gICAgY29uc3QgbmV4dCA9IHRyYXZlcnNlZCArIG5vZGUubGVuZ3RoXG4gICAgaWYgKG4gPD0gbmV4dCkge1xuICAgICAgb2Zmc2V0ID0gbmV4dCAtIG5cbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlZCA9IG5leHRcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgZm9jdXMgbm9kZSBpcyBpbnNpZGUgYSB2b2lkLCBnbyB1cCB1bnRpbCByaWdodCBhZnRlciBpdC5cbiAgaWYgKGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQobm9kZS5rZXkpKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdFZvaWQobm9kZS5rZXkpXG4gICAgbm9kZSA9IGRvY3VtZW50LmdldE5leHRUZXh0KHBhcmVudC5rZXkpXG4gICAgb2Zmc2V0ID0gMFxuICB9XG5cbiAgcmFuZ2UgPSByYW5nZS5tZXJnZSh7XG4gICAgZm9jdXNLZXk6IG5vZGUua2V5LFxuICAgIGZvY3VzT2Zmc2V0OiBvZmZzZXQsXG4gICAgaXNCYWNrd2FyZDogdHJ1ZVxuICB9KVxuXG4gIHRyYW5zZm9ybS5kZWxldGVBdFJhbmdlKHJhbmdlLCB7IG5vcm1hbGl6ZSB9KVxufVxuXG4vKipcbiAqIERlbGV0ZSBmb3J3YXJkIHVudGlsIHRoZSBjaGFyYWN0ZXIgYm91bmRhcnkgYXQgYSBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZUNoYXJGb3J3YXJkQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCB7IHN0YXJ0S2V5LCBzdGFydE9mZnNldCB9ID0gcmFuZ2VcbiAgY29uc3Qgc3RhcnRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhzdGFydEtleSlcbiAgY29uc3Qgb2Zmc2V0ID0gc3RhcnRCbG9jay5nZXRPZmZzZXQoc3RhcnRLZXkpXG4gIGNvbnN0IG8gPSBvZmZzZXQgKyBzdGFydE9mZnNldFxuICBjb25zdCB7IHRleHQgfSA9IHN0YXJ0QmxvY2tcbiAgY29uc3QgbiA9IFN0cmluZy5nZXRDaGFyT2Zmc2V0Rm9yd2FyZCh0ZXh0LCBvKVxuICB0cmFuc2Zvcm0uZGVsZXRlRm9yd2FyZEF0UmFuZ2UocmFuZ2UsIG4sIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRGVsZXRlIGZvcndhcmQgdW50aWwgdGhlIGxpbmUgYm91bmRhcnkgYXQgYSBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZUxpbmVGb3J3YXJkQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCB7IHN0YXJ0S2V5LCBzdGFydE9mZnNldCB9ID0gcmFuZ2VcbiAgY29uc3Qgc3RhcnRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhzdGFydEtleSlcbiAgY29uc3Qgb2Zmc2V0ID0gc3RhcnRCbG9jay5nZXRPZmZzZXQoc3RhcnRLZXkpXG4gIGNvbnN0IG8gPSBvZmZzZXQgKyBzdGFydE9mZnNldFxuICB0cmFuc2Zvcm0uZGVsZXRlRm9yd2FyZEF0UmFuZ2UocmFuZ2UsIG8sIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRGVsZXRlIGZvcndhcmQgdW50aWwgdGhlIHdvcmQgYm91bmRhcnkgYXQgYSBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZVdvcmRGb3J3YXJkQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCB7IHN0YXJ0S2V5LCBzdGFydE9mZnNldCB9ID0gcmFuZ2VcbiAgY29uc3Qgc3RhcnRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhzdGFydEtleSlcbiAgY29uc3Qgb2Zmc2V0ID0gc3RhcnRCbG9jay5nZXRPZmZzZXQoc3RhcnRLZXkpXG4gIGNvbnN0IG8gPSBvZmZzZXQgKyBzdGFydE9mZnNldFxuICBjb25zdCB7IHRleHQgfSA9IHN0YXJ0QmxvY2tcbiAgY29uc3QgbiA9IFN0cmluZy5nZXRXb3JkT2Zmc2V0Rm9yd2FyZCh0ZXh0LCBvKVxuICB0cmFuc2Zvcm0uZGVsZXRlRm9yd2FyZEF0UmFuZ2UocmFuZ2UsIG4sIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRGVsZXRlIGZvcndhcmQgYG5gIGNoYXJhY3RlcnMgYXQgYSBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IG4gKG9wdGlvbmFsKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmRlbGV0ZUZvcndhcmRBdFJhbmdlID0gKHRyYW5zZm9ybSwgcmFuZ2UsIG4gPSAxLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCB7IHN0YXJ0S2V5LCBmb2N1c09mZnNldCB9ID0gcmFuZ2VcblxuICAvLyBJZiB0aGUgcmFuZ2UgaXMgZXhwYW5kZWQsIHBlcmZvcm0gYSByZWd1bGFyIGRlbGV0ZSBpbnN0ZWFkLlxuICBpZiAocmFuZ2UuaXNFeHBhbmRlZCkge1xuICAgIHRyYW5zZm9ybS5kZWxldGVBdFJhbmdlKHJhbmdlLCB7IG5vcm1hbGl6ZSB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgYmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2soc3RhcnRLZXkpXG4gIC8vIElmIHRoZSBjbG9zZXN0IGJsb2NrIGlzIHZvaWQsIGRlbGV0ZSBpdC5cbiAgaWYgKGJsb2NrICYmIGJsb2NrLmlzVm9pZCkge1xuICAgIHRyYW5zZm9ybS5yZW1vdmVOb2RlQnlLZXkoYmxvY2sua2V5LCB7IG5vcm1hbGl6ZSB9KVxuICAgIHJldHVyblxuICB9XG4gIC8vIElmIHRoZSBjbG9zZXN0IGlzIG5vdCB2b2lkLCBidXQgZW1wdHksIHJlbW92ZSBpdFxuICBpZiAoYmxvY2sgJiYgIWJsb2NrLmlzVm9pZCAmJiBibG9jay5pc0VtcHR5ICYmIGRvY3VtZW50Lm5vZGVzLnNpemUgIT09IDEpIHtcbiAgICB0cmFuc2Zvcm0ucmVtb3ZlTm9kZUJ5S2V5KGJsb2NrLmtleSwgeyBub3JtYWxpemUgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElmIHRoZSBjbG9zZXN0IGlubGluZSBpcyB2b2lkLCBkZWxldGUgaXQuXG4gIGNvbnN0IGlubGluZSA9IGRvY3VtZW50LmdldENsb3Nlc3RJbmxpbmUoc3RhcnRLZXkpXG4gIGlmIChpbmxpbmUgJiYgaW5saW5lLmlzVm9pZCkge1xuICAgIHRyYW5zZm9ybS5yZW1vdmVOb2RlQnlLZXkoaW5saW5lLmtleSwgeyBub3JtYWxpemUgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElmIHRoZSByYW5nZSBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LCBhYm9ydC5cbiAgaWYgKHJhbmdlLmlzQXRFbmRPZihkb2N1bWVudCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElmIHRoZSByYW5nZSBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIHRleHQgbm9kZSwgd2UgbmVlZCB0byBmaWd1cmUgb3V0IHdoYXRcbiAgLy8gaXMgYmVoaW5kIGl0IHRvIGtub3cgaG93IHRvIGRlbGV0ZS4uLlxuICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0RGVzY2VuZGFudChzdGFydEtleSlcbiAgaWYgKHJhbmdlLmlzQXRFbmRPZih0ZXh0KSkge1xuICAgIGNvbnN0IG5leHQgPSBkb2N1bWVudC5nZXROZXh0VGV4dCh0ZXh0LmtleSlcbiAgICBjb25zdCBuZXh0QmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2sobmV4dC5rZXkpXG4gICAgY29uc3QgbmV4dElubGluZSA9IGRvY3VtZW50LmdldENsb3Nlc3RJbmxpbmUobmV4dC5rZXkpXG5cbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgYmxvY2sgaXMgdm9pZCwgcmVtb3ZlIGl0LlxuICAgIGlmIChuZXh0QmxvY2sgJiYgbmV4dEJsb2NrLmlzVm9pZCkge1xuICAgICAgdHJhbnNmb3JtLnJlbW92ZU5vZGVCeUtleShuZXh0QmxvY2sua2V5LCB7IG5vcm1hbGl6ZSB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIGlubGluZSBpcyB2b2lkLCByZW1vdmUgaXQuXG4gICAgaWYgKG5leHRJbmxpbmUgJiYgbmV4dElubGluZS5pc1ZvaWQpIHtcbiAgICAgIHRyYW5zZm9ybS5yZW1vdmVOb2RlQnlLZXkobmV4dElubGluZS5rZXksIHsgbm9ybWFsaXplIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBkZWxldGluZyBieSBvbmUgY2hhcmFjdGVyIGFuZCB0aGUgcHJldmlvdXMgdGV4dCBub2RlIGlzIG5vdFxuICAgIC8vIGluc2lkZSB0aGUgY3VycmVudCBibG9jaywgd2UgbmVlZCB0byBqb2luIHRoZSB0d28gYmxvY2tzIHRvZ2V0aGVyLlxuICAgIGlmIChuID09IDEgJiYgbmV4dEJsb2NrICE9IGJsb2NrKSB7XG4gICAgICByYW5nZSA9IHJhbmdlLm1lcmdlKHtcbiAgICAgICAgZm9jdXNLZXk6IG5leHQua2V5LFxuICAgICAgICBmb2N1c09mZnNldDogMFxuICAgICAgfSlcblxuICAgICAgdHJhbnNmb3JtLmRlbGV0ZUF0UmFuZ2UocmFuZ2UsIHsgbm9ybWFsaXplIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWxcbiAgLy8gdG8gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZSwganVzdCByZW1vdmUgdGhlIGNoYXJhY3RlcnMgZm9yd2FyZHNcbiAgLy8gaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUuXG4gIGlmIChuIDw9ICh0ZXh0Lmxlbmd0aCAtIGZvY3VzT2Zmc2V0KSkge1xuICAgIHJhbmdlID0gcmFuZ2UubWVyZ2Uoe1xuICAgICAgZm9jdXNPZmZzZXQ6IGZvY3VzT2Zmc2V0ICsgblxuICAgIH0pXG5cbiAgICB0cmFuc2Zvcm0uZGVsZXRlQXRSYW5nZShyYW5nZSwgeyBub3JtYWxpemUgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBzZWUgaG93IG1hbnkgbm9kZXMgZm9yd2FyZHMgdG8gZ28uXG4gIGxldCBub2RlID0gdGV4dFxuICBsZXQgb2Zmc2V0ID0gZm9jdXNPZmZzZXRcbiAgbGV0IHRyYXZlcnNlZCA9IHRleHQubGVuZ3RoIC0gZm9jdXNPZmZzZXRcblxuICB3aGlsZSAobiA+IHRyYXZlcnNlZCkge1xuICAgIG5vZGUgPSBkb2N1bWVudC5nZXROZXh0VGV4dChub2RlLmtleSlcbiAgICBjb25zdCBuZXh0ID0gdHJhdmVyc2VkICsgbm9kZS5sZW5ndGhcbiAgICBpZiAobiA8PSBuZXh0KSB7XG4gICAgICBvZmZzZXQgPSBuIC0gdHJhdmVyc2VkXG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmF2ZXJzZWQgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIGZvY3VzIG5vZGUgaXMgaW5zaWRlIGEgdm9pZCwgZ28gdXAgdW50aWwgcmlnaHQgYmVmb3JlIGl0LlxuICBpZiAoZG9jdW1lbnQuaGFzVm9pZFBhcmVudChub2RlLmtleSkpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRDbG9zZXN0Vm9pZChub2RlLmtleSlcbiAgICBub2RlID0gZG9jdW1lbnQuZ2V0UHJldmlvdXNUZXh0KHBhcmVudC5rZXkpXG4gICAgb2Zmc2V0ID0gbm9kZS5sZW5ndGhcbiAgfVxuXG4gIHJhbmdlID0gcmFuZ2UubWVyZ2Uoe1xuICAgIGZvY3VzS2V5OiBub2RlLmtleSxcbiAgICBmb2N1c09mZnNldDogb2Zmc2V0LFxuICB9KVxuXG4gIHRyYW5zZm9ybS5kZWxldGVBdFJhbmdlKHJhbmdlLCB7IG5vcm1hbGl6ZSB9KVxufVxuXG4vKipcbiAqIEluc2VydCBhIGBibG9ja2Agbm9kZSBhdCBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtCbG9ja3xTdHJpbmd8T2JqZWN0fSBibG9ja1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmluc2VydEJsb2NrQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBibG9jaywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGJsb2NrID0gTm9ybWFsaXplLmJsb2NrKGJsb2NrKVxuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcblxuICBpZiAocmFuZ2UuaXNFeHBhbmRlZCkge1xuICAgIHRyYW5zZm9ybS5kZWxldGVBdFJhbmdlKHJhbmdlKVxuICAgIHJhbmdlID0gcmFuZ2UuY29sbGFwc2VUb1N0YXJ0KClcbiAgfVxuXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCB7IHN0YXJ0S2V5LCBzdGFydE9mZnNldCB9ID0gcmFuZ2VcbiAgY29uc3Qgc3RhcnRUZXh0ID0gZG9jdW1lbnQuYXNzZXJ0RGVzY2VuZGFudChzdGFydEtleSlcbiAgY29uc3Qgc3RhcnRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhzdGFydEtleSlcbiAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50KHN0YXJ0QmxvY2sua2V5KVxuICBjb25zdCBpbmRleCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKHN0YXJ0QmxvY2spXG5cbiAgaWYgKHN0YXJ0QmxvY2suaXNWb2lkKSB7XG4gICAgdHJhbnNmb3JtLmluc2VydE5vZGVCeUtleShwYXJlbnQua2V5LCBpbmRleCArIDEsIGJsb2NrLCB7IG5vcm1hbGl6ZSB9KVxuICB9XG5cbiAgZWxzZSBpZiAoc3RhcnRCbG9jay5pc0VtcHR5KSB7XG4gICAgdHJhbnNmb3JtLnJlbW92ZU5vZGVCeUtleShzdGFydEJsb2NrLmtleSlcbiAgICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KHBhcmVudC5rZXksIGluZGV4LCBibG9jaywgeyBub3JtYWxpemUgfSlcbiAgfVxuXG4gIGVsc2UgaWYgKHJhbmdlLmlzQXRTdGFydE9mKHN0YXJ0QmxvY2spKSB7XG4gICAgdHJhbnNmb3JtLmluc2VydE5vZGVCeUtleShwYXJlbnQua2V5LCBpbmRleCwgYmxvY2ssIHsgbm9ybWFsaXplIH0pXG4gIH1cblxuICBlbHNlIGlmIChyYW5nZS5pc0F0RW5kT2Yoc3RhcnRCbG9jaykpIHtcbiAgICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KHBhcmVudC5rZXksIGluZGV4ICsgMSwgYmxvY2ssIHsgbm9ybWFsaXplIH0pXG4gIH1cblxuICBlbHNlIHtcbiAgICBjb25zdCBvZmZzZXQgPSBzdGFydEJsb2NrLmdldE9mZnNldChzdGFydFRleHQua2V5KSArIHN0YXJ0T2Zmc2V0XG4gICAgdHJhbnNmb3JtLnNwbGl0Tm9kZUJ5S2V5KHN0YXJ0QmxvY2sua2V5LCBvZmZzZXQsIHsgbm9ybWFsaXplIH0pXG4gICAgdHJhbnNmb3JtLmluc2VydE5vZGVCeUtleShwYXJlbnQua2V5LCBpbmRleCArIDEsIGJsb2NrLCB7IG5vcm1hbGl6ZSB9KVxuICB9XG5cbiAgaWYgKG5vcm1hbGl6ZSkge1xuICAgIHRyYW5zZm9ybS5ub3JtYWxpemVOb2RlQnlLZXkocGFyZW50LmtleSwgU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogSW5zZXJ0IGEgYGZyYWdtZW50YCBhdCBhIGByYW5nZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTZWxlY3Rpb259IHJhbmdlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBmcmFnbWVudFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50QXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBmcmFnbWVudCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuXG4gIC8vIElmIHRoZSByYW5nZSBpcyBleHBhbmRlZCwgZGVsZXRlIGl0IGZpcnN0LlxuICBpZiAocmFuZ2UuaXNFeHBhbmRlZCkge1xuICAgIHRyYW5zZm9ybS5kZWxldGVBdFJhbmdlKHJhbmdlLCBPUFRTKVxuICAgIHJhbmdlID0gcmFuZ2UuY29sbGFwc2VUb1N0YXJ0KClcbiAgfVxuXG4gIC8vIElmIHRoZSBmcmFnbWVudCBpcyBlbXB0eSwgdGhlcmUncyBub3RoaW5nIHRvIGRvIGFmdGVyIGRlbGV0aW5nLlxuICBpZiAoIWZyYWdtZW50Lm5vZGVzLnNpemUpIHJldHVyblxuXG4gIC8vIFJlZ2VuZXJhdGUgdGhlIGtleXMgZm9yIGFsbCBvZiB0aGUgZnJhZ21lbnRzIG5vZGVzLCBzbyB0aGF0IHRoZXkncmVcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gY29sbGlkZSB3aXRoIHRoZSBleGlzdGluZyBrZXlzIGluIHRoZSBkb2N1bWVudC4gT3RoZXJ3aXNlXG4gIC8vIHRoZXkgd2lsbCBiZSByZW5nZXJhdGVkIGF1dG9tYXRpY2FsbHkgYW5kIHdlIHdvbid0IGhhdmUgYW4gZWFzeSB3YXkgdG9cbiAgLy8gcmVmZXJlbmNlIHRoZW0uXG4gIGZyYWdtZW50ID0gZnJhZ21lbnQubWFwRGVzY2VuZGFudHMoY2hpbGQgPT4gY2hpbGQucmVnZW5lcmF0ZUtleSgpKVxuXG4gIC8vIENhbGN1bGF0ZSBhIGZldyB0aGluZ3MuLi5cbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQgfSA9IHJhbmdlXG4gIGxldCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBzdGFydFRleHQgPSBkb2N1bWVudC5nZXREZXNjZW5kYW50KHN0YXJ0S2V5KVxuICBsZXQgc3RhcnRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhzdGFydFRleHQua2V5KVxuICBsZXQgc3RhcnRDaGlsZCA9IHN0YXJ0QmxvY2suZ2V0RnVydGhlc3RBbmNlc3RvcihzdGFydFRleHQua2V5KVxuICBjb25zdCBpc0F0U3RhcnQgPSByYW5nZS5pc0F0U3RhcnRPZihzdGFydEJsb2NrKVxuICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQoc3RhcnRCbG9jay5rZXkpXG4gIGNvbnN0IGluZGV4ID0gcGFyZW50Lm5vZGVzLmluZGV4T2Yoc3RhcnRCbG9jaylcbiAgY29uc3Qgb2Zmc2V0ID0gc3RhcnRDaGlsZCA9PSBzdGFydFRleHRcbiAgICA/IHN0YXJ0T2Zmc2V0XG4gICAgOiBzdGFydENoaWxkLmdldE9mZnNldChzdGFydFRleHQua2V5KSArIHN0YXJ0T2Zmc2V0XG5cbiAgY29uc3QgYmxvY2tzID0gZnJhZ21lbnQuZ2V0QmxvY2tzKClcbiAgY29uc3QgZmlyc3RCbG9jayA9IGJsb2Nrcy5maXJzdCgpXG4gIGNvbnN0IGxhc3RCbG9jayA9IGJsb2Nrcy5sYXN0KClcblxuICAvLyBJZiB0aGUgZnJhZ21lbnQgb25seSBjb250YWlucyBhIHZvaWQgYmxvY2ssIHVzZSBgaW5zZXJ0QmxvY2tgIGluc3RlYWQuXG4gIGlmIChmaXJzdEJsb2NrID09IGxhc3RCbG9jayAmJiBmaXJzdEJsb2NrLmlzVm9pZCkge1xuICAgIHRyYW5zZm9ybS5pbnNlcnRCbG9ja0F0UmFuZ2UocmFuZ2UsIGZpcnN0QmxvY2ssIG9wdGlvbnMpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBJZiB0aGUgZmlyc3QgYW5kIGxhc3QgYmxvY2sgYXJlbid0IHRoZSBzYW1lLCB3ZSBuZWVkIHRvIGluc2VydCBhbGwgb2YgdGhlXG4gIC8vIG5vZGVzIGFmdGVyIHRoZSBmcmFnbWVudCdzIGZpcnN0IGJsb2NrIGF0IHRoZSBpbmRleC5cbiAgaWYgKGZpcnN0QmxvY2sgIT0gbGFzdEJsb2NrKSB7XG4gICAgY29uc3QgbG9uZWx5UGFyZW50ID0gZnJhZ21lbnQuZ2V0RnVydGhlc3QoZmlyc3RCbG9jay5rZXksIHAgPT4gcC5ub2Rlcy5zaXplID09IDEpXG4gICAgY29uc3QgbG9uZWx5Q2hpbGQgPSBsb25lbHlQYXJlbnQgfHwgZmlyc3RCbG9ja1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBwYXJlbnQubm9kZXMuaW5kZXhPZihzdGFydEJsb2NrKVxuICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVtb3ZlRGVzY2VuZGFudChsb25lbHlDaGlsZC5rZXkpXG5cbiAgICBmcmFnbWVudC5ub2Rlcy5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHN0YXJ0SW5kZXggKyBpICsgMVxuICAgICAgdHJhbnNmb3JtLmluc2VydE5vZGVCeUtleShwYXJlbnQua2V5LCBuZXdJbmRleCwgbm9kZSwgT1BUUylcbiAgICB9KVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzcGxpdCB0aGUgbm9kZS5cbiAgaWYgKHN0YXJ0T2Zmc2V0ICE9IDApIHtcbiAgICB0cmFuc2Zvcm0uc3BsaXROb2RlQnlLZXkoc3RhcnRDaGlsZC5rZXksIG9mZnNldCwgT1BUUylcbiAgfVxuXG4gIC8vIFVwZGF0ZSBvdXIgdmFyaWFibGVzIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgc3RhdGUgPSB0cmFuc2Zvcm0uc3RhdGVcbiAgZG9jdW1lbnQgPSBzdGF0ZS5kb2N1bWVudFxuICBzdGFydFRleHQgPSBkb2N1bWVudC5nZXREZXNjZW5kYW50KHN0YXJ0S2V5KVxuICBzdGFydEJsb2NrID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdEJsb2NrKHN0YXJ0S2V5KVxuICBzdGFydENoaWxkID0gc3RhcnRCbG9jay5nZXRGdXJ0aGVzdEFuY2VzdG9yKHN0YXJ0VGV4dC5rZXkpXG5cbiAgLy8gSWYgdGhlIGZpcnN0IGFuZCBsYXN0IGJsb2NrIGFyZW4ndCB0aGUgc2FtZSwgd2UgbmVlZCB0byBtb3ZlIGFueSBvZiB0aGVcbiAgLy8gc3RhcnRpbmcgYmxvY2sncyBjaGlsZHJlbiBhZnRlciB0aGUgc3BsaXQgaW50byB0aGUgbGFzdCBibG9jayBvZiB0aGVcbiAgLy8gZnJhZ21lbnQsIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5zZXJ0ZWQuXG4gIGlmIChmaXJzdEJsb2NrICE9IGxhc3RCbG9jaykge1xuICAgIGNvbnN0IG5leHRDaGlsZCA9IGlzQXRTdGFydCA/IHN0YXJ0Q2hpbGQgOiBzdGFydEJsb2NrLmdldE5leHRTaWJsaW5nKHN0YXJ0Q2hpbGQua2V5KVxuICAgIGNvbnN0IG5leHROb2RlcyA9IG5leHRDaGlsZCA/IHN0YXJ0QmxvY2subm9kZXMuc2tpcFVudGlsKG4gPT4gbi5rZXkgPT0gbmV4dENoaWxkLmtleSkgOiBMaXN0KClcbiAgICBjb25zdCBsYXN0SW5kZXggPSBsYXN0QmxvY2subm9kZXMuc2l6ZVxuXG4gICAgbmV4dE5vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gbGFzdEluZGV4ICsgaVxuICAgICAgdHJhbnNmb3JtLm1vdmVOb2RlQnlLZXkobm9kZS5rZXksIGxhc3RCbG9jay5rZXksIG5ld0luZGV4LCBPUFRTKVxuICAgIH0pXG4gIH1cblxuICAvLyBJZiB0aGUgc3RhcnRpbmcgYmxvY2sgaXMgZW1wdHksIHdlIHJlcGxhY2UgaXQgZW50aXJlbHkgd2l0aCB0aGUgZmlyc3QgYmxvY2tcbiAgLy8gb2YgdGhlIGZyYWdtZW50LCBzaW5jZSB0aGlzIGxlYWRzIHRvIGEgbW9yZSBleHBlY3RlZCBiZWhhdmlvciBmb3IgdGhlIHVzZXIuXG4gIGlmIChzdGFydEJsb2NrLmlzRW1wdHkpIHtcbiAgICB0cmFuc2Zvcm0ucmVtb3ZlTm9kZUJ5S2V5KHN0YXJ0QmxvY2sua2V5LCBPUFRTKVxuICAgIHRyYW5zZm9ybS5pbnNlcnROb2RlQnlLZXkocGFyZW50LmtleSwgaW5kZXgsIGZpcnN0QmxvY2ssIE9QVFMpXG4gIH1cblxuICAvLyBPdGhlcndpc2UsIHdlIG1haW50YWluIHRoZSBzdGFydGluZyBibG9jaywgYW5kIGluc2VydCBhbGwgb2YgdGhlIGZpcnN0XG4gIC8vIGJsb2NrJ3MgaW5saW5lIG5vZGVzIGludG8gaXQgYXQgdGhlIHNwbGl0IHBvaW50LlxuICBlbHNlIHtcbiAgICBjb25zdCBpbmxpbmVDaGlsZCA9IHN0YXJ0QmxvY2suZ2V0RnVydGhlc3RBbmNlc3RvcihzdGFydFRleHQua2V5KVxuICAgIGNvbnN0IGlubGluZUluZGV4ID0gc3RhcnRCbG9jay5ub2Rlcy5pbmRleE9mKGlubGluZUNoaWxkKVxuXG4gICAgZmlyc3RCbG9jay5ub2Rlcy5mb3JFYWNoKChpbmxpbmUsIGkpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBzdGFydE9mZnNldCA9PSAwID8gMCA6IDFcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5saW5lSW5kZXggKyBpICsgb1xuICAgICAgdHJhbnNmb3JtLmluc2VydE5vZGVCeUtleShzdGFydEJsb2NrLmtleSwgbmV3SW5kZXgsIGlubGluZSwgT1BUUylcbiAgICB9KVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGlmIHJlcXVlc3RlZC5cbiAgaWYgKG5vcm1hbGl6ZSkge1xuICAgIHRyYW5zZm9ybS5ub3JtYWxpemVOb2RlQnlLZXkocGFyZW50LmtleSwgU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogSW5zZXJ0IGFuIGBpbmxpbmVgIG5vZGUgYXQgYHJhbmdlYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gcmFuZ2VcbiAqIEBwYXJhbSB7SW5saW5lfFN0cmluZ3xPYmplY3R9IGlubGluZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLmluc2VydElubGluZUF0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgaW5saW5lLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGlubGluZSA9IE5vcm1hbGl6ZS5pbmxpbmUoaW5saW5lKVxuXG4gIGlmIChyYW5nZS5pc0V4cGFuZGVkKSB7XG4gICAgdHJhbnNmb3JtLmRlbGV0ZUF0UmFuZ2UocmFuZ2UsIE9QVFMpXG4gICAgcmFuZ2UgPSByYW5nZS5jb2xsYXBzZVRvU3RhcnQoKVxuICB9XG5cbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHsgc3RhcnRLZXksIHN0YXJ0T2Zmc2V0IH0gPSByYW5nZVxuICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQoc3RhcnRLZXkpXG4gIGNvbnN0IHN0YXJ0VGV4dCA9IGRvY3VtZW50LmFzc2VydERlc2NlbmRhbnQoc3RhcnRLZXkpXG4gIGNvbnN0IGluZGV4ID0gcGFyZW50Lm5vZGVzLmluZGV4T2Yoc3RhcnRUZXh0KVxuXG4gIGlmIChwYXJlbnQuaXNWb2lkKSByZXR1cm5cblxuICB0cmFuc2Zvcm0uc3BsaXROb2RlQnlLZXkoc3RhcnRLZXksIHN0YXJ0T2Zmc2V0LCBPUFRTKVxuICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KHBhcmVudC5rZXksIGluZGV4ICsgMSwgaW5saW5lLCBPUFRTKVxuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplTm9kZUJ5S2V5KHBhcmVudC5rZXksIFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIEluc2VydCBgdGV4dGAgYXQgYSBgcmFuZ2VgLCB3aXRoIG9wdGlvbmFsIGBtYXJrc2AuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTZWxlY3Rpb259IHJhbmdlXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtTZXQ8TWFyaz59IG1hcmtzIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy5pbnNlcnRUZXh0QXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCB0ZXh0LCBtYXJrcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCB7IG5vcm1hbGl6ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQgfSA9IHJhbmdlXG4gIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmdldFBhcmVudChzdGFydEtleSlcblxuICBpZiAocGFyZW50LmlzVm9pZCkgcmV0dXJuXG5cbiAgaWYgKHJhbmdlLmlzRXhwYW5kZWQpIHtcbiAgICB0cmFuc2Zvcm0uZGVsZXRlQXRSYW5nZShyYW5nZSwgT1BUUylcbiAgfVxuXG4gIC8vIFBFUkY6IFVubGVzcyBzcGVjaWZpZWQsIGRvbid0IG5vcm1hbGl6ZSBpZiBvbmx5IGluc2VydGluZyB0ZXh0LlxuICBpZiAobm9ybWFsaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBub3JtYWxpemUgPSByYW5nZS5pc0V4cGFuZGVkXG4gIH1cblxuICB0cmFuc2Zvcm0uaW5zZXJ0VGV4dEJ5S2V5KHN0YXJ0S2V5LCBzdGFydE9mZnNldCwgdGV4dCwgbWFya3MsIHsgbm9ybWFsaXplIH0pXG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV4aXN0aW5nIGBtYXJrYCB0byB0aGUgY2hhcmFjdGVycyBhdCBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtNYXJrfFN0cmluZ30gbWFyayAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMucmVtb3ZlTWFya0F0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgbWFyaywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChyYW5nZS5pc0NvbGxhcHNlZCkgcmV0dXJuXG5cbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCB0ZXh0cyA9IGRvY3VtZW50LmdldFRleHRzQXRSYW5nZShyYW5nZSlcbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQsIGVuZEtleSwgZW5kT2Zmc2V0IH0gPSByYW5nZVxuXG4gIHRleHRzLmZvckVhY2goKHRleHQpID0+IHtcbiAgICBjb25zdCB7IGtleSB9ID0gdGV4dFxuICAgIGxldCBpbmRleCA9IDBcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5sZW5ndGhcblxuICAgIGlmIChrZXkgPT0gc3RhcnRLZXkpIGluZGV4ID0gc3RhcnRPZmZzZXRcbiAgICBpZiAoa2V5ID09IGVuZEtleSkgbGVuZ3RoID0gZW5kT2Zmc2V0XG4gICAgaWYgKGtleSA9PSBzdGFydEtleSAmJiBrZXkgPT0gZW5kS2V5KSBsZW5ndGggPSBlbmRPZmZzZXQgLSBzdGFydE9mZnNldFxuXG4gICAgdHJhbnNmb3JtLnJlbW92ZU1hcmtCeUtleShrZXksIGluZGV4LCBsZW5ndGgsIG1hcmssIHsgbm9ybWFsaXplIH0pXG4gIH0pXG59XG5cbi8qKlxuICogU2V0IHRoZSBgcHJvcGVydGllc2Agb2YgYmxvY2sgbm9kZXMgaW4gYSBgcmFuZ2VgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuc2V0QmxvY2tBdFJhbmdlID0gKHRyYW5zZm9ybSwgcmFuZ2UsIHByb3BlcnRpZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LmdldEJsb2Nrc0F0UmFuZ2UocmFuZ2UpXG5cbiAgYmxvY2tzLmZvckVhY2goKGJsb2NrKSA9PiB7XG4gICAgdHJhbnNmb3JtLnNldE5vZGVCeUtleShibG9jay5rZXksIHByb3BlcnRpZXMsIHsgbm9ybWFsaXplIH0pXG4gIH0pXG59XG5cbi8qKlxuICogU2V0IHRoZSBgcHJvcGVydGllc2Agb2YgaW5saW5lIG5vZGVzIGluIGEgYHJhbmdlYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gcmFuZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLnNldElubGluZUF0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgcHJvcGVydGllcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgaW5saW5lcyA9IGRvY3VtZW50LmdldElubGluZXNBdFJhbmdlKHJhbmdlKVxuXG4gIGlubGluZXMuZm9yRWFjaCgoaW5saW5lKSA9PiB7XG4gICAgdHJhbnNmb3JtLnNldE5vZGVCeUtleShpbmxpbmUua2V5LCBwcm9wZXJ0aWVzLCB7IG5vcm1hbGl6ZSB9KVxuICB9KVxufVxuXG4vKipcbiAqIFNwbGl0IHRoZSBibG9jayBub2RlcyBhdCBhIGByYW5nZWAsIHRvIG9wdGlvbmFsIGBoZWlnaHRgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMuc3BsaXRCbG9ja0F0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgaGVpZ2h0ID0gMSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuXG4gIGlmIChyYW5nZS5pc0V4cGFuZGVkKSB7XG4gICAgdHJhbnNmb3JtLmRlbGV0ZUF0UmFuZ2UocmFuZ2UsIHsgbm9ybWFsaXplIH0pXG4gICAgcmFuZ2UgPSByYW5nZS5jb2xsYXBzZVRvU3RhcnQoKVxuICB9XG5cbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQgfSA9IHJhbmdlXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBsZXQgbm9kZSA9IGRvY3VtZW50LmFzc2VydERlc2NlbmRhbnQoc3RhcnRLZXkpXG4gIGxldCBwYXJlbnQgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2sobm9kZS5rZXkpXG4gIGxldCBvZmZzZXQgPSBzdGFydE9mZnNldFxuICBsZXQgaCA9IDBcblxuICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5raW5kID09ICdibG9jaycgJiYgaCA8IGhlaWdodCkge1xuICAgIG9mZnNldCArPSBwYXJlbnQuZ2V0T2Zmc2V0KG5vZGUua2V5KVxuICAgIG5vZGUgPSBwYXJlbnRcbiAgICBwYXJlbnQgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2socGFyZW50LmtleSlcbiAgICBoKytcbiAgfVxuXG4gIHRyYW5zZm9ybS5zcGxpdE5vZGVCeUtleShub2RlLmtleSwgb2Zmc2V0LCB7IG5vcm1hbGl6ZSB9KVxufVxuXG4vKipcbiAqIFNwbGl0IHRoZSBpbmxpbmUgbm9kZXMgYXQgYSBgcmFuZ2VgLCB0byBvcHRpb25hbCBgaGVpZ2h0YC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gcmFuZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLnNwbGl0SW5saW5lQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBoZWlnaHQgPSBJbmZpbml0eSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuXG4gIGlmIChyYW5nZS5pc0V4cGFuZGVkKSB7XG4gICAgdHJhbnNmb3JtLmRlbGV0ZUF0UmFuZ2UocmFuZ2UsIHsgbm9ybWFsaXplIH0pXG4gICAgcmFuZ2UgPSByYW5nZS5jb2xsYXBzZVRvU3RhcnQoKVxuICB9XG5cbiAgY29uc3QgeyBzdGFydEtleSwgc3RhcnRPZmZzZXQgfSA9IHJhbmdlXG4gIGNvbnN0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBsZXQgbm9kZSA9IGRvY3VtZW50LmFzc2VydERlc2NlbmRhbnQoc3RhcnRLZXkpXG4gIGxldCBwYXJlbnQgPSBkb2N1bWVudC5nZXRDbG9zZXN0SW5saW5lKG5vZGUua2V5KVxuICBsZXQgb2Zmc2V0ID0gc3RhcnRPZmZzZXRcbiAgbGV0IGggPSAwXG5cbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQua2luZCA9PSAnaW5saW5lJyAmJiBoIDwgaGVpZ2h0KSB7XG4gICAgb2Zmc2V0ICs9IHBhcmVudC5nZXRPZmZzZXQobm9kZS5rZXkpXG4gICAgbm9kZSA9IHBhcmVudFxuICAgIHBhcmVudCA9IGRvY3VtZW50LmdldENsb3Nlc3RJbmxpbmUocGFyZW50LmtleSlcbiAgICBoKytcbiAgfVxuXG4gIHRyYW5zZm9ybS5zcGxpdE5vZGVCeUtleShub2RlLmtleSwgb2Zmc2V0LCB7IG5vcm1hbGl6ZSB9KVxufVxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgYSBgbWFya2AgZnJvbSB0aGUgY2hhcmFjdGVycyBhdCBgcmFuZ2VgLCBkZXBlbmRpbmcgb24gd2hldGhlclxuICogaXQncyBhbHJlYWR5IHRoZXJlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtNaXhlZH0gbWFya1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLnRvZ2dsZU1hcmtBdFJhbmdlID0gKHRyYW5zZm9ybSwgcmFuZ2UsIG1hcmssIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHJldHVyblxuXG4gIG1hcmsgPSBOb3JtYWxpemUubWFyayhtYXJrKVxuXG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgbWFya3MgPSBkb2N1bWVudC5nZXRNYXJrc0F0UmFuZ2UocmFuZ2UpXG4gIGNvbnN0IGV4aXN0cyA9IG1hcmtzLnNvbWUobSA9PiBtLmVxdWFscyhtYXJrKSlcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgdHJhbnNmb3JtLnJlbW92ZU1hcmtBdFJhbmdlKHJhbmdlLCBtYXJrLCB7IG5vcm1hbGl6ZSB9KVxuICB9IGVsc2Uge1xuICAgIHRyYW5zZm9ybS5hZGRNYXJrQXRSYW5nZShyYW5nZSwgbWFyaywgeyBub3JtYWxpemUgfSlcbiAgfVxufVxuXG4vKipcbiAqIFVud3JhcCBhbGwgb2YgdGhlIGJsb2NrIG5vZGVzIGluIGEgYHJhbmdlYCBmcm9tIGEgYmxvY2sgd2l0aCBgcHJvcGVydGllc2AuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTZWxlY3Rpb259IHJhbmdlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbm9ybWFsaXplXG4gKi9cblxuVHJhbnNmb3Jtcy51bndyYXBCbG9ja0F0UmFuZ2UgPSAodHJhbnNmb3JtLCByYW5nZSwgcHJvcGVydGllcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHByb3BlcnRpZXMgPSBOb3JtYWxpemUubm9kZVByb3BlcnRpZXMocHJvcGVydGllcylcblxuICBjb25zdCB7IG5vcm1hbGl6ZSA9IHRydWUgfSA9IG9wdGlvbnNcbiAgbGV0IHsgc3RhdGUgfSA9IHRyYW5zZm9ybVxuICBsZXQgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgYmxvY2tzID0gZG9jdW1lbnQuZ2V0QmxvY2tzQXRSYW5nZShyYW5nZSlcbiAgY29uc3Qgd3JhcHBlcnMgPSBibG9ja3NcbiAgICAubWFwKChibG9jaykgPT4ge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldENsb3Nlc3QoYmxvY2sua2V5LCAocGFyZW50KSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnQua2luZCAhPSAnYmxvY2snKSByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKHByb3BlcnRpZXMudHlwZSAhPSBudWxsICYmIHBhcmVudC50eXBlICE9IHByb3BlcnRpZXMudHlwZSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzVm9pZCAhPSBudWxsICYmIHBhcmVudC5pc1ZvaWQgIT0gcHJvcGVydGllcy5pc1ZvaWQpIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAocHJvcGVydGllcy5kYXRhICE9IG51bGwgJiYgIXBhcmVudC5kYXRhLmlzU3VwZXJzZXQocHJvcGVydGllcy5kYXRhKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pXG4gICAgLmZpbHRlcihleGlzdHMgPT4gZXhpc3RzKVxuICAgIC50b09yZGVyZWRTZXQoKVxuICAgIC50b0xpc3QoKVxuXG4gIHdyYXBwZXJzLmZvckVhY2goKGJsb2NrKSA9PiB7XG4gICAgY29uc3QgZmlyc3QgPSBibG9jay5ub2Rlcy5maXJzdCgpXG4gICAgY29uc3QgbGFzdCA9IGJsb2NrLm5vZGVzLmxhc3QoKVxuICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmdldFBhcmVudChibG9jay5rZXkpXG4gICAgY29uc3QgaW5kZXggPSBwYXJlbnQubm9kZXMuaW5kZXhPZihibG9jaylcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gYmxvY2subm9kZXMuZmlsdGVyKChjaGlsZCkgPT4ge1xuICAgICAgcmV0dXJuIGJsb2Nrcy5zb21lKGIgPT4gY2hpbGQgPT0gYiB8fCBjaGlsZC5oYXNEZXNjZW5kYW50KGIua2V5KSlcbiAgICB9KVxuXG4gICAgY29uc3QgZmlyc3RNYXRjaCA9IGNoaWxkcmVuLmZpcnN0KClcbiAgICBjb25zdCBsYXN0TWF0Y2ggPSBjaGlsZHJlbi5sYXN0KClcblxuICAgIGlmIChmaXJzdCA9PSBmaXJzdE1hdGNoICYmIGxhc3QgPT0gbGFzdE1hdGNoKSB7XG4gICAgICBibG9jay5ub2Rlcy5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICB0cmFuc2Zvcm0ubW92ZU5vZGVCeUtleShjaGlsZC5rZXksIHBhcmVudC5rZXksIGluZGV4ICsgaSwgT1BUUylcbiAgICAgIH0pXG5cbiAgICAgIHRyYW5zZm9ybS5yZW1vdmVOb2RlQnlLZXkoYmxvY2sua2V5LCBPUFRTKVxuICAgIH1cblxuICAgIGVsc2UgaWYgKGxhc3QgPT0gbGFzdE1hdGNoKSB7XG4gICAgICBibG9jay5ub2Rlc1xuICAgICAgICAuc2tpcFVudGlsKG4gPT4gbiA9PSBmaXJzdE1hdGNoKVxuICAgICAgICAuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICB0cmFuc2Zvcm0ubW92ZU5vZGVCeUtleShjaGlsZC5rZXksIHBhcmVudC5rZXksIGluZGV4ICsgMSArIGksIE9QVFMpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZWxzZSBpZiAoZmlyc3QgPT0gZmlyc3RNYXRjaCkge1xuICAgICAgYmxvY2subm9kZXNcbiAgICAgICAgLnRha2VVbnRpbChuID0+IG4gPT0gbGFzdE1hdGNoKVxuICAgICAgICAucHVzaChsYXN0TWF0Y2gpXG4gICAgICAgIC5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICAgIHRyYW5zZm9ybS5tb3ZlTm9kZUJ5S2V5KGNoaWxkLmtleSwgcGFyZW50LmtleSwgaW5kZXggKyBpLCBPUFRTKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gYmxvY2suZ2V0T2Zmc2V0KGZpcnN0TWF0Y2gua2V5KVxuXG4gICAgICB0cmFuc2Zvcm0uc3BsaXROb2RlQnlLZXkoYmxvY2sua2V5LCBvZmZzZXQsIE9QVFMpXG4gICAgICBzdGF0ZSA9IHRyYW5zZm9ybS5zdGF0ZVxuICAgICAgZG9jdW1lbnQgPSBzdGF0ZS5kb2N1bWVudFxuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgY29uc3QgZXh0cmEgPSBjaGlsZFxuICAgICAgICAgIGNoaWxkID0gZG9jdW1lbnQuZ2V0TmV4dEJsb2NrKGNoaWxkLmtleSlcbiAgICAgICAgICB0cmFuc2Zvcm0ucmVtb3ZlTm9kZUJ5S2V5KGV4dHJhLmtleSwgT1BUUylcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybS5tb3ZlTm9kZUJ5S2V5KGNoaWxkLmtleSwgcGFyZW50LmtleSwgaW5kZXggKyAxICsgaSwgT1BUUylcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIC8vIFRPRE86IG9wdG1pemUgdG8gb25seSBub3JtYWxpemUgdGhlIHJpZ2h0IGJsb2NrXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICB0cmFuc2Zvcm0ubm9ybWFsaXplRG9jdW1lbnQoU0NIRU1BKVxuICB9XG59XG5cbi8qKlxuICogVW53cmFwIHRoZSBpbmxpbmUgbm9kZXMgaW4gYSBgcmFuZ2VgIGZyb20gYW4gaW5saW5lIHdpdGggYHByb3BlcnRpZXNgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMudW53cmFwSW5saW5lQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBwcm9wZXJ0aWVzLCBvcHRpb25zID0ge30pID0+IHtcbiAgcHJvcGVydGllcyA9IE5vcm1hbGl6ZS5ub2RlUHJvcGVydGllcyhwcm9wZXJ0aWVzKVxuXG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3QgdGV4dHMgPSBkb2N1bWVudC5nZXRUZXh0c0F0UmFuZ2UocmFuZ2UpXG4gIGNvbnN0IGlubGluZXMgPSB0ZXh0c1xuICAgIC5tYXAoKHRleHQpID0+IHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5nZXRDbG9zZXN0KHRleHQua2V5LCAocGFyZW50KSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnQua2luZCAhPSAnaW5saW5lJykgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnR5cGUgIT0gbnVsbCAmJiBwYXJlbnQudHlwZSAhPSBwcm9wZXJ0aWVzLnR5cGUpIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAocHJvcGVydGllcy5pc1ZvaWQgIT0gbnVsbCAmJiBwYXJlbnQuaXNWb2lkICE9IHByb3BlcnRpZXMuaXNWb2lkKSByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuZGF0YSAhPSBudWxsICYmICFwYXJlbnQuZGF0YS5pc1N1cGVyc2V0KHByb3BlcnRpZXMuZGF0YSkpIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9KVxuICAgIC5maWx0ZXIoZXhpc3RzID0+IGV4aXN0cylcbiAgICAudG9PcmRlcmVkU2V0KClcbiAgICAudG9MaXN0KClcblxuICBpbmxpbmVzLmZvckVhY2goKGlubGluZSkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IHRyYW5zZm9ybS5zdGF0ZS5kb2N1bWVudC5nZXRQYXJlbnQoaW5saW5lLmtleSlcbiAgICBjb25zdCBpbmRleCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKGlubGluZSlcblxuICAgIGlubGluZS5ub2Rlcy5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgdHJhbnNmb3JtLm1vdmVOb2RlQnlLZXkoY2hpbGQua2V5LCBwYXJlbnQua2V5LCBpbmRleCArIGksIE9QVFMpXG4gICAgfSlcbiAgfSlcblxuICAvLyBUT0RPOiBvcHRtaXplIHRvIG9ubHkgbm9ybWFsaXplIHRoZSByaWdodCBibG9ja1xuICBpZiAobm9ybWFsaXplKSB7XG4gICAgdHJhbnNmb3JtLm5vcm1hbGl6ZURvY3VtZW50KFNDSEVNQSlcbiAgfVxufVxuXG4vKipcbiAqIFdyYXAgYWxsIG9mIHRoZSBibG9ja3MgaW4gYSBgcmFuZ2VgIGluIGEgbmV3IGBibG9ja2AuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtTZWxlY3Rpb259IHJhbmdlXG4gKiBAcGFyYW0ge0Jsb2NrfE9iamVjdHxTdHJpbmd9IGJsb2NrXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMud3JhcEJsb2NrQXRSYW5nZSA9ICh0cmFuc2Zvcm0sIHJhbmdlLCBibG9jaywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGJsb2NrID0gTm9ybWFsaXplLmJsb2NrKGJsb2NrKVxuICBibG9jayA9IGJsb2NrLnNldCgnbm9kZXMnLCBibG9jay5ub2Rlcy5jbGVhcigpKVxuXG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcblxuICBjb25zdCBibG9ja3MgPSBkb2N1bWVudC5nZXRCbG9ja3NBdFJhbmdlKHJhbmdlKVxuICBjb25zdCBmaXJzdGJsb2NrID0gYmxvY2tzLmZpcnN0KClcbiAgY29uc3QgbGFzdGJsb2NrID0gYmxvY2tzLmxhc3QoKVxuICBsZXQgcGFyZW50LCBzaWJsaW5ncywgaW5kZXhcblxuICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBibG9jayBpbiB0aGUgc2VsZWN0aW9uIHRoZW4gd2Uga25vdyB0aGUgcGFyZW50IGFuZFxuICAvLyBzaWJsaW5ncy5cbiAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDEpIHtcbiAgICBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnQoZmlyc3RibG9jay5rZXkpXG4gICAgc2libGluZ3MgPSBibG9ja3NcbiAgfVxuXG4gIC8vIERldGVybWluZSBjbG9zZXN0IHNoYXJlZCBwYXJlbnQgdG8gYWxsIGJsb2NrcyBpbiBzZWxlY3Rpb24uXG4gIGVsc2Uge1xuICAgIHBhcmVudCA9IGRvY3VtZW50LmdldENsb3Nlc3QoZmlyc3RibG9jay5rZXksIChwMSkgPT4ge1xuICAgICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0Q2xvc2VzdChsYXN0YmxvY2sua2V5LCBwMiA9PiBwMSA9PSBwMilcbiAgICB9KVxuICB9XG5cbiAgLy8gSWYgbm8gc2hhcmVkIHBhcmVudCBjb3VsZCBiZSBmb3VuZCB0aGVuIHRoZSBwYXJlbnQgaXMgdGhlIGRvY3VtZW50LlxuICBpZiAocGFyZW50ID09IG51bGwpIHBhcmVudCA9IGRvY3VtZW50XG5cbiAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBkaXJlY3QgY2hpbGRyZW4gc2libGluZ3Mgb2YgcGFyZW50IHRoYXQgZmFsbCBpbiB0aGVcbiAgLy8gc2VsZWN0aW9uLlxuICBpZiAoc2libGluZ3MgPT0gbnVsbCkge1xuICAgIGNvbnN0IGluZGV4ZXMgPSBwYXJlbnQubm9kZXMucmVkdWNlKChpbmQsIG5vZGUsIGkpID0+IHtcbiAgICAgIGlmIChub2RlID09IGZpcnN0YmxvY2sgfHwgbm9kZS5oYXNEZXNjZW5kYW50KGZpcnN0YmxvY2sua2V5KSkgaW5kWzBdID0gaVxuICAgICAgaWYgKG5vZGUgPT0gbGFzdGJsb2NrIHx8IG5vZGUuaGFzRGVzY2VuZGFudChsYXN0YmxvY2sua2V5KSkgaW5kWzFdID0gaVxuICAgICAgcmV0dXJuIGluZFxuICAgIH0sIFtdKVxuXG4gICAgaW5kZXggPSBpbmRleGVzWzBdXG4gICAgc2libGluZ3MgPSBwYXJlbnQubm9kZXMuc2xpY2UoaW5kZXhlc1swXSwgaW5kZXhlc1sxXSArIDEpXG4gIH1cblxuICAvLyBHZXQgdGhlIGluZGV4IHRvIHBsYWNlIHRoZSBuZXcgd3JhcHBlZCBub2RlIGF0LlxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gcGFyZW50Lm5vZGVzLmluZGV4T2Yoc2libGluZ3MuZmlyc3QoKSlcbiAgfVxuXG4gIC8vIEluamVjdCB0aGUgbmV3IGJsb2NrIG5vZGUgaW50byB0aGUgcGFyZW50LlxuICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KHBhcmVudC5rZXksIGluZGV4LCBibG9jaywgT1BUUylcblxuICAvLyBNb3ZlIHRoZSBzaWJsaW5nIG5vZGVzIGludG8gdGhlIG5ldyBibG9jayBub2RlLlxuICBzaWJsaW5ncy5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgdHJhbnNmb3JtLm1vdmVOb2RlQnlLZXkobm9kZS5rZXksIGJsb2NrLmtleSwgaSwgT1BUUylcbiAgfSlcblxuICBpZiAobm9ybWFsaXplKSB7XG4gICAgdHJhbnNmb3JtLm5vcm1hbGl6ZU5vZGVCeUtleShwYXJlbnQua2V5LCBTQ0hFTUEpXG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwIHRoZSB0ZXh0IGFuZCBpbmxpbmVzIGluIGEgYHJhbmdlYCBpbiBhIG5ldyBgaW5saW5lYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gcmFuZ2VcbiAqIEBwYXJhbSB7SW5saW5lfE9iamVjdHxTdHJpbmd9IGlubGluZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgQHByb3BlcnR5IHtCb29sZWFufSBub3JtYWxpemVcbiAqL1xuXG5UcmFuc2Zvcm1zLndyYXBJbmxpbmVBdFJhbmdlID0gKHRyYW5zZm9ybSwgcmFuZ2UsIGlubGluZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGNvbnN0IHsgbm9ybWFsaXplID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHN0YXJ0S2V5LCBzdGFydE9mZnNldCwgZW5kS2V5LCBlbmRPZmZzZXQgfSA9IHJhbmdlXG5cbiAgaWYgKHJhbmdlLmlzQ29sbGFwc2VkKSB7XG4gICAgLy8gV3JhcHBpbmcgYW4gaW5saW5lIHZvaWRcbiAgICBjb25zdCBpbmxpbmVQYXJlbnQgPSBkb2N1bWVudC5nZXRDbG9zZXN0SW5saW5lKHN0YXJ0S2V5KVxuICAgIGlmICghaW5saW5lUGFyZW50LmlzVm9pZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zZm9ybS53cmFwSW5saW5lQnlLZXkoaW5saW5lUGFyZW50LmtleSwgaW5saW5lLCBvcHRpb25zKVxuICB9XG5cbiAgaW5saW5lID0gTm9ybWFsaXplLmlubGluZShpbmxpbmUpXG4gIGlubGluZSA9IGlubGluZS5zZXQoJ25vZGVzJywgaW5saW5lLm5vZGVzLmNsZWFyKCkpXG5cbiAgY29uc3QgYmxvY2tzID0gZG9jdW1lbnQuZ2V0QmxvY2tzQXRSYW5nZShyYW5nZSlcbiAgbGV0IHN0YXJ0QmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2soc3RhcnRLZXkpXG4gIGxldCBlbmRCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhlbmRLZXkpXG4gIGxldCBzdGFydENoaWxkID0gc3RhcnRCbG9jay5nZXRGdXJ0aGVzdEFuY2VzdG9yKHN0YXJ0S2V5KVxuICBjb25zdCBlbmRDaGlsZCA9IGVuZEJsb2NrLmdldEZ1cnRoZXN0QW5jZXN0b3IoZW5kS2V5KVxuICBjb25zdCBzdGFydEluZGV4ID0gc3RhcnRCbG9jay5ub2Rlcy5pbmRleE9mKHN0YXJ0Q2hpbGQpXG4gIGNvbnN0IGVuZEluZGV4ID0gZW5kQmxvY2subm9kZXMuaW5kZXhPZihlbmRDaGlsZClcblxuICBjb25zdCBzdGFydE9mZiA9IHN0YXJ0Q2hpbGQua2V5ID09IHN0YXJ0S2V5XG4gICAgPyBzdGFydE9mZnNldFxuICAgIDogc3RhcnRDaGlsZC5nZXRPZmZzZXQoc3RhcnRLZXkpICsgc3RhcnRPZmZzZXRcblxuICBjb25zdCBlbmRPZmYgPSBlbmRDaGlsZC5rZXkgPT0gZW5kS2V5XG4gICAgPyBlbmRPZmZzZXRcbiAgICA6IGVuZENoaWxkLmdldE9mZnNldChlbmRLZXkpICsgZW5kT2Zmc2V0XG5cbiAgaWYgKHN0YXJ0QmxvY2sgPT0gZW5kQmxvY2spIHtcbiAgICBpZiAoZW5kT2ZmICE9IGVuZENoaWxkLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtLnNwbGl0Tm9kZUJ5S2V5KGVuZENoaWxkLmtleSwgZW5kT2ZmLCBPUFRTKVxuICAgIH1cblxuICAgIGlmIChzdGFydE9mZiAhPSAwKSB7XG4gICAgICB0cmFuc2Zvcm0uc3BsaXROb2RlQnlLZXkoc3RhcnRDaGlsZC5rZXksIHN0YXJ0T2ZmLCBPUFRTKVxuICAgIH1cblxuICAgIHN0YXRlID0gdHJhbnNmb3JtLnN0YXRlXG4gICAgZG9jdW1lbnQgPSBzdGF0ZS5kb2N1bWVudFxuICAgIHN0YXJ0QmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2soc3RhcnRLZXkpXG4gICAgc3RhcnRDaGlsZCA9IHN0YXJ0QmxvY2suZ2V0RnVydGhlc3RBbmNlc3RvcihzdGFydEtleSlcblxuICAgIGNvbnN0IHN0YXJ0SW5uZXIgPSBzdGFydE9mZiA9PSAwXG4gICAgICA/IHN0YXJ0Q2hpbGRcbiAgICAgIDogZG9jdW1lbnQuZ2V0TmV4dFNpYmxpbmcoc3RhcnRDaGlsZC5rZXkpXG5cbiAgICBjb25zdCBzdGFydElubmVySW5kZXggPSBzdGFydEJsb2NrLm5vZGVzLmluZGV4T2Yoc3RhcnRJbm5lcilcblxuICAgIGNvbnN0IGVuZElubmVyID0gc3RhcnRLZXkgPT0gZW5kS2V5ID8gc3RhcnRJbm5lciA6IHN0YXJ0QmxvY2suZ2V0RnVydGhlc3RBbmNlc3RvcihlbmRLZXkpXG4gICAgY29uc3QgaW5saW5lcyA9IHN0YXJ0QmxvY2subm9kZXNcbiAgICAgIC5za2lwVW50aWwobiA9PiBuID09IHN0YXJ0SW5uZXIpXG4gICAgICAudGFrZVVudGlsKG4gPT4gbiA9PSBlbmRJbm5lcilcbiAgICAgIC5wdXNoKGVuZElubmVyKVxuXG4gICAgY29uc3Qgbm9kZSA9IGlubGluZS5yZWdlbmVyYXRlS2V5KClcblxuICAgIHRyYW5zZm9ybS5pbnNlcnROb2RlQnlLZXkoc3RhcnRCbG9jay5rZXksIHN0YXJ0SW5uZXJJbmRleCwgbm9kZSwgT1BUUylcblxuICAgIGlubGluZXMuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgIHRyYW5zZm9ybS5tb3ZlTm9kZUJ5S2V5KGNoaWxkLmtleSwgbm9kZS5rZXksIGksIE9QVFMpXG4gICAgfSlcblxuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRyYW5zZm9ybS5ub3JtYWxpemVOb2RlQnlLZXkoc3RhcnRCbG9jay5rZXksIFNDSEVNQSlcbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB0cmFuc2Zvcm0uc3BsaXROb2RlQnlLZXkoc3RhcnRDaGlsZC5rZXksIHN0YXJ0T2ZmLCBPUFRTKVxuICAgIHRyYW5zZm9ybS5zcGxpdE5vZGVCeUtleShlbmRDaGlsZC5rZXksIGVuZE9mZiwgT1BUUylcblxuICAgIHN0YXRlID0gdHJhbnNmb3JtLnN0YXRlXG4gICAgZG9jdW1lbnQgPSBzdGF0ZS5kb2N1bWVudFxuICAgIHN0YXJ0QmxvY2sgPSBkb2N1bWVudC5nZXREZXNjZW5kYW50KHN0YXJ0QmxvY2sua2V5KVxuICAgIGVuZEJsb2NrID0gZG9jdW1lbnQuZ2V0RGVzY2VuZGFudChlbmRCbG9jay5rZXkpXG5cbiAgICBjb25zdCBzdGFydElubGluZXMgPSBzdGFydEJsb2NrLm5vZGVzLnNsaWNlKHN0YXJ0SW5kZXggKyAxKVxuICAgIGNvbnN0IGVuZElubGluZXMgPSBlbmRCbG9jay5ub2Rlcy5zbGljZSgwLCBlbmRJbmRleCArIDEpXG4gICAgY29uc3Qgc3RhcnROb2RlID0gaW5saW5lLnJlZ2VuZXJhdGVLZXkoKVxuICAgIGNvbnN0IGVuZE5vZGUgPSBpbmxpbmUucmVnZW5lcmF0ZUtleSgpXG5cbiAgICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KHN0YXJ0QmxvY2sua2V5LCBzdGFydEluZGV4IC0gMSwgc3RhcnROb2RlLCBPUFRTKVxuICAgIHRyYW5zZm9ybS5pbnNlcnROb2RlQnlLZXkoZW5kQmxvY2sua2V5LCBlbmRJbmRleCwgZW5kTm9kZSwgT1BUUylcblxuICAgIHN0YXJ0SW5saW5lcy5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgdHJhbnNmb3JtLm1vdmVOb2RlQnlLZXkoY2hpbGQua2V5LCBzdGFydE5vZGUua2V5LCBpLCBPUFRTKVxuICAgIH0pXG5cbiAgICBlbmRJbmxpbmVzLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICB0cmFuc2Zvcm0ubW92ZU5vZGVCeUtleShjaGlsZC5rZXksIGVuZE5vZGUua2V5LCBpLCBPUFRTKVxuICAgIH0pXG5cbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0cmFuc2Zvcm1cbiAgICAgICAgLm5vcm1hbGl6ZU5vZGVCeUtleShzdGFydEJsb2NrLmtleSwgU0NIRU1BKVxuICAgICAgICAubm9ybWFsaXplTm9kZUJ5S2V5KGVuZEJsb2NrLmtleSwgU0NIRU1BKVxuICAgIH1cblxuICAgIGJsb2Nrcy5zbGljZSgxLCAtMSkuZm9yRWFjaCgoYmxvY2spID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBpbmxpbmUucmVnZW5lcmF0ZUtleSgpXG4gICAgICB0cmFuc2Zvcm0uaW5zZXJ0Tm9kZUJ5S2V5KGJsb2NrLmtleSwgMCwgbm9kZSwgT1BUUylcblxuICAgICAgYmxvY2subm9kZXMuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgdHJhbnNmb3JtLm1vdmVOb2RlQnlLZXkoY2hpbGQua2V5LCBub2RlLmtleSwgaSwgT1BUUylcbiAgICAgIH0pXG5cbiAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgdHJhbnNmb3JtLm5vcm1hbGl6ZU5vZGVCeUtleShibG9jay5rZXksIFNDSEVNQSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogV3JhcCB0aGUgdGV4dCBpbiBhIGByYW5nZWAgaW4gYSBwcmVmaXgvc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSByYW5nZVxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHBhcmFtIHtTdHJpbmd9IHN1ZmZpeCAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0Jvb2xlYW59IG5vcm1hbGl6ZVxuICovXG5cblRyYW5zZm9ybXMud3JhcFRleHRBdFJhbmdlID0gKHRyYW5zZm9ybSwgcmFuZ2UsIHByZWZpeCwgc3VmZml4ID0gcHJlZml4LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBub3JtYWxpemUgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IHsgc3RhcnRLZXksIGVuZEtleSB9ID0gcmFuZ2VcbiAgY29uc3Qgc3RhcnQgPSByYW5nZS5jb2xsYXBzZVRvU3RhcnQoKVxuICBsZXQgZW5kID0gcmFuZ2UuY29sbGFwc2VUb0VuZCgpXG5cbiAgaWYgKHN0YXJ0S2V5ID09IGVuZEtleSkge1xuICAgIGVuZCA9IGVuZC5tb3ZlKHByZWZpeC5sZW5ndGgpXG4gIH1cblxuICB0cmFuc2Zvcm0uaW5zZXJ0VGV4dEF0UmFuZ2Uoc3RhcnQsIHByZWZpeCwgW10sIHsgbm9ybWFsaXplIH0pXG4gIHRyYW5zZm9ybS5pbnNlcnRUZXh0QXRSYW5nZShlbmQsIHN1ZmZpeCwgW10sIHsgbm9ybWFsaXplIH0pXG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3Jtc1xuIl19