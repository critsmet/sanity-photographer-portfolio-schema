'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Transforms.
 *
 * @type {Object}
 */

var Transforms = {};

/**
 * Redo to the next state in the history.
 *
 * @param {Transform} transform
 */

Transforms.redo = function (transform) {
  var state = transform.state;
  var _state = state,
      history = _state.history;
  var _history = history,
      undos = _history.undos,
      redos = _history.redos;

  // If there's no next snapshot, abort.

  var next = redos.peek();
  if (!next) return;

  // Shift the next state into the undo stack.
  redos = redos.pop();
  undos = undos.push(next);

  // Replay the next operations.
  next.forEach(function (op) {
    transform.applyOperation(op);
  });

  // Update the history.
  state = transform.state;
  history = history.set('undos', undos).set('redos', redos);
  state = state.set('history', history);

  // Update the transform.
  transform.state = state;
};

/**
 * Save the operations into the history.
 *
 * @param {Transform} transform
 * @param {Object} options
 */

Transforms.save = function (transform) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$merge = options.merge,
      merge = _options$merge === undefined ? false : _options$merge;
  var state = transform.state,
      operations = transform.operations;
  var _state2 = state,
      history = _state2.history;
  var _history2 = history,
      undos = _history2.undos,
      redos = _history2.redos;

  var previous = undos.peek();

  // If there are no operations, abort.
  if (!operations.length) return;

  // Create a new save point or merge the operations into the previous one.
  if (merge && previous) {
    undos = undos.pop();
    previous = previous.concat(operations);
    undos = undos.push(previous);
  } else {
    undos = undos.push(operations);
  }

  // Clear the redo stack and constrain the undos stack.
  if (undos.size > 100) undos = undos.take(100);
  redos = redos.clear();

  // Update the state.
  history = history.set('undos', undos).set('redos', redos);
  state = state.set('history', history);

  // Update the transform.
  transform.state = state;
};

/**
 * Undo the previous operations in the history.
 *
 * @param {Transform} transform
 */

Transforms.undo = function (transform) {
  var state = transform.state;
  var _state3 = state,
      history = _state3.history;
  var _history3 = history,
      undos = _history3.undos,
      redos = _history3.redos;

  // If there's no previous snapshot, abort.

  var previous = undos.peek();
  if (!previous) return;

  // Shift the previous operations into the redo stack.
  undos = undos.pop();
  redos = redos.push(previous);

  // Replay the inverse of the previous operations.
  previous.slice().reverse().forEach(function (op) {
    op.inverse.forEach(function (inv) {
      transform.applyOperation(inv);
    });
  });

  // Update the history.
  state = transform.state;
  history = history.set('undos', undos).set('redos', redos);
  state = state.set('history', history);

  // Update the transform.
  transform.state = state;
};

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Transforms;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zL29uLWhpc3RvcnkuanMiXSwibmFtZXMiOlsiVHJhbnNmb3JtcyIsInJlZG8iLCJ0cmFuc2Zvcm0iLCJzdGF0ZSIsImhpc3RvcnkiLCJ1bmRvcyIsInJlZG9zIiwibmV4dCIsInBlZWsiLCJwb3AiLCJwdXNoIiwiZm9yRWFjaCIsIm9wIiwiYXBwbHlPcGVyYXRpb24iLCJzZXQiLCJzYXZlIiwib3B0aW9ucyIsIm1lcmdlIiwib3BlcmF0aW9ucyIsInByZXZpb3VzIiwibGVuZ3RoIiwiY29uY2F0Iiwic2l6ZSIsInRha2UiLCJjbGVhciIsInVuZG8iLCJzbGljZSIsInJldmVyc2UiLCJpbnZlcnNlIiwiaW52Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7Ozs7O0FBTUEsSUFBTUEsYUFBYSxFQUFuQjs7QUFFQTs7Ozs7O0FBTUFBLFdBQVdDLElBQVgsR0FBa0IsVUFBQ0MsU0FBRCxFQUFlO0FBQUEsTUFDekJDLEtBRHlCLEdBQ2ZELFNBRGUsQ0FDekJDLEtBRHlCO0FBQUEsZUFFYkEsS0FGYTtBQUFBLE1BRXpCQyxPQUZ5QixVQUV6QkEsT0FGeUI7QUFBQSxpQkFHUkEsT0FIUTtBQUFBLE1BR3pCQyxLQUh5QixZQUd6QkEsS0FIeUI7QUFBQSxNQUdsQkMsS0FIa0IsWUFHbEJBLEtBSGtCOztBQUsvQjs7QUFDQSxNQUFNQyxPQUFPRCxNQUFNRSxJQUFOLEVBQWI7QUFDQSxNQUFJLENBQUNELElBQUwsRUFBVzs7QUFFWDtBQUNBRCxVQUFRQSxNQUFNRyxHQUFOLEVBQVI7QUFDQUosVUFBUUEsTUFBTUssSUFBTixDQUFXSCxJQUFYLENBQVI7O0FBRUE7QUFDQUEsT0FBS0ksT0FBTCxDQUFhLFVBQUNDLEVBQUQsRUFBUTtBQUNuQlYsY0FBVVcsY0FBVixDQUF5QkQsRUFBekI7QUFDRCxHQUZEOztBQUlBO0FBQ0FULFVBQVFELFVBQVVDLEtBQWxCO0FBQ0FDLFlBQVVBLFFBQVFVLEdBQVIsQ0FBWSxPQUFaLEVBQXFCVCxLQUFy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QixDQUFSOztBQUVBO0FBQ0FGLFlBQVVDLEtBQVYsR0FBa0JBLEtBQWxCO0FBQ0QsQ0EzQkQ7O0FBNkJBOzs7Ozs7a0JBTWVILFUiLCJmaWxlIjoib24taGlzdG9yeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUcmFuc2Zvcm1zLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgVHJhbnNmb3JtcyA9IHt9XG5cbi8qKlxuICogUmVkbyB0byB0aGUgbmV4dCBzdGF0ZSBpbiB0aGUgaGlzdG9yeS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKi9cblxuVHJhbnNmb3Jtcy5yZWRvID0gKHRyYW5zZm9ybSkgPT4ge1xuICBsZXQgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGxldCB7IGhpc3RvcnkgfSA9IHN0YXRlXG4gIGxldCB7IHVuZG9zLCByZWRvcyB9ID0gaGlzdG9yeVxuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gbmV4dCBzbmFwc2hvdCwgYWJvcnQuXG4gIGNvbnN0IG5leHQgPSByZWRvcy5wZWVrKClcbiAgaWYgKCFuZXh0KSByZXR1cm5cblxuICAvLyBTaGlmdCB0aGUgbmV4dCBzdGF0ZSBpbnRvIHRoZSB1bmRvIHN0YWNrLlxuICByZWRvcyA9IHJlZG9zLnBvcCgpXG4gIHVuZG9zID0gdW5kb3MucHVzaChuZXh0KVxuXG4gIC8vIFJlcGxheSB0aGUgbmV4dCBvcGVyYXRpb25zLlxuICBuZXh0LmZvckVhY2goKG9wKSA9PiB7XG4gICAgdHJhbnNmb3JtLmFwcGx5T3BlcmF0aW9uKG9wKVxuICB9KVxuXG4gIC8vIFVwZGF0ZSB0aGUgaGlzdG9yeS5cbiAgc3RhdGUgPSB0cmFuc2Zvcm0uc3RhdGVcbiAgaGlzdG9yeSA9IGhpc3Rvcnkuc2V0KCd1bmRvcycsIHVuZG9zKS5zZXQoJ3JlZG9zJywgcmVkb3MpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdoaXN0b3J5JywgaGlzdG9yeSlcblxuICAvLyBVcGRhdGUgdGhlIHRyYW5zZm9ybS5cbiAgdHJhbnNmb3JtLnN0YXRlID0gc3RhdGVcbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBvcGVyYXRpb25zIGludG8gdGhlIGhpc3RvcnkuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5UcmFuc2Zvcm1zLnNhdmUgPSAodHJhbnNmb3JtLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBtZXJnZSA9IGZhbHNlIH0gPSBvcHRpb25zXG4gIGxldCB7IHN0YXRlLCBvcGVyYXRpb25zIH0gPSB0cmFuc2Zvcm1cbiAgbGV0IHsgaGlzdG9yeSB9ID0gc3RhdGVcbiAgbGV0IHsgdW5kb3MsIHJlZG9zIH0gPSBoaXN0b3J5XG4gIGxldCBwcmV2aW91cyA9IHVuZG9zLnBlZWsoKVxuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBvcGVyYXRpb25zLCBhYm9ydC5cbiAgaWYgKCFvcGVyYXRpb25zLmxlbmd0aCkgcmV0dXJuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHNhdmUgcG9pbnQgb3IgbWVyZ2UgdGhlIG9wZXJhdGlvbnMgaW50byB0aGUgcHJldmlvdXMgb25lLlxuICBpZiAobWVyZ2UgJiYgcHJldmlvdXMpIHtcbiAgICB1bmRvcyA9IHVuZG9zLnBvcCgpXG4gICAgcHJldmlvdXMgPSBwcmV2aW91cy5jb25jYXQob3BlcmF0aW9ucylcbiAgICB1bmRvcyA9IHVuZG9zLnB1c2gocHJldmlvdXMpXG4gIH0gZWxzZSB7XG4gICAgdW5kb3MgPSB1bmRvcy5wdXNoKG9wZXJhdGlvbnMpXG4gIH1cblxuICAvLyBDbGVhciB0aGUgcmVkbyBzdGFjayBhbmQgY29uc3RyYWluIHRoZSB1bmRvcyBzdGFjay5cbiAgaWYgKHVuZG9zLnNpemUgPiAxMDApIHVuZG9zID0gdW5kb3MudGFrZSgxMDApXG4gIHJlZG9zID0gcmVkb3MuY2xlYXIoKVxuXG4gIC8vIFVwZGF0ZSB0aGUgc3RhdGUuXG4gIGhpc3RvcnkgPSBoaXN0b3J5LnNldCgndW5kb3MnLCB1bmRvcykuc2V0KCdyZWRvcycsIHJlZG9zKVxuICBzdGF0ZSA9IHN0YXRlLnNldCgnaGlzdG9yeScsIGhpc3RvcnkpXG5cbiAgLy8gVXBkYXRlIHRoZSB0cmFuc2Zvcm0uXG4gIHRyYW5zZm9ybS5zdGF0ZSA9IHN0YXRlXG59XG5cbi8qKlxuICogVW5kbyB0aGUgcHJldmlvdXMgb3BlcmF0aW9ucyBpbiB0aGUgaGlzdG9yeS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKi9cblxuVHJhbnNmb3Jtcy51bmRvID0gKHRyYW5zZm9ybSkgPT4ge1xuICBsZXQgeyBzdGF0ZSB9ID0gdHJhbnNmb3JtXG4gIGxldCB7IGhpc3RvcnkgfSA9IHN0YXRlXG4gIGxldCB7IHVuZG9zLCByZWRvcyB9ID0gaGlzdG9yeVxuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gcHJldmlvdXMgc25hcHNob3QsIGFib3J0LlxuICBjb25zdCBwcmV2aW91cyA9IHVuZG9zLnBlZWsoKVxuICBpZiAoIXByZXZpb3VzKSByZXR1cm5cblxuICAvLyBTaGlmdCB0aGUgcHJldmlvdXMgb3BlcmF0aW9ucyBpbnRvIHRoZSByZWRvIHN0YWNrLlxuICB1bmRvcyA9IHVuZG9zLnBvcCgpXG4gIHJlZG9zID0gcmVkb3MucHVzaChwcmV2aW91cylcblxuICAvLyBSZXBsYXkgdGhlIGludmVyc2Ugb2YgdGhlIHByZXZpb3VzIG9wZXJhdGlvbnMuXG4gIHByZXZpb3VzLnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2goKG9wKSA9PiB7XG4gICAgb3AuaW52ZXJzZS5mb3JFYWNoKChpbnYpID0+IHtcbiAgICAgIHRyYW5zZm9ybS5hcHBseU9wZXJhdGlvbihpbnYpXG4gICAgfSlcbiAgfSlcblxuICAvLyBVcGRhdGUgdGhlIGhpc3RvcnkuXG4gIHN0YXRlID0gdHJhbnNmb3JtLnN0YXRlXG4gIGhpc3RvcnkgPSBoaXN0b3J5LnNldCgndW5kb3MnLCB1bmRvcykuc2V0KCdyZWRvcycsIHJlZG9zKVxuICBzdGF0ZSA9IHN0YXRlLnNldCgnaGlzdG9yeScsIGhpc3RvcnkpXG5cbiAgLy8gVXBkYXRlIHRoZSB0cmFuc2Zvcm0uXG4gIHRyYW5zZm9ybS5zdGF0ZSA9IHN0YXRlXG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3Jtc1xuIl19