'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _warn = require('../utils/warn');

var _warn2 = _interopRequireDefault(_warn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:operation');

/**
 * Transforms.
 *
 * @type {Object}
 */

var Transforms = {};

/**
 * Operations.
 *
 * @type {Object}
 */

var OPERATIONS = {
  // Text operations.
  insert_text: insertText,
  remove_text: removeText,
  // Mark operations.
  add_mark: addMark,
  remove_mark: removeMark,
  set_mark: setMark,
  // Node operations.
  insert_node: insertNode,
  join_node: joinNode,
  move_node: moveNode,
  remove_node: removeNode,
  set_node: setNode,
  split_node: splitNode,
  // Selection operations.
  set_selection: setSelection,
  // State data operations.
  set_data: setData
};

/**
 * Apply an `operation` to the current state.
 *
 * @param {Transform} transform
 * @param {Object} operation
 */

Transforms.applyOperation = function (transform, operation) {
  var state = transform.state,
      operations = transform.operations;
  var type = operation.type;

  var fn = OPERATIONS[type];

  if (!fn) {
    throw new Error('Unknown operation type: "' + type + '".');
  }

  debug(type, operation);
  transform.state = fn(state, operation);
  transform.operations = operations.concat([operation]);
};

/**
 * Add mark to text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function addMark(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length,
      mark = operation.mark;
  var _state = state,
      document = _state.document;

  var node = document.assertPath(path);
  node = node.addMark(offset, length, mark);
  document = document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Insert a `node` at `index` in a node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function insertNode(state, operation) {
  var path = operation.path,
      index = operation.index,
      node = operation.node;
  var _state2 = state,
      document = _state2.document;

  var parent = document.assertPath(path);
  var isParent = document == parent;
  parent = parent.insertNode(index, node);
  document = isParent ? parent : document.updateDescendant(parent);
  state = state.set('document', document);
  return state;
}

/**
 * Insert `text` at `offset` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function insertText(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      text = operation.text,
      marks = operation.marks;
  var _state3 = state,
      document = _state3.document,
      selection = _state3.selection;
  var _selection = selection,
      anchorKey = _selection.anchorKey,
      focusKey = _selection.focusKey,
      anchorOffset = _selection.anchorOffset,
      focusOffset = _selection.focusOffset;

  var node = document.assertPath(path);

  // Update the document
  node = node.insertText(offset, text, marks);
  document = document.updateDescendant(node);

  // Update the selection
  if (anchorKey == node.key && anchorOffset >= offset) {
    selection = selection.moveAnchor(text.length);
  }
  if (focusKey == node.key && focusOffset >= offset) {
    selection = selection.moveFocus(text.length);
  }

  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Join a node by `path` with a node `withPath`.
 *
 * @param {State} state
 * @param {Object} operation
 *   @param {Boolean} operation.deep (optional) Join recursively the
 *   respective last node and first node of the nodes' children. Like a zipper :)
 * @return {State}
 */

function joinNode(state, operation) {
  var path = operation.path,
      withPath = operation.withPath,
      _operation$deep = operation.deep,
      deep = _operation$deep === undefined ? false : _operation$deep;
  var _state4 = state,
      document = _state4.document,
      selection = _state4.selection;

  var first = document.assertPath(withPath);
  var second = document.assertPath(path);

  document = document.joinNode(first, second, { deep: deep });

  // If the operation is deep, or the nodes are text nodes, it means we will be
  // merging two text nodes together, so we need to update the selection.
  if (deep || second.kind == 'text') {
    var _selection2 = selection,
        anchorKey = _selection2.anchorKey,
        anchorOffset = _selection2.anchorOffset,
        focusKey = _selection2.focusKey,
        focusOffset = _selection2.focusOffset;

    var firstText = first.kind == 'text' ? first : first.getLastText();
    var secondText = second.kind == 'text' ? second : second.getFirstText();

    if (anchorKey == secondText.key) {
      selection = selection.merge({
        anchorKey: firstText.key,
        anchorOffset: anchorOffset + firstText.characters.size
      });
    }

    if (focusKey == secondText.key) {
      selection = selection.merge({
        focusKey: firstText.key,
        focusOffset: focusOffset + firstText.characters.size
      });
    }
  }

  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Move a node by `path` to a new parent by `path` and `index`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function moveNode(state, operation) {
  var path = operation.path,
      newPath = operation.newPath,
      newIndex = operation.newIndex;
  var _state5 = state,
      document = _state5.document;

  var node = document.assertPath(path);
  var index = path[path.length - 1];
  var parentPath = path.slice(0, -1);

  // Remove the node from its current parent
  var parent = document.getParent(node.key);
  parent = parent.removeNode(index);
  document = parent.kind === 'document' ? parent : document.updateDescendant(parent);

  // Check if `parent` is an anchestor of `target`
  var isAncestor = parentPath.every(function (x, i) {
    return x === newPath[i];
  });

  var target = void 0;

  // If `parent` is an ancestor of `target` and their paths have same length,
  // then `parent` and `target` are equal.
  if (isAncestor && parentPath.length === newPath.length) {
    target = parent;
  }

  // Else if `parent` is an ancestor of `target` and `node` index is less than
  // the index of the `target` ancestor with the same depth of `node`,
  // then removing `node` changes the path to `target`.
  // So we have to adjust `newPath` before picking `target`.
  else if (isAncestor && index < newPath[parentPath.length]) {
      newPath[parentPath.length]--;
      target = document.assertPath(newPath);
    }

    // Else pick `target`
    else {
        target = document.assertPath(newPath);
      }

  // Insert the new node to its new parent
  target = target.insertNode(newIndex, node);
  document = target.kind === 'document' ? target : document.updateDescendant(target);

  state = state.set('document', document);
  return state;
}

/**
 * Remove mark from text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function removeMark(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length,
      mark = operation.mark;
  var _state6 = state,
      document = _state6.document;

  var node = document.assertPath(path);
  node = node.removeMark(offset, length, mark);
  document = document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Remove a node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function removeNode(state, operation) {
  var path = operation.path;
  var _state7 = state,
      document = _state7.document,
      selection = _state7.selection;
  var _selection3 = selection,
      startKey = _selection3.startKey,
      endKey = _selection3.endKey;

  var node = document.assertPath(path);

  // If the selection is set, check to see if it needs to be updated.
  if (selection.isSet) {
    var hasStartNode = node.hasNode(startKey);
    var hasEndNode = node.hasNode(endKey);

    // If one of the selection's nodes is being removed, we need to update it.
    if (hasStartNode) {
      var prev = document.getPreviousText(startKey);
      var next = document.getNextText(startKey);

      if (prev) {
        selection = selection.moveStartTo(prev.key, prev.length);
      } else if (next) {
        selection = selection.moveStartTo(next.key, 0);
      } else {
        selection = selection.deselect();
      }
    }

    if (hasEndNode) {
      var _prev = document.getPreviousText(endKey);
      var _next = document.getNextText(endKey);

      if (_prev) {
        selection = selection.moveEndTo(_prev.key, _prev.length);
      } else if (_next) {
        selection = selection.moveEndTo(_next.key, 0);
      } else {
        selection = selection.deselect();
      }
    }
  }

  // Remove the node from the document.
  var parent = document.getParent(node.key);
  var index = parent.nodes.indexOf(node);
  var isParent = document == parent;
  parent = parent.removeNode(index);
  document = isParent ? parent : document.updateDescendant(parent);

  // Update the document and selection.
  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Remove text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function removeText(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length;

  var rangeOffset = offset + length;
  var _state8 = state,
      document = _state8.document,
      selection = _state8.selection;
  var _selection4 = selection,
      anchorKey = _selection4.anchorKey,
      focusKey = _selection4.focusKey,
      anchorOffset = _selection4.anchorOffset,
      focusOffset = _selection4.focusOffset;

  var node = document.assertPath(path);

  // Update the selection
  if (anchorKey == node.key && anchorOffset >= rangeOffset) {
    selection = selection.moveAnchor(-length);
  }
  if (focusKey == node.key && focusOffset >= rangeOffset) {
    selection = selection.moveFocus(-length);
  }

  node = node.removeText(offset, length);
  document = document.updateDescendant(node);
  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Set `data` on `state`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setData(state, operation) {
  var properties = operation.properties;
  var _state9 = state,
      data = _state9.data;


  data = data.merge(properties);
  state = state.set('data', data);
  return state;
}

/**
 * Set `properties` on mark on text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setMark(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length,
      mark = operation.mark,
      newMark = operation.newMark;
  var _state10 = state,
      document = _state10.document;

  var node = document.assertPath(path);
  node = node.updateMark(offset, length, mark, newMark);
  document = document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Set `properties` on a node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setNode(state, operation) {
  var path = operation.path,
      properties = operation.properties;
  var _state11 = state,
      document = _state11.document;

  var node = document.assertPath(path);

  // Deprecate the ability to overwite a node's children.
  if (properties.nodes && properties.nodes != node.nodes) {
    (0, _warn2.default)('Updating a Node\'s `nodes` property via `setNode()` is not allowed. Use the appropriate insertion and removal operations instead. The opeartion in question was:', operation);
    delete properties.nodes;
  }

  // Deprecate the ability to change a node's key.
  if (properties.key && properties.key != node.key) {
    (0, _warn2.default)('Updating a Node\'s `key` property via `setNode()` is not allowed. There should be no reason to do this. The opeartion in question was:', operation);
    delete properties.key;
  }

  node = node.merge(properties);
  document = node.kind === 'document' ? node : document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Set `properties` on the selection.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setSelection(state, operation) {
  var properties = _extends({}, operation.properties);
  var _state12 = state,
      document = _state12.document,
      selection = _state12.selection;


  if (properties.anchorPath !== undefined) {
    properties.anchorKey = properties.anchorPath === null ? null : document.assertPath(properties.anchorPath).key;
    delete properties.anchorPath;
  }

  if (properties.focusPath !== undefined) {
    properties.focusKey = properties.focusPath === null ? null : document.assertPath(properties.focusPath).key;
    delete properties.focusPath;
  }

  selection = selection.merge(properties);
  selection = selection.normalize(document);
  state = state.set('selection', selection);
  return state;
}

/**
 * Split a node by `path` at `offset`.
 *
 * @param {State} state
 * @param {Object} operation
 *   @param {Array} operation.path The path of the node to split
 *   @param {Number} operation.offset (optional) Split using a relative offset
 *   @param {Number} operation.count (optional) Split after `count`
 *   children. Cannot be used in combination with offset.
 * @return {State}
 */

function splitNode(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      count = operation.count;
  var _state13 = state,
      document = _state13.document,
      selection = _state13.selection;

  // If there's no offset, it's using the `count` instead.

  if (offset == null) {
    document = document.splitNodeAfter(path, count);
    state = state.set('document', document);
    return state;
  }

  // Otherwise, split using the `offset`, but calculate a few things first.
  var node = document.assertPath(path);
  var text = node.kind == 'text' ? node : node.getTextAtOffset(offset);
  var textOffset = node.kind == 'text' ? offset : offset - node.getOffset(text.key);
  var _selection5 = selection,
      anchorKey = _selection5.anchorKey,
      anchorOffset = _selection5.anchorOffset,
      focusKey = _selection5.focusKey,
      focusOffset = _selection5.focusOffset;


  document = document.splitNode(path, offset);

  // Determine whether we need to update the selection.
  var splitAnchor = text.key == anchorKey && textOffset <= anchorOffset;
  var splitFocus = text.key == focusKey && textOffset <= focusOffset;

  // If either the anchor of focus was after the split, we need to update them.
  if (splitFocus || splitAnchor) {
    var nextText = document.getNextText(text.key);

    if (splitAnchor) {
      selection = selection.merge({
        anchorKey: nextText.key,
        anchorOffset: anchorOffset - textOffset
      });
    }

    if (splitFocus) {
      selection = selection.merge({
        focusKey: nextText.key,
        focusOffset: focusOffset - textOffset
      });
    }
  }

  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Transforms;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zL2FwcGx5LW9wZXJhdGlvbi5qcyJdLCJuYW1lcyI6WyJkZWJ1ZyIsIlRyYW5zZm9ybXMiLCJPUEVSQVRJT05TIiwiaW5zZXJ0X3RleHQiLCJpbnNlcnRUZXh0IiwicmVtb3ZlX3RleHQiLCJyZW1vdmVUZXh0IiwiYWRkX21hcmsiLCJhZGRNYXJrIiwicmVtb3ZlX21hcmsiLCJyZW1vdmVNYXJrIiwic2V0X21hcmsiLCJzZXRNYXJrIiwiaW5zZXJ0X25vZGUiLCJpbnNlcnROb2RlIiwiam9pbl9ub2RlIiwiam9pbk5vZGUiLCJtb3ZlX25vZGUiLCJtb3ZlTm9kZSIsInJlbW92ZV9ub2RlIiwicmVtb3ZlTm9kZSIsInNldF9ub2RlIiwic2V0Tm9kZSIsInNwbGl0X25vZGUiLCJzcGxpdE5vZGUiLCJzZXRfc2VsZWN0aW9uIiwic2V0U2VsZWN0aW9uIiwic2V0X2RhdGEiLCJzZXREYXRhIiwiYXBwbHlPcGVyYXRpb24iLCJ0cmFuc2Zvcm0iLCJvcGVyYXRpb24iLCJzdGF0ZSIsIm9wZXJhdGlvbnMiLCJ0eXBlIiwiZm4iLCJFcnJvciIsImNvbmNhdCIsInBhdGgiLCJvZmZzZXQiLCJsZW5ndGgiLCJtYXJrIiwiZG9jdW1lbnQiLCJub2RlIiwiYXNzZXJ0UGF0aCIsInVwZGF0ZURlc2NlbmRhbnQiLCJzZXQiLCJpbmRleCIsInBhcmVudCIsImlzUGFyZW50IiwidGV4dCIsIm1hcmtzIiwic2VsZWN0aW9uIiwiYW5jaG9yS2V5IiwiZm9jdXNLZXkiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImtleSIsIm1vdmVBbmNob3IiLCJtb3ZlRm9jdXMiLCJ3aXRoUGF0aCIsImRlZXAiLCJmaXJzdCIsInNlY29uZCIsImtpbmQiLCJmaXJzdFRleHQiLCJnZXRMYXN0VGV4dCIsInNlY29uZFRleHQiLCJnZXRGaXJzdFRleHQiLCJtZXJnZSIsImNoYXJhY3RlcnMiLCJzaXplIiwibmV3UGF0aCIsIm5ld0luZGV4IiwicGFyZW50UGF0aCIsInNsaWNlIiwiZ2V0UGFyZW50IiwiaXNBbmNlc3RvciIsImV2ZXJ5IiwieCIsImkiLCJ0YXJnZXQiLCJzdGFydEtleSIsImVuZEtleSIsImlzU2V0IiwiaGFzU3RhcnROb2RlIiwiaGFzTm9kZSIsImhhc0VuZE5vZGUiLCJwcmV2IiwiZ2V0UHJldmlvdXNUZXh0IiwibmV4dCIsImdldE5leHRUZXh0IiwibW92ZVN0YXJ0VG8iLCJkZXNlbGVjdCIsIm1vdmVFbmRUbyIsIm5vZGVzIiwiaW5kZXhPZiIsInJhbmdlT2Zmc2V0IiwicHJvcGVydGllcyIsImRhdGEiLCJuZXdNYXJrIiwidXBkYXRlTWFyayIsImFuY2hvclBhdGgiLCJ1bmRlZmluZWQiLCJmb2N1c1BhdGgiLCJub3JtYWxpemUiLCJjb3VudCIsInNwbGl0Tm9kZUFmdGVyIiwiZ2V0VGV4dEF0T2Zmc2V0IiwidGV4dE9mZnNldCIsImdldE9mZnNldCIsInNwbGl0QW5jaG9yIiwic3BsaXRGb2N1cyIsIm5leHRUZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNQSxRQUFRLHFCQUFNLGlCQUFOLENBQWQ7O0FBRUE7Ozs7OztBQU1BLElBQU1DLGFBQWEsRUFBbkI7O0FBRUE7Ozs7OztBQU1BLElBQU1DLGFBQWE7QUFDakI7QUFDQUMsZUFBYUMsVUFGSTtBQUdqQkMsZUFBYUMsVUFISTtBQUlqQjtBQUNBQyxZQUFVQyxPQUxPO0FBTWpCQyxlQUFhQyxVQU5JO0FBT2pCQyxZQUFVQyxPQVBPO0FBUWpCO0FBQ0FDLGVBQWFDLFVBVEk7QUFVakJDLGFBQVdDLFFBVk07QUFXakJDLGFBQVdDLFFBWE07QUFZakJDLGVBQWFDLFVBWkk7QUFhakJDLFlBQVVDLE9BYk87QUFjakJDLGNBQVlDLFNBZEs7QUFlakI7QUFDQUMsaUJBQWVDLFlBaEJFO0FBaUJqQjtBQUNBQyxZQUFVQztBQWxCTyxDQUFuQjs7QUFxQkE7Ozs7Ozs7QUFPQTNCLFdBQVc0QixjQUFYLEdBQTRCLFVBQUNDLFNB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QWV3QkwsU0FmeEI7QUFBQSxNQWUzQkMsU0FmMkIsZUFlM0JBLFNBZjJCO0FBQUEsTUFlaEJFLFlBZmdCLGVBZWhCQSxZQWZnQjtBQUFBLE1BZUZELFFBZkUsZUFlRkEsUUFmRTtBQUFBLE1BZVFFLFdBZlIsZUFlUUEsV0FmUjs7O0FBaUJuQ2QsYUFBV0EsU0FBU2xCLFNBQVQsQ0FBbUJjLElBQW5CLEVBQXlCQyxNQUF6QixDQUFYOztBQUVBO0FBQ0EsTUFBTXdFLGNBQWM3RCxLQUFLTyxHQUFMLElBQVlKLFNBQVosSUFBeUJ3RCxjQUFjdEQsWUFBM0Q7QUFDQSxNQUFNeUQsYUFBYTlELEtBQUtPLEdBQUwsSUFBWUgsUUFBWixJQUF3QnVELGNBQWNyRCxXQUF6RDs7QUFFQTtBQUNBLE1BQUl3RCxjQUFjRCxXQUFsQixFQUErQjtBQUM3QixRQUFNRSxXQUFXdkUsU0FBU2lELFdBQVQsQ0FBcUJ6QyxLQUFLTyxHQUExQixDQUFqQjs7QUFFQSxRQUFJc0QsV0FBSixFQUFpQjtBQUNmM0Qsa0JBQVlBLFVBQVVpQixLQUFWLENBQWdCO0FBQzFCaEIsbUJBQVc0RCxTQUFTeEQsR0FETTtBQUUxQkYsc0JBQWNBLGVBQWVzRDtBQUZILE9BQWhCLENBQVo7QUFJRDs7QUFFRCxRQUFJRyxVQUFKLEVBQWdCO0FBQ2Q1RCxrQkFBWUEsVUFBVWlCLEtBQVYsQ0FBZ0I7QUFDMUJmLGtCQUFVMkQsU0FBU3hELEdBRE87QUFFMUJELHFCQUFhQSxjQUFjcUQ7QUFGRCxPQUFoQixDQUFaO0FBSUQ7QUFDRjs7QUFFRDdFLFVBQVFBLE1BQU1jLEdBQU4sQ0FBVSxVQUFWLEVBQXNCSixRQUF0QixFQUFnQ0ksR0FBaEMsQ0FBb0MsV0FBcEMsRUFBaURNLFNBQWpELENBQVI7QUFDQSxTQUFPcEIsS0FBUDtBQUNEOztBQUVEOzs7Ozs7a0JBTWUvQixVIiwiZmlsZSI6ImFwcGx5LW9wZXJhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHdhcm4gZnJvbSAnLi4vdXRpbHMvd2FybidcblxuLyoqXG4gKiBEZWJ1Zy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxuY29uc3QgZGVidWcgPSBEZWJ1Zygnc2xhdGU6b3BlcmF0aW9uJylcblxuLyoqXG4gKiBUcmFuc2Zvcm1zLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgVHJhbnNmb3JtcyA9IHt9XG5cbi8qKlxuICogT3BlcmF0aW9ucy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IE9QRVJBVElPTlMgPSB7XG4gIC8vIFRleHQgb3BlcmF0aW9ucy5cbiAgaW5zZXJ0X3RleHQ6IGluc2VydFRleHQsXG4gIHJlbW92ZV90ZXh0OiByZW1vdmVUZXh0LFxuICAvLyBNYXJrIG9wZXJhdGlvbnMuXG4gIGFkZF9tYXJrOiBhZGRNYXJrLFxuICByZW1vdmVfbWFyazogcmVtb3ZlTWFyayxcbiAgc2V0X21hcms6IHNldE1hcmssXG4gIC8vIE5vZGUgb3BlcmF0aW9ucy5cbiAgaW5zZXJ0X25vZGU6IGluc2VydE5vZGUsXG4gIGpvaW5fbm9kZTogam9pbk5vZGUsXG4gIG1vdmVfbm9kZTogbW92ZU5vZGUsXG4gIHJlbW92ZV9ub2RlOiByZW1vdmVOb2RlLFxuICBzZXRfbm9kZTogc2V0Tm9kZSxcbiAgc3BsaXRfbm9kZTogc3BsaXROb2RlLFxuICAvLyBTZWxlY3Rpb24gb3BlcmF0aW9ucy5cbiAgc2V0X3NlbGVjdGlvbjogc2V0U2VsZWN0aW9uLFxuICAvLyBTdGF0ZSBkYXRhIG9wZXJhdGlvbnMuXG4gIHNldF9kYXRhOiBzZXREYXRhXG59XG5cbi8qKlxuICogQXBwbHkgYW4gYG9wZXJhdGlvbmAgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICovXG5cblRyYW5zZm9ybXMuYXBwbHlPcGVyYXRpb24gPSAodHJhbnNmb3JtLCBvcGVyYXRpb24pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSwgb3BlcmF0aW9ucyB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IHsgdHlwZSB9ID0gb3BlcmF0aW9uXG4gIGNvbnN0IGZuID0gT1BFUkFUSU9OU1t0eXBlXVxuXG4gIGlmICghZm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0aW9uIHR5cGU6IFwiJHt0eXBlfVwiLmApXG4gIH1cblxuICBkZWJ1Zyh0eXBlLCBvcGVyYXRpb24pXG4gIHRyYW5zZm9ybS5zdGF0ZSA9IGZuKHN0YXRlLCBvcGVyYXRpb24pXG4gIHRyYW5zZm9ybS5vcGVyYXRpb25zID0gb3BlcmF0aW9ucy5jb25jYXQoW29wZXJhdGlvbl0pXG59XG5cbi8qKlxuICogQWRkIG1hcmsgdG8gdGV4dCBhdCBgb2Zmc2V0YCBhbmQgYGxlbmd0aGAgaW4gbm9kZSBieSBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge1N0YXRlfVxuICovXG5cbmZ1bmN0aW9uIGFkZE1hcmsoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIG9mZnNldCwgbGVuZ3RoLCBtYXJrIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChwYXRoKVxuICBub2RlID0gbm9kZS5hZGRNYXJrKG9mZnNldCwgbGVuZ3RoLCBtYXJrKVxuICBkb2N1bWVudCA9IGRvY3VtZW50LnVwZGF0ZURlc2NlbmRhbnQobm9kZSlcbiAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIEluc2VydCBhIGBub2RlYCBhdCBgaW5kZXhgIGluIGEgbm9kZSBieSBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge1N0YXRlfVxuICovXG5cbmZ1bmN0aW9uIGluc2VydE5vZGUoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIGluZGV4LCBub2RlIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBwYXJlbnQgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG4gIGNvbnN0IGlzUGFyZW50ID0gZG9jdW1lbnQgPT0gcGFyZW50XG4gIHBhcmVudCA9IHBhcmVudC5pbnNlcnROb2RlKGluZGV4LCBub2RlKVxuICBkb2N1bWVudCA9IGlzUGFyZW50ID8gcGFyZW50IDogZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChwYXJlbnQpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBJbnNlcnQgYHRleHRgIGF0IGBvZmZzZXRgIGluIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBpbnNlcnRUZXh0KHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwYXRoLCBvZmZzZXQsIHRleHQsIG1hcmtzIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgY29uc3QgeyBhbmNob3JLZXksIGZvY3VzS2V5LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0IH0gPSBzZWxlY3Rpb25cbiAgbGV0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG5cbiAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudFxuICBub2RlID0gbm9kZS5pbnNlcnRUZXh0KG9mZnNldCwgdGV4dCwgbWFya3MpXG4gIGRvY3VtZW50ID0gZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChub2RlKVxuXG4gIC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gIGlmIChhbmNob3JLZXkgPT0gbm9kZS5rZXkgJiYgYW5jaG9yT2Zmc2V0ID49IG9mZnNldCkge1xuICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tb3ZlQW5jaG9yKHRleHQubGVuZ3RoKVxuICB9XG4gIGlmIChmb2N1c0tleSA9PSBub2RlLmtleSAmJiBmb2N1c09mZnNldCA+PSBvZmZzZXQpIHtcbiAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24ubW92ZUZvY3VzKHRleHQubGVuZ3RoKVxuICB9XG5cbiAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpLnNldCgnc2VsZWN0aW9uJywgc2VsZWN0aW9uKVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBKb2luIGEgbm9kZSBieSBgcGF0aGAgd2l0aCBhIG5vZGUgYHdpdGhQYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogICBAcGFyYW0ge0Jvb2xlYW59IG9wZXJhdGlvbi5kZWVwIChvcHRpb25hbCkgSm9pbiByZWN1cnNpdmVseSB0aGVcbiAqICAgcmVzcGVjdGl2ZSBsYXN0IG5vZGUgYW5kIGZpcnN0IG5vZGUgb2YgdGhlIG5vZGVzJyBjaGlsZHJlbi4gTGlrZSBhIHppcHBlciA6KVxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gam9pbk5vZGUoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIHdpdGhQYXRoLCBkZWVwID0gZmFsc2UgfSA9IG9wZXJhdGlvblxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjb25zdCBmaXJzdCA9IGRvY3VtZW50LmFzc2VydFBhdGgod2l0aFBhdGgpXG4gIGNvbnN0IHNlY29uZCA9IGRvY3VtZW50LmFzc2VydFBhdGgocGF0aClcblxuICBkb2N1bWVudCA9IGRvY3VtZW50LmpvaW5Ob2RlKGZpcnN0LCBzZWNvbmQsIHsgZGVlcCB9KVxuXG4gIC8vIElmIHRoZSBvcGVyYXRpb24gaXMgZGVlcCwgb3IgdGhlIG5vZGVzIGFyZSB0ZXh0IG5vZGVzLCBpdCBtZWFucyB3ZSB3aWxsIGJlXG4gIC8vIG1lcmdpbmcgdHdvIHRleHQgbm9kZXMgdG9nZXRoZXIsIHNvIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gIGlmIChkZWVwIHx8IHNlY29uZC5raW5kID09ICd0ZXh0Jykge1xuICAgIGNvbnN0IHsgYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGZvY3VzS2V5LCBmb2N1c09mZnNldCB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgZmlyc3RUZXh0ID0gZmlyc3Qua2luZCA9PSAndGV4dCcgPyBmaXJzdCA6IGZpcnN0LmdldExhc3RUZXh0KClcbiAgICBjb25zdCBzZWNvbmRUZXh0ID0gc2Vjb25kLmtpbmQgPT0gJ3RleHQnID8gc2Vjb25kIDogc2Vjb25kLmdldEZpcnN0VGV4dCgpXG5cbiAgICBpZiAoYW5jaG9yS2V5ID09IHNlY29uZFRleHQua2V5KSB7XG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24ubWVyZ2Uoe1xuICAgICAgICBhbmNob3JLZXk6IGZpcnN0VGV4dC5rZXksXG4gICAgICAgIGFuY2hvck9mZnNldDogYW5jaG9yT2Zmc2V0ICsgZmlyc3RUZXh0LmNoYXJhY3RlcnMuc2l6ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZm9jdXNLZXkgPT0gc2Vjb25kVGV4dC5rZXkpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICAgIGZvY3VzS2V5OiBmaXJzdFRleHQua2V5LFxuICAgICAgICBmb2N1c09mZnNldDogZm9jdXNPZmZzZXQgKyBmaXJzdFRleHQuY2hhcmFjdGVycy5zaXplXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KS5zZXQoJ3NlbGVjdGlvbicsIHNlbGVjdGlvbilcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogTW92ZSBhIG5vZGUgYnkgYHBhdGhgIHRvIGEgbmV3IHBhcmVudCBieSBgcGF0aGAgYW5kIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge1N0YXRlfVxuICovXG5cbmZ1bmN0aW9uIG1vdmVOb2RlKHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwYXRoLCBuZXdQYXRoLCBuZXdJbmRleCB9ID0gb3BlcmF0aW9uXG4gIGxldCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChwYXRoKVxuICBjb25zdCBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aC5zbGljZSgwLCAtMSlcblxuICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSBpdHMgY3VycmVudCBwYXJlbnRcbiAgbGV0IHBhcmVudCA9IGRvY3VtZW50LmdldFBhcmVudChub2RlLmtleSlcbiAgcGFyZW50ID0gcGFyZW50LnJlbW92ZU5vZGUoaW5kZXgpXG4gIGRvY3VtZW50ID0gcGFyZW50LmtpbmQgPT09ICdkb2N1bWVudCcgPyBwYXJlbnQgOiBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KHBhcmVudClcblxuICAvLyBDaGVjayBpZiBgcGFyZW50YCBpcyBhbiBhbmNoZXN0b3Igb2YgYHRhcmdldGBcbiAgY29uc3QgaXNBbmNlc3RvciA9IHBhcmVudFBhdGguZXZlcnkoKHgsIGkpID0+IHggPT09IG5ld1BhdGhbaV0pXG5cbiAgbGV0IHRhcmdldFxuXG4gIC8vIElmIGBwYXJlbnRgIGlzIGFuIGFuY2VzdG9yIG9mIGB0YXJnZXRgIGFuZCB0aGVpciBwYXRocyBoYXZlIHNhbWUgbGVuZ3RoLFxuICAvLyB0aGVuIGBwYXJlbnRgIGFuZCBgdGFyZ2V0YCBhcmUgZXF1YWwuXG4gIGlmIChpc0FuY2VzdG9yICYmIHBhcmVudFBhdGgubGVuZ3RoID09PSBuZXdQYXRoLmxlbmd0aCkge1xuICAgIHRhcmdldCA9IHBhcmVudFxuICB9XG5cbiAgLy8gRWxzZSBpZiBgcGFyZW50YCBpcyBhbiBhbmNlc3RvciBvZiBgdGFyZ2V0YCBhbmQgYG5vZGVgIGluZGV4IGlzIGxlc3MgdGhhblxuICAvLyB0aGUgaW5kZXggb2YgdGhlIGB0YXJnZXRgIGFuY2VzdG9yIHdpdGggdGhlIHNhbWUgZGVwdGggb2YgYG5vZGVgLFxuICAvLyB0aGVuIHJlbW92aW5nIGBub2RlYCBjaGFuZ2VzIHRoZSBwYXRoIHRvIGB0YXJnZXRgLlxuICAvLyBTbyB3ZSBoYXZlIHRvIGFkanVzdCBgbmV3UGF0aGAgYmVmb3JlIHBpY2tpbmcgYHRhcmdldGAuXG4gIGVsc2UgaWYgKGlzQW5jZXN0b3IgJiYgaW5kZXggPCBuZXdQYXRoW3BhcmVudFBhdGgubGVuZ3RoXSkge1xuICAgIG5ld1BhdGhbcGFyZW50UGF0aC5sZW5ndGhdLS1cbiAgICB0YXJnZXQgPSBkb2N1bWVudC5hc3NlcnRQYXRoKG5ld1BhdGgpXG4gIH1cblxuICAvLyBFbHNlIHBpY2sgYHRhcmdldGBcbiAgZWxzZSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChuZXdQYXRoKVxuICB9XG5cbiAgLy8gSW5zZXJ0IHRoZSBuZXcgbm9kZSB0byBpdHMgbmV3IHBhcmVudFxuICB0YXJnZXQgPSB0YXJnZXQuaW5zZXJ0Tm9kZShuZXdJbmRleCwgbm9kZSlcbiAgZG9jdW1lbnQgPSB0YXJnZXQua2luZCA9PT0gJ2RvY3VtZW50JyA/IHRhcmdldCA6IGRvY3VtZW50LnVwZGF0ZURlc2NlbmRhbnQodGFyZ2V0KVxuXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBSZW1vdmUgbWFyayBmcm9tIHRleHQgYXQgYG9mZnNldGAgYW5kIGBsZW5ndGhgIGluIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVNYXJrKHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwYXRoLCBvZmZzZXQsIGxlbmd0aCwgbWFyayB9ID0gb3BlcmF0aW9uXG4gIGxldCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBsZXQgbm9kZSA9IGRvY3VtZW50LmFzc2VydFBhdGgocGF0aClcbiAgbm9kZSA9IG5vZGUucmVtb3ZlTWFyayhvZmZzZXQsIGxlbmd0aCwgbWFyaylcbiAgZG9jdW1lbnQgPSBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KG5vZGUpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHsgcGF0aCB9ID0gb3BlcmF0aW9uXG4gIGxldCB7IGRvY3VtZW50LCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIGNvbnN0IHsgc3RhcnRLZXksIGVuZEtleSB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG5cbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBzZXQsIGNoZWNrIHRvIHNlZSBpZiBpdCBuZWVkcyB0byBiZSB1cGRhdGVkLlxuICBpZiAoc2VsZWN0aW9uLmlzU2V0KSB7XG4gICAgY29uc3QgaGFzU3RhcnROb2RlID0gbm9kZS5oYXNOb2RlKHN0YXJ0S2V5KVxuICAgIGNvbnN0IGhhc0VuZE5vZGUgPSBub2RlLmhhc05vZGUoZW5kS2V5KVxuXG4gICAgLy8gSWYgb25lIG9mIHRoZSBzZWxlY3Rpb24ncyBub2RlcyBpcyBiZWluZyByZW1vdmVkLCB3ZSBuZWVkIHRvIHVwZGF0ZSBpdC5cbiAgICBpZiAoaGFzU3RhcnROb2RlKSB7XG4gICAgICBjb25zdCBwcmV2ID0gZG9jdW1lbnQuZ2V0UHJldmlvdXNUZXh0KHN0YXJ0S2V5KVxuICAgICAgY29uc3QgbmV4dCA9IGRvY3VtZW50LmdldE5leHRUZXh0KHN0YXJ0S2V5KVxuXG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24ubW92ZVN0YXJ0VG8ocHJldi5rZXksIHByZXYubGVuZ3RoKVxuICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tb3ZlU3RhcnRUbyhuZXh0LmtleSwgMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5kZXNlbGVjdCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc0VuZE5vZGUpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBkb2N1bWVudC5nZXRQcmV2aW91c1RleHQoZW5kS2V5KVxuICAgICAgY29uc3QgbmV4dCA9IGRvY3VtZW50LmdldE5leHRUZXh0KGVuZEtleSlcblxuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1vdmVFbmRUbyhwcmV2LmtleSwgcHJldi5sZW5ndGgpXG4gICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1vdmVFbmRUbyhuZXh0LmtleSwgMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5kZXNlbGVjdCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGRvY3VtZW50LlxuICBsZXQgcGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50KG5vZGUua2V5KVxuICBjb25zdCBpbmRleCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKG5vZGUpXG4gIGNvbnN0IGlzUGFyZW50ID0gZG9jdW1lbnQgPT0gcGFyZW50XG4gIHBhcmVudCA9IHBhcmVudC5yZW1vdmVOb2RlKGluZGV4KVxuICBkb2N1bWVudCA9IGlzUGFyZW50ID8gcGFyZW50IDogZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChwYXJlbnQpXG5cbiAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudCBhbmQgc2VsZWN0aW9uLlxuICBzdGF0ZSA9IHN0YXRlLnNldCgnZG9jdW1lbnQnLCBkb2N1bWVudCkuc2V0KCdzZWxlY3Rpb24nLCBzZWxlY3Rpb24pXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIFJlbW92ZSB0ZXh0IGF0IGBvZmZzZXRgIGFuZCBgbGVuZ3RoYCBpbiBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVGV4dChzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHsgcGF0aCwgb2Zmc2V0LCBsZW5ndGggfSA9IG9wZXJhdGlvblxuICBjb25zdCByYW5nZU9mZnNldCA9IG9mZnNldCArIGxlbmd0aFxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjb25zdCB7IGFuY2hvcktleSwgZm9jdXNLZXksIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQgfSA9IHNlbGVjdGlvblxuICBsZXQgbm9kZSA9IGRvY3VtZW50LmFzc2VydFBhdGgocGF0aClcblxuICAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvblxuICBpZiAoYW5jaG9yS2V5ID09IG5vZGUua2V5ICYmIGFuY2hvck9mZnNldCA+PSByYW5nZU9mZnNldCkge1xuICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tb3ZlQW5jaG9yKC1sZW5ndGgpXG4gIH1cbiAgaWYgKGZvY3VzS2V5ID09IG5vZGUua2V5ICYmIGZvY3VzT2Zmc2V0ID49IHJhbmdlT2Zmc2V0KSB7XG4gICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1vdmVGb2N1cygtbGVuZ3RoKVxuICB9XG5cbiAgbm9kZSA9IG5vZGUucmVtb3ZlVGV4dChvZmZzZXQsIGxlbmd0aClcbiAgZG9jdW1lbnQgPSBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KG5vZGUpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KS5zZXQoJ3NlbGVjdGlvbicsIHNlbGVjdGlvbilcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogU2V0IGBkYXRhYCBvbiBgc3RhdGVgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBzZXREYXRhKHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZGF0YSB9ID0gc3RhdGVcblxuICBkYXRhID0gZGF0YS5tZXJnZShwcm9wZXJ0aWVzKVxuICBzdGF0ZSA9IHN0YXRlLnNldCgnZGF0YScsIGRhdGEpXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIFNldCBgcHJvcGVydGllc2Agb24gbWFyayBvbiB0ZXh0IGF0IGBvZmZzZXRgIGFuZCBgbGVuZ3RoYCBpbiBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gc2V0TWFyayhzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHsgcGF0aCwgb2Zmc2V0LCBsZW5ndGgsIG1hcmssIG5ld01hcmsgfSA9IG9wZXJhdGlvblxuICBsZXQgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgbGV0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG4gIG5vZGUgPSBub2RlLnVwZGF0ZU1hcmsob2Zmc2V0LCBsZW5ndGgsIG1hcmssIG5ld01hcmspXG4gIGRvY3VtZW50ID0gZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChub2RlKVxuICBzdGF0ZSA9IHN0YXRlLnNldCgnZG9jdW1lbnQnLCBkb2N1bWVudClcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogU2V0IGBwcm9wZXJ0aWVzYCBvbiBhIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBzZXROb2RlKHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwYXRoLCBwcm9wZXJ0aWVzIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChwYXRoKVxuXG4gIC8vIERlcHJlY2F0ZSB0aGUgYWJpbGl0eSB0byBvdmVyd2l0ZSBhIG5vZGUncyBjaGlsZHJlbi5cbiAgaWYgKHByb3BlcnRpZXMubm9kZXMgJiYgcHJvcGVydGllcy5ub2RlcyAhPSBub2RlLm5vZGVzKSB7XG4gICAgd2FybignVXBkYXRpbmcgYSBOb2RlXFwncyBgbm9kZXNgIHByb3BlcnR5IHZpYSBgc2V0Tm9kZSgpYCBpcyBub3QgYWxsb3dlZC4gVXNlIHRoZSBhcHByb3ByaWF0ZSBpbnNlcnRpb24gYW5kIHJlbW92YWwgb3BlcmF0aW9ucyBpbnN0ZWFkLiBUaGUgb3BlYXJ0aW9uIGluIHF1ZXN0aW9uIHdhczonLCBvcGVyYXRpb24pXG4gICAgZGVsZXRlIHByb3BlcnRpZXMubm9kZXNcbiAgfVxuXG4gIC8vIERlcHJlY2F0ZSB0aGUgYWJpbGl0eSB0byBjaGFuZ2UgYSBub2RlJ3Mga2V5LlxuICBpZiAocHJvcGVydGllcy5rZXkgJiYgcHJvcGVydGllcy5rZXkgIT0gbm9kZS5rZXkpIHtcbiAgICB3YXJuKCdVcGRhdGluZyBhIE5vZGVcXCdzIGBrZXlgIHByb3BlcnR5IHZpYSBgc2V0Tm9kZSgpYCBpcyBub3QgYWxsb3dlZC4gVGhlcmUgc2hvdWxkIGJlIG5vIHJlYXNvbiB0byBkbyB0aGlzLiBUaGUgb3BlYXJ0aW9uIGluIHF1ZXN0aW9uIHdhczonLCBvcGVyYXRpb24pXG4gICAgZGVsZXRlIHByb3BlcnRpZXMua2V5XG4gIH1cblxuICBub2RlID0gbm9kZS5tZXJnZShwcm9wZXJ0aWVzKVxuICBkb2N1bWVudCA9IG5vZGUua2luZCA9PT0gJ2RvY3VtZW50JyA/IG5vZGUgOiBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KG5vZGUpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBTZXQgYHByb3BlcnRpZXNgIG9uIHRoZSBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge1N0YXRlfVxuICovXG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7IC4uLm9wZXJhdGlvbi5wcm9wZXJ0aWVzIH1cbiAgbGV0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcblxuICBpZiAocHJvcGVydGllcy5hbmNob3JQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBwcm9wZXJ0aWVzLmFuY2hvcktleSA9IHByb3BlcnRpZXMuYW5jaG9yUGF0aCA9PT0gbnVsbFxuICAgICAgPyBudWxsXG4gICAgICA6IGRvY3VtZW50LmFzc2VydFBhdGgocHJvcGVydGllcy5hbmNob3JQYXRoKS5rZXlcbiAgICBkZWxldGUgcHJvcGVydGllcy5hbmNob3JQYXRoXG4gIH1cblxuICBpZiAocHJvcGVydGllcy5mb2N1c1BhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIHByb3BlcnRpZXMuZm9jdXNLZXkgPSBwcm9wZXJ0aWVzLmZvY3VzUGF0aCA9PT0gbnVsbFxuICAgICAgPyBudWxsXG4gICAgICA6IGRvY3VtZW50LmFzc2VydFBhdGgocHJvcGVydGllcy5mb2N1c1BhdGgpLmtleVxuICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLmZvY3VzUGF0aFxuICB9XG5cbiAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1lcmdlKHByb3BlcnRpZXMpXG4gIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5ub3JtYWxpemUoZG9jdW1lbnQpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdzZWxlY3Rpb24nLCBzZWxlY3Rpb24pXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIFNwbGl0IGEgbm9kZSBieSBgcGF0aGAgYXQgYG9mZnNldGAuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqICAgQHBhcmFtIHtBcnJheX0gb3BlcmF0aW9uLnBhdGggVGhlIHBhdGggb2YgdGhlIG5vZGUgdG8gc3BsaXRcbiAqICAgQHBhcmFtIHtOdW1iZXJ9IG9wZXJhdGlvbi5vZmZzZXQgKG9wdGlvbmFsKSBTcGxpdCB1c2luZyBhIHJlbGF0aXZlIG9mZnNldFxuICogICBAcGFyYW0ge051bWJlcn0gb3BlcmF0aW9uLmNvdW50IChvcHRpb25hbCkgU3BsaXQgYWZ0ZXIgYGNvdW50YFxuICogICBjaGlsZHJlbi4gQ2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBzcGxpdE5vZGUoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIG9mZnNldCwgY291bnQgfSA9IG9wZXJhdGlvblxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gb2Zmc2V0LCBpdCdzIHVzaW5nIHRoZSBgY291bnRgIGluc3RlYWQuXG4gIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuICAgIGRvY3VtZW50ID0gZG9jdW1lbnQuc3BsaXROb2RlQWZ0ZXIocGF0aCwgY291bnQpXG4gICAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvLyBPdGhlcndpc2UsIHNwbGl0IHVzaW5nIHRoZSBgb2Zmc2V0YCwgYnV0IGNhbGN1bGF0ZSBhIGZldyB0aGluZ3MgZmlyc3QuXG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG4gIGNvbnN0IHRleHQgPSBub2RlLmtpbmQgPT0gJ3RleHQnID8gbm9kZSA6IG5vZGUuZ2V0VGV4dEF0T2Zmc2V0KG9mZnNldClcbiAgY29uc3QgdGV4dE9mZnNldCA9IG5vZGUua2luZCA9PSAndGV4dCcgPyBvZmZzZXQgOiBvZmZzZXQgLSBub2RlLmdldE9mZnNldCh0ZXh0LmtleSlcbiAgY29uc3QgeyBhbmNob3JLZXksIGFuY2hvck9mZnNldCwgZm9jdXNLZXksIGZvY3VzT2Zmc2V0IH0gPSBzZWxlY3Rpb25cblxuICBkb2N1bWVudCA9IGRvY3VtZW50LnNwbGl0Tm9kZShwYXRoLCBvZmZzZXQpXG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHNlbGVjdGlvbi5cbiAgY29uc3Qgc3BsaXRBbmNob3IgPSB0ZXh0LmtleSA9PSBhbmNob3JLZXkgJiYgdGV4dE9mZnNldCA8PSBhbmNob3JPZmZzZXRcbiAgY29uc3Qgc3BsaXRGb2N1cyA9IHRleHQua2V5ID09IGZvY3VzS2V5ICYmIHRleHRPZmZzZXQgPD0gZm9jdXNPZmZzZXRcblxuICAvLyBJZiBlaXRoZXIgdGhlIGFuY2hvciBvZiBmb2N1cyB3YXMgYWZ0ZXIgdGhlIHNwbGl0LCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGVtLlxuICBpZiAoc3BsaXRGb2N1cyB8fCBzcGxpdEFuY2hvcikge1xuICAgIGNvbnN0IG5leHRUZXh0ID0gZG9jdW1lbnQuZ2V0TmV4dFRleHQodGV4dC5rZXkpXG5cbiAgICBpZiAoc3BsaXRBbmNob3IpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICAgIGFuY2hvcktleTogbmV4dFRleHQua2V5LFxuICAgICAgICBhbmNob3JPZmZzZXQ6IGFuY2hvck9mZnNldCAtIHRleHRPZmZzZXRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHNwbGl0Rm9jdXMpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICAgIGZvY3VzS2V5OiBuZXh0VGV4dC5rZXksXG4gICAgICAgIGZvY3VzT2Zmc2V0OiBmb2N1c09mZnNldCAtIHRleHRPZmZzZXRcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpLnNldCgnc2VsZWN0aW9uJywgc2VsZWN0aW9uKVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm1zXG4iXX0=