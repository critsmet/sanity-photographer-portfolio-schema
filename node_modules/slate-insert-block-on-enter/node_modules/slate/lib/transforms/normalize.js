'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _normalize = require('../utils/normalize');

var _normalize2 = _interopRequireDefault(_normalize);

var _schema = require('../models/schema');

var _schema2 = _interopRequireDefault(_schema);

var _warn = require('../utils/warn');

var _warn2 = _interopRequireDefault(_warn);

var _immutable = require('immutable');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transforms.
 *
 * @type {Object}
 */

var Transforms = {};

/**
 * Normalize the document and selection with a `schema`.
 *
 * @param {Transform} transform
 * @param {Schema} schema
 */

Transforms.normalize = function (transform, schema) {
  transform.normalizeDocument(schema);
  transform.normalizeSelection(schema);
};

/**
 * Normalize the document with a `schema`.
 *
 * @param {Transform} transform
 * @param {Schema} schema
 */

Transforms.normalizeDocument = function (transform, schema) {
  var state = transform.state;
  var document = state.document;

  transform.normalizeNodeByKey(document.key, schema);
};

/**
 * Normalize a `node` and its children with a `schema`.
 *
 * @param {Transform} transform
 * @param {Node|String} key
 * @param {Schema} schema
 */

Transforms.normalizeNodeByKey = function (transform, key, schema) {
  assertSchema(schema);

  // If the schema has no validation rules, there's nothing to normalize.
  if (!schema.hasValidators) return;

  key = _normalize2.default.key(key);
  var state = transform.state;
  var document = state.document;

  var node = document.assertNode(key);

  normalizeNodeAndChildren(transform, node, schema);
};

/**
 * Normalize the selection.
 *
 * @param {Transform} transform
 */

Transforms.normalizeSelection = function (transform) {
  var state = transform.state;
  var _state = state,
      document = _state.document,
      selection = _state.selection;

  // If document is empty, return

  if (document.nodes.size === 0) {
    return;
  }

  selection = selection.normalize(document);

  // If the selection is unset, or the anchor or focus key in the selection are
  // pointing to nodes that no longer exist, warn (if not unset) and reset the selection.
  if (selection.isUnset || !document.hasDescendant(selection.anchorKey) || !document.hasDescendant(selection.focusKey)) {
    if (!selection.isUnset) {
      (0, _warn2.default)('The selection was invalid and was reset to start of the document. The selection in question was:', selection);
    }

    var firstText = document.getFirstText();
    selection = selection.merge({
      anchorKey: firstText.key,
      anchorOffset: 0,
      focusKey: firstText.key,
      focusOffset: 0,
      isBackward: false
    });
  }

  state = state.set('selection', selection);
  transform.state = state;
};

/**
 * Normalize a `node` and its children with a `schema`.
 *
 * @param {Transform} transform
 * @param {Node} node
 * @param {Schema} schema
 */

function normalizeNodeAndChildren(transform, node, schema) {
  if (node.kind == 'text') {
    normalizeNode(transform, node, schema);
    return;
  }

  // We can't just loop the children and normalize them, because in the process
  // of normalizing one child, we might end up creating another. Instead, we
  // have to normalize one at a time, and check for new children along the way.
  // PERF: use a mutable array here instead of an immutable stack.
  var keys = node.nodes.toArray().map(function (n) {
    return n.key;
  });

  // While there is still a child key that hasn't been normalized yet...

  var _loop = function _loop() {
    var ops = transform.operations.length;
    var key = void 0;

    // PERF: use a mutable set here since we'll be add to it a lot.
    var set = new _immutable.Set().asMutable();

    // Unwind the stack, normalizing every child and adding it to the set.
    while (key = keys[0]) {
      var child = node.getChild(key);
      normalizeNodeAndChildren(transform, child, schema);
      set.add(key);
      keys.shift();
    }

    // Turn the set immutable to be able to compare against it.
    set = set.asImmutable();

    // PERF: Only re-find the node and re-normalize any new children if
    // operations occured that might have changed it.
    if (transform.operations.length != ops) {
      node = refindNode(transform, node);

      // Add any new children back onto the stack.
      node.nodes.forEach(function (n) {
        if (set.has(n.key)) return;
        keys.unshift(n.key);
      });
    }
  };

  while (keys.length) {
    _loop();
  }

  // Normalize the node itself if it still exists.
  if (node) {
    normalizeNode(transform, node, schema);
  }
}

/**
 * Re-find a reference to a node that may have been modified or removed
 * entirely by a transform.
 *
 * @param {Transform} transform
 * @param {Node} node
 * @return {Node}
 */

function refindNode(transform, node) {
  var state = transform.state;
  var document = state.document;

  return node.kind == 'document' ? document : document.getDescendant(node.key);
}

/**
 * Normalize a `node` with a `schema`, but not its children.
 *
 * @param {Transform} transform
 * @param {Node} node
 * @param {Schema} schema
 */

function normalizeNode(transform, node, schema) {
  var max = schema.rules.length;
  var iterations = 0;

  function iterate(t, n) {
    var failure = n.validate(schema);
    if (!failure) return;

    // Run the `normalize` function for the rule with the invalid value.
    var value = failure.value,
        rule = failure.rule;

    rule.normalize(t, n, value);

    // Re-find the node reference, in case it was updated. If the node no longer
    // exists, we're done for this branch.
    n = refindNode(t, n);
    if (!n) return;

    // Increment the iterations counter, and check to make sure that we haven't
    // exceeded the max. Without this check, it's easy for the `validate` or
    // `normalize` function of a schema rule to be written incorrectly and for
    // an infinite invalid loop to occur.
    iterations++;

    if (iterations > max) {
      throw new Error('A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.');
    }

    // Otherwise, iterate again.
    iterate(t, n);
  }

  iterate(transform, node);
}

/**
 * Assert that a `schema` exists.
 *
 * @param {Schema} schema
 */

function assertSchema(schema) {
  if (schema instanceof _schema2.default) {
    return;
  } else if (schema == null) {
    throw new Error('You must pass a `schema` object.');
  } else {
    throw new Error('You passed an invalid `schema` object: ' + schema + '.');
  }
}

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Transforms;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zL25vcm1hbGl6ZS5qcyJdLCJuYW1lcyI6WyJUcmFuc2Zvcm1zIiwibm9ybWFsaXplIiwidHJhbnNmb3JtIiwic2NoZW1hIiwibm9ybWFsaXplRG9jdW1lbnQiLCJub3JtYWxpemVTZWxlY3Rpb24iLCJzdGF0ZSIsImRvY3VtZW50Iiwibm9ybWFsaXplTm9kZUJ5S2V5Iiwia2V5IiwiYXNzZXJ0U2NoZW1hIiwiaGFzVmFsaWRhdG9ycyIsIm5vZGUiLCJhc3NlcnROb2RlIiwibm9ybWFsaXplTm9kZUFuZENoaWxkcmVuIiwic2VsZWN0aW9uIiwibm9kZXMiLCJzaXplIiwiaXNVbnNldCIsImhhc0Rlc2NlbmRhbnQiLCJhbmNob3JLZXkiLCJmb2N1c0tleSIsImZpcnN0VGV4dCIsImdldEZpcnN0VGV4dCIsIm1lcmdlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJpc0JhY2t3YXJkIiwic2V0Iiwia2luZCIsIm5vcm1hbGl6ZU5vZGUiLCJrZXlzIiwidG9BcnJheSIsIm1hcCIsIm4iLCJvcHMiLCJvcGVyYXRpb25zIiwibGVuZ3RoIiwiYXNNdXRhYmxlIiwiY2hpbGQiLCJnZXRDaGlsZCIsImFkZCIsInNoaWZ0IiwiYXNJbW11dGFibGUiLCJyZWZpbmROb2RlIiwiZm9yRWFjaCIsImhhcyIsInVuc2hpZnQiLCJnZXREZXNjZW5kYW50IiwibWF4IiwicnVsZXMiLCJpdGVyYXRpb25zIiwiaXRlcmF0ZSIsInQiLCJmYWlsdXJlIiwidmFsaWRhdGUiLCJ2YWx1ZSIsInJ1bGUiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBTUEsSUFBTUEsYUFBYSxFQUFuQjs7QUFFQTs7Ozs7OztBQU9BQSxXQUFXQyxTQUFYLEdBQXVCLFVBQUNDLFNBQUQsRUFBWUMsTUFBWixFQUF1QjtBQUM1Q0QsWUFBVUUsaUJBQVYsQ0FBNEJELE1BQTVCO0FBQ0FE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bGl6ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IE5vcm1hbGl6ZSBmcm9tICcuLi91dGlscy9ub3JtYWxpemUnXG5pbXBvcnQgU2NoZW1hIGZyb20gJy4uL21vZGVscy9zY2hlbWEnXG5pbXBvcnQgd2FybiBmcm9tICcuLi91dGlscy93YXJuJ1xuaW1wb3J0IHsgU2V0IH0gZnJvbSAnaW1tdXRhYmxlJ1xuXG4vKipcbiAqIFRyYW5zZm9ybXMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5jb25zdCBUcmFuc2Zvcm1zID0ge31cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gd2l0aCBhIGBzY2hlbWFgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqL1xuXG5UcmFuc2Zvcm1zLm5vcm1hbGl6ZSA9ICh0cmFuc2Zvcm0sIHNjaGVtYSkgPT4ge1xuICB0cmFuc2Zvcm0ubm9ybWFsaXplRG9jdW1lbnQoc2NoZW1hKVxuICB0cmFuc2Zvcm0ubm9ybWFsaXplU2VsZWN0aW9uKHNjaGVtYSlcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGRvY3VtZW50IHdpdGggYSBgc2NoZW1hYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cblxuVHJhbnNmb3Jtcy5ub3JtYWxpemVEb2N1bWVudCA9ICh0cmFuc2Zvcm0sIHNjaGVtYSkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgdHJhbnNmb3JtLm5vcm1hbGl6ZU5vZGVCeUtleShkb2N1bWVudC5rZXksIHNjaGVtYSlcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBgbm9kZWAgYW5kIGl0cyBjaGlsZHJlbiB3aXRoIGEgYHNjaGVtYWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybVxuICogQHBhcmFtIHtOb2RlfFN0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cblxuVHJhbnNmb3Jtcy5ub3JtYWxpemVOb2RlQnlLZXkgPSAodHJhbnNmb3JtLCBrZXksIHNjaGVtYSkgPT4ge1xuICBhc3NlcnRTY2hlbWEoc2NoZW1hKVxuXG4gIC8vIElmIHRoZSBzY2hlbWEgaGFzIG5vIHZhbGlkYXRpb24gcnVsZXMsIHRoZXJlJ3Mgbm90aGluZyB0byBub3JtYWxpemUuXG4gIGlmICghc2NoZW1hLmhhc1ZhbGlkYXRvcnMpIHJldHVyblxuXG4gIGtleSA9IE5vcm1hbGl6ZS5rZXkoa2V5KVxuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmFzc2VydE5vZGUoa2V5KVxuXG4gIG5vcm1hbGl6ZU5vZGVBbmRDaGlsZHJlbih0cmFuc2Zvcm0sIG5vZGUsIHNjaGVtYSlcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKi9cblxuVHJhbnNmb3Jtcy5ub3JtYWxpemVTZWxlY3Rpb24gPSAodHJhbnNmb3JtKSA9PiB7XG4gIGxldCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgbGV0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcblxuICAvLyBJZiBkb2N1bWVudCBpcyBlbXB0eSwgcmV0dXJuXG4gIGlmIChkb2N1bWVudC5ub2Rlcy5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24ubm9ybWFsaXplKGRvY3VtZW50KVxuXG4gIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgdW5zZXQsIG9yIHRoZSBhbmNob3Igb3IgZm9jdXMga2V5IGluIHRoZSBzZWxlY3Rpb24gYXJlXG4gIC8vIHBvaW50aW5nIHRvIG5vZGVzIHRoYXQgbm8gbG9uZ2VyIGV4aXN0LCB3YXJuIChpZiBub3QgdW5zZXQpIGFuZCByZXNldCB0aGUgc2VsZWN0aW9uLlxuICBpZiAoXG4gICAgc2VsZWN0aW9uLmlzVW5zZXQgfHxcbiAgICAhZG9jdW1lbnQuaGFzRGVzY2VuZGFudChzZWxlY3Rpb24uYW5jaG9yS2V5KSB8fFxuICAgICFkb2N1bWVudC5oYXNEZXNjZW5kYW50KHNlbGVjdGlvbi5mb2N1c0tleSlcbiAgKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24uaXNVbnNldCkge1xuICAgICAgd2FybignVGhlIHNlbGVjdGlvbiB3YXMgaW52YWxpZCBhbmQgd2FzIHJlc2V0IHRvIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC4gVGhlIHNlbGVjdGlvbiBpbiBxdWVzdGlvbiB3YXM6Jywgc2VsZWN0aW9uKVxuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0VGV4dCA9IGRvY3VtZW50LmdldEZpcnN0VGV4dCgpXG4gICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1lcmdlKHtcbiAgICAgIGFuY2hvcktleTogZmlyc3RUZXh0LmtleSxcbiAgICAgIGFuY2hvck9mZnNldDogMCxcbiAgICAgIGZvY3VzS2V5OiBmaXJzdFRleHQua2V5LFxuICAgICAgZm9jdXNPZmZzZXQ6IDAsXG4gICAgICBpc0JhY2t3YXJkOiBmYWxzZVxuICAgIH0pXG4gIH1cblxuICBzdGF0ZSA9IHN0YXRlLnNldCgnc2VsZWN0aW9uJywgc2VsZWN0aW9uKVxuICB0cmFuc2Zvcm0uc3RhdGUgPSBzdGF0ZVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIGBub2RlYCBhbmQgaXRzIGNoaWxkcmVuIHdpdGggYSBgc2NoZW1hYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVOb2RlQW5kQ2hpbGRyZW4odHJhbnNmb3JtLCBub2RlLCBzY2hlbWEpIHtcbiAgaWYgKG5vZGUua2luZCA9PSAndGV4dCcpIHtcbiAgICBub3JtYWxpemVOb2RlKHRyYW5zZm9ybSwgbm9kZSwgc2NoZW1hKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gV2UgY2FuJ3QganVzdCBsb29wIHRoZSBjaGlsZHJlbiBhbmQgbm9ybWFsaXplIHRoZW0sIGJlY2F1c2UgaW4gdGhlIHByb2Nlc3NcbiAgLy8gb2Ygbm9ybWFsaXppbmcgb25lIGNoaWxkLCB3ZSBtaWdodCBlbmQgdXAgY3JlYXRpbmcgYW5vdGhlci4gSW5zdGVhZCwgd2VcbiAgLy8gaGF2ZSB0byBub3JtYWxpemUgb25lIGF0IGEgdGltZSwgYW5kIGNoZWNrIGZvciBuZXcgY2hpbGRyZW4gYWxvbmcgdGhlIHdheS5cbiAgLy8gUEVSRjogdXNlIGEgbXV0YWJsZSBhcnJheSBoZXJlIGluc3RlYWQgb2YgYW4gaW1tdXRhYmxlIHN0YWNrLlxuICBjb25zdCBrZXlzID0gbm9kZS5ub2Rlcy50b0FycmF5KCkubWFwKG4gPT4gbi5rZXkpXG5cbiAgLy8gV2hpbGUgdGhlcmUgaXMgc3RpbGwgYSBjaGlsZCBrZXkgdGhhdCBoYXNuJ3QgYmVlbiBub3JtYWxpemVkIHlldC4uLlxuICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICBjb25zdCBvcHMgPSB0cmFuc2Zvcm0ub3BlcmF0aW9ucy5sZW5ndGhcbiAgICBsZXQga2V5XG5cbiAgICAvLyBQRVJGOiB1c2UgYSBtdXRhYmxlIHNldCBoZXJlIHNpbmNlIHdlJ2xsIGJlIGFkZCB0byBpdCBhIGxvdC5cbiAgICBsZXQgc2V0ID0gbmV3IFNldCgpLmFzTXV0YWJsZSgpXG5cbiAgICAvLyBVbndpbmQgdGhlIHN0YWNrLCBub3JtYWxpemluZyBldmVyeSBjaGlsZCBhbmQgYWRkaW5nIGl0IHRvIHRoZSBzZXQuXG4gICAgd2hpbGUgKGtleSA9IGtleXNbMF0pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRDaGlsZChrZXkpXG4gICAgICBub3JtYWxpemVOb2RlQW5kQ2hpbGRyZW4odHJhbnNmb3JtLCBjaGlsZCwgc2NoZW1hKVxuICAgICAgc2V0LmFkZChrZXkpXG4gICAgICBrZXlzLnNoaWZ0KClcbiAgICB9XG5cbiAgICAvLyBUdXJuIHRoZSBzZXQgaW1tdXRhYmxlIHRvIGJlIGFibGUgdG8gY29tcGFyZSBhZ2FpbnN0IGl0LlxuICAgIHNldCA9IHNldC5hc0ltbXV0YWJsZSgpXG5cbiAgICAvLyBQRVJGOiBPbmx5IHJlLWZpbmQgdGhlIG5vZGUgYW5kIHJlLW5vcm1hbGl6ZSBhbnkgbmV3IGNoaWxkcmVuIGlmXG4gICAgLy8gb3BlcmF0aW9ucyBvY2N1cmVkIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIGl0LlxuICAgIGlmICh0cmFuc2Zvcm0ub3BlcmF0aW9ucy5sZW5ndGggIT0gb3BzKSB7XG4gICAgICBub2RlID0gcmVmaW5kTm9kZSh0cmFuc2Zvcm0sIG5vZGUpXG5cbiAgICAgIC8vIEFkZCBhbnkgbmV3IGNoaWxkcmVuIGJhY2sgb250byB0aGUgc3RhY2suXG4gICAgICBub2RlLm5vZGVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKHNldC5oYXMobi5rZXkpKSByZXR1cm5cbiAgICAgICAga2V5cy51bnNoaWZ0KG4ua2V5KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBOb3JtYWxpemUgdGhlIG5vZGUgaXRzZWxmIGlmIGl0IHN0aWxsIGV4aXN0cy5cbiAgaWYgKG5vZGUpIHtcbiAgICBub3JtYWxpemVOb2RlKHRyYW5zZm9ybSwgbm9kZSwgc2NoZW1hKVxuICB9XG59XG5cbi8qKlxuICogUmUtZmluZCBhIHJlZmVyZW5jZSB0byBhIG5vZGUgdGhhdCBtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIG9yIHJlbW92ZWRcbiAqIGVudGlyZWx5IGJ5IGEgdHJhbnNmb3JtLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiByZWZpbmROb2RlKHRyYW5zZm9ybSwgbm9kZSkge1xuICBjb25zdCB7IHN0YXRlIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgcmV0dXJuIG5vZGUua2luZCA9PSAnZG9jdW1lbnQnXG4gICAgPyBkb2N1bWVudFxuICAgIDogZG9jdW1lbnQuZ2V0RGVzY2VuZGFudChub2RlLmtleSlcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBgbm9kZWAgd2l0aCBhIGBzY2hlbWFgLCBidXQgbm90IGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVOb2RlKHRyYW5zZm9ybSwgbm9kZSwgc2NoZW1hKSB7XG4gIGNvbnN0IG1heCA9IHNjaGVtYS5ydWxlcy5sZW5ndGhcbiAgbGV0IGl0ZXJhdGlvbnMgPSAwXG5cbiAgZnVuY3Rpb24gaXRlcmF0ZSh0LCBuKSB7XG4gICAgY29uc3QgZmFpbHVyZSA9IG4udmFsaWRhdGUoc2NoZW1hKVxuICAgIGlmICghZmFpbHVyZSkgcmV0dXJuXG5cbiAgICAvLyBSdW4gdGhlIGBub3JtYWxpemVgIGZ1bmN0aW9uIGZvciB0aGUgcnVsZSB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlLlxuICAgIGNvbnN0IHsgdmFsdWUsIHJ1bGUgfSA9IGZhaWx1cmVcbiAgICBydWxlLm5vcm1hbGl6ZSh0LCBuLCB2YWx1ZSlcblxuICAgIC8vIFJlLWZpbmQgdGhlIG5vZGUgcmVmZXJlbmNlLCBpbiBjYXNlIGl0IHdhcyB1cGRhdGVkLiBJZiB0aGUgbm9kZSBubyBsb25nZXJcbiAgICAvLyBleGlzdHMsIHdlJ3JlIGRvbmUgZm9yIHRoaXMgYnJhbmNoLlxuICAgIG4gPSByZWZpbmROb2RlKHQsIG4pXG4gICAgaWYgKCFuKSByZXR1cm5cblxuICAgIC8vIEluY3JlbWVudCB0aGUgaXRlcmF0aW9ucyBjb3VudGVyLCBhbmQgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgd2UgaGF2ZW4ndFxuICAgIC8vIGV4Y2VlZGVkIHRoZSBtYXguIFdpdGhvdXQgdGhpcyBjaGVjaywgaXQncyBlYXN5IGZvciB0aGUgYHZhbGlkYXRlYCBvclxuICAgIC8vIGBub3JtYWxpemVgIGZ1bmN0aW9uIG9mIGEgc2NoZW1hIHJ1bGUgdG8gYmUgd3JpdHRlbiBpbmNvcnJlY3RseSBhbmQgZm9yXG4gICAgLy8gYW4gaW5maW5pdGUgaW52YWxpZCBsb29wIHRvIG9jY3VyLlxuICAgIGl0ZXJhdGlvbnMrK1xuXG4gICAgaWYgKGl0ZXJhdGlvbnMgPiBtYXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBzY2hlbWEgcnVsZSBjb3VsZCBub3QgYmUgdmFsaWRhdGVkIGFmdGVyIHN1ZmZpY2llbnQgaXRlcmF0aW9ucy4gVGhpcyBpcyB1c3VhbGx5IGR1ZSB0byBhIGBydWxlLnZhbGlkYXRlYCBvciBgcnVsZS5ub3JtYWxpemVgIGZ1bmN0aW9uIG9mIGEgc2NoZW1hIGJlaW5nIGluY29ycmVjdGx5IHdyaXR0ZW4sIGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcC4nKVxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgaXRlcmF0ZSBhZ2Fpbi5cbiAgICBpdGVyYXRlKHQsIG4pXG4gIH1cblxuICBpdGVyYXRlKHRyYW5zZm9ybSwgbm9kZSlcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIGBzY2hlbWFgIGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0U2NoZW1hKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSBgc2NoZW1hYCBvYmplY3QuJylcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBwYXNzZWQgYW4gaW52YWxpZCBcXGBzY2hlbWFcXGAgb2JqZWN0OiAke3NjaGVtYX0uYClcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybXNcbiJdfQ==